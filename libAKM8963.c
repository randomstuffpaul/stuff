/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int __fastcall _cxa_finalize(_DWORD); weak
// int _android_log_print(_DWORD, _DWORD, const char *, ...); weak
// void *memset(void *s, int c, size_t n);
// char *strncpy(char *dest, const char *src, size_t n);
// int fscanf(FILE *stream, const char *format, ...);
// int strncmp(const char *s1, const char *s2, size_t n);
// int __fastcall _stack_chk_fail(_DWORD); weak
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// FILE *fopen(const char *filename, const char *modes);
// int fclose(FILE *stream);
// int _errno(void); weak
// char *strerror(int errnum);
// int fprintf(FILE *stream, const char *format, ...);
// void *memcpy(void *dest, const void *src, size_t n);
// int raise(int sig);
// int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD); weak
// void abort(void);
// int __fastcall _cxa_begin_cleanup(_DWORD); weak
// int __fastcall _cxa_type_match(_DWORD, _DWORD, _DWORD, _DWORD); weak
int sub_1960();
int getFormation();
void AKMD_Release();
signed int __fastcall AKMD_Init(int a1, int a2);
int __fastcall AKMD_Start(const char *a1);
signed int __fastcall AKMD_Stop(const char *a1);
signed int __fastcall AKMD_GetData(signed int a1, signed int a2, signed int a3, int a4, signed int a5, int a6, int a7, int a8, int a9, int a10, int a11, _DWORD *a12);
int AKMD_ResetDOE();
signed int __fastcall AKMD_ChangeFormation(signed int a1);
signed int __fastcall LoadInt(FILE *a1, const char *a2, int a3);
signed int __fastcall LoadInt16(FILE *a1, const char *a2, _WORD *a3);
signed int __fastcall LoadInt32(FILE *a1, const char *a2, const char **a3);
signed int __fastcall LoadInt16vec(FILE *a1, int a2, int a3);
signed int __fastcall LoadInt32vec(FILE *a1, int a2, int a3);
int __fastcall LoadParameters(const char *a1, int a2);
signed int __fastcall SaveInt16(FILE *a1, int a2, int a3);
signed int __fastcall SaveInt16vec(FILE *a1, int a2, int a3);
signed int __fastcall SaveInt32(FILE *a1, int a2, int a3);
signed int __fastcall SaveInt32vec(FILE *a1, int a2, int a3);
int __fastcall SaveParameters(const char *a1, int a2);
int __fastcall RegisterFormClass(int result);
signed int __fastcall InitAK8963PRMS(_WORD *a1);
int __fastcall SetDefaultPRMS(int result);
int __fastcall InitAK8963_Measure(int (__cdecl *a1)(_DWORD, _DWORD), int a2);
signed int __fastcall GetMagneticVector(int a1, int a2, int a3, __int16 a4);
int __fastcall AKSC_InitDecomp8963(int result);
int __fastcall sub_2C24(int a1, int a2);
signed int __fastcall sub_2D80(int a1, int *a2);
signed int __fastcall sub_2E5C(signed int a1, int a2, int a3);
int __fastcall AKSC_Decomp8963S3(int a1, signed int a2, int a3, int a4, int a5, int a6, _WORD *a7, int a8, signed __int16 *a9, signed __int16 *a10, _WORD *a11, _WORD *a12, _WORD *a13);
signed int __fastcall AKSC_Decomp8963(int a1, signed int a2, int a3, int a4, int a5, _WORD *a6, int a7, signed __int16 *a8, signed __int16 *a9, _WORD *a10, _WORD *a11);
int __fastcall AKSC_div16(int a1, int a2);
int __fastcall AKSC_div32(unsigned int a1, unsigned int a2);
int __fastcall AKSC_norm16(int a1);
int __fastcall AKSC_norm32(signed int a1);
int __fastcall AKSC_abs16(signed int a1);
int __fastcall AKSC_div16f(int a1, int a2, _WORD *a3);
int __fastcall sub_348C(int a1, int a2, int a3);
int __fastcall AKSC_SetLayout(int result, int a2);
int __fastcall AKSC_ThetaFilter(int a1, int a2, int a3);
signed int __fastcall sub_3838(int a1, int a2);
signed int __fastcall sub_39B8(int a1, _WORD *a2);
signed int __fastcall sub_3A74(int a1, int a2, int a3);
int __fastcall sub_3CDC(int a1, int a2, _WORD *a3);
int __fastcall sub_3D4C(int a1, int a2, signed __int16 *a3);
signed int __fastcall sub_3DE0(int a1, _WORD *a2, __int16 *a3, _WORD *a4, __int16 *a5);
int __fastcall sub_3EAC(int a1, _WORD *a2, _WORD *a3, _WORD *a4);
signed int __fastcall sub_3F7C(int a1, _WORD *a2);
int __fastcall AKSC_DirectionS3(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _WORD *a9, signed __int16 *a10, _WORD *a11, _WORD *a12, _WORD *a13, _WORD *a14, __int16 *a15, _WORD *a16, __int16 *a17, int a18, int a19);
signed int __fastcall AKSC_VNorm(int a1, int a2, int a3, int a4, int a5);
int __fastcall AKSC_cholSl(int a1, signed int a2, int a3, int a4, int a5, int a6);
signed int __fastcall AKSC_cholDc(int a1, signed int a2, int a3, int a4);
signed int __fastcall AKSC_fitOnPlane(int a1, int a2, int a3, int a4, _WORD *a5);
signed int __fastcall AKSC_getCoeff(int a1, int a2, int a3, int a4);
int __fastcall sub_4984(int a1, int a2, int a3);
int __fastcall AKSC_SetHDOELevel(int a1, int a2, __int16 a3, int a4);
signed int __fastcall zzAKSC_InitHDOEProcPrmsS3(int a1, int a2, int a3, __int16 a4, int a5, __int16 a6);
int __fastcall sub_4D50(int a1, int a2, int a3, int a4, _WORD *a5, _WORD *a6);
signed int __fastcall sub_4E64(int a1, int a2, int a3, int a4, _WORD *a5, _WORD *a6);
signed int __fastcall sub_4F18(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7);
signed int __fastcall sub_5008(_WORD *a1, _WORD *a2, _WORD *a3, int a4, int a5, __int16 *a6, _WORD *a7, __int16 a8);
int __fastcall zzAKSC_HDOEProcessS3(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9, _DWORD *a10);
signed int __fastcall AKSC_InitHFlucCheck(int a1, int a2, int a3);
signed int __fastcall AKSC_HFlucCheck(int a1, int a2);
_DWORD *__fastcall AKSC_TransByHbase(_DWORD *result, _DWORD *a2, int a3, int *a4, _WORD *a5);
signed int __fastcall sub_5710(int a1, int a2, _WORD *a3, int a4, _WORD *a5);
signed int __fastcall AKSC_HOffsetCal(int a1, _WORD *a2);
unsigned int __fastcall AKSC_sqrt16(int a1);
int __fastcall AKSC_sqrt32(unsigned int a1);
int __fastcall AKSC_angRng(int result, int a2);
unsigned int __fastcall AKSC_sin(int a1);
int __fastcall AKSC_cos(signed int a1);
int __fastcall sub_5A48(int a1);
int __fastcall AKSC_atan2(int a1, int a2);
int __fastcall AKSC_invSqrt(signed int a1, _WORD *a2);
int __fastcall AKSC_buffer(int result, signed int a2, signed int a3, int a4);
int __fastcall AKSC_vectorCalc(int result, signed int a2, signed __int16 *a3, signed __int16 *a4, int a5, int a6);
signed int AKSC_GetVersion_Major();
int AKSC_GetVersion_Variation();
signed int AKSC_GetVersion_DateCode();
int __fastcall sub_5F08(int result, unsigned int a2);
int _aeabi_ldiv0();
int __fastcall sub_600C(char *a1);
int __fastcall sub_6024(int a1, int a2, unsigned int a3);
int __fastcall sub_60C8(int a1);
_DWORD *__fastcall sub_611C(_DWORD *result);
signed int __fastcall sub_6188(int a1, int a2, int a3);
int __fastcall sub_6298(char *a1);
signed int sub_62AC();
int __fastcall nullsub_1(_DWORD, _DWORD); // weak
signed int __fastcall sub_62B8(int a1, int a2, int a3);
int __fastcall sub_63E0(int a1, int a2, int a3);
int __fastcall Unwind_GetCFA(int a1);
signed int __fastcall _gnu_Unwind_RaiseException(int a1, int a2);
signed int __fastcall _gnu_Unwind_ForcedUnwind(int a1, int a2, int a3, int a4);
void __fastcall _gnu_Unwind_Resume(int a1, int a2);
signed int __fastcall _gnu_Unwind_Resume_or_Rethrow(int a1, int a2);
int __fastcall Unwind_DeleteException(int result);
signed int __fastcall Unwind_VRS_Get(int a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5);
int __fastcall sub_660C(int a1, unsigned int a2, int a3, int a4);
signed int __fastcall Unwind_VRS_Set(int a1, _DWORD *a2, unsigned int a3, int a4, _DWORD *a5);
signed int __fastcall sub_6678(int a1, unsigned int a2, int a3);
signed int __fastcall sub_66A4(int a1, int a2, int a3, signed int a4);
signed int __fastcall _aeabi_unwind_cpp_pr2(int a1, int a2, int a3);
signed int __fastcall _aeabi_unwind_cpp_pr1(int a1, int a2, int a3);
signed int __fastcall _aeabi_unwind_cpp_pr0(int a1, int a2, int a3);
signed int __fastcall _gnu_Unwind_Backtrace(int (__fastcall *a1)(int *, int), int a2, int a3);
int __fastcall Unwind_VRS_Pop(int a1, int a2, unsigned int a3, int a4);
void __fastcall restore_core_regs(int a1);
int __fastcall _gnu_Unwind_Restore_VFP(int result);
int _gnu_Unwind_Save_VFP();
int __fastcall _gnu_Unwind_Restore_VFP_D(int _R0);
int __fastcall _gnu_Unwind_Save_VFP_D(int _R0);
int __fastcall _gnu_Unwind_Restore_VFP_D_16_to_31(int _R0);
int __fastcall _gnu_Unwind_Save_VFP_D_16_to_31(int _R0);
int __fastcall _gnu_Unwind_Restore_WMMXD(_DWORD *a1);
void _gnu_Unwind_Save_WMMXD();
int __fastcall _gnu_Unwind_Restore_WMMXC(_DWORD *a1);
void _gnu_Unwind_Save_WMMXC();
signed int __fastcall __Unwind_RaiseException(int a1, int a2, int a3, int a4);
void __fastcall __Unwind_Resume(int a1, int a2, int a3, int a4);
signed int __fastcall __Unwind_Resume_or_Rethrow(int a1, int a2, int a3, int a4);
signed int __fastcall __Unwind_ForcedUnwind(int a1, int a2, int a3, int a4);
signed int __fastcall __Unwind_Backtrace(int (__fastcall *a1)(int *, int), int a2, int a3, int a4);
signed int __fastcall sub_7094(int a1);
int __fastcall sub_70F0(int a1, int a2, int a3, int a4);
int sub_7118(void); // weak
signed int __fastcall _gnu_unwind_execute(int a1, int a2, int a3, int a4);
signed int __fastcall _gnu_unwind_frame(int a1, int a2, int a3, int a4);
int Unwind_GetRegionStart();
int Unwind_GetLanguageSpecificData();
void Unwind_GetDataRelBase();
void Unwind_GetTextRelBase();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_753C; // weak
_UNKNOWN unk_7D10; // weak
_UNKNOWN unk_7D68; // weak
_UNKNOWN unk_7DC7; // weak
_UNKNOWN unk_7E10; // weak
_WORD word_7E64[64] =
{
  286,
  858,
  1429,
  2000,
  2571,
  3141,
  3709,
  4277,
  4843,
  5408,
  5971,
  6533,
  7092,
  7649,
  8204,
  8757,
  9306,
  9853,
  10397,
  10938,
  11475,
  12009,
  12539,
  13066,
  13588,
  14107,
  14621,
  15130,
  15635,
  16135,
  16631,
  17121,
  17606,
  18085,
  18559,
  19028,
  19491,
  19947,
  20398,
  20842,
  21280,
  21712,
  22137,
  22555,
  22967,
  23371,
  23768,
  24158,
  24541,
  24916,
  25284,
  25644,
  25996,
  26340,
  26676,
  27004,
  27324,
  27635,
  27938,
  28233,
  28519,
  28796,
  29065,
  29324
}; // idb
__int16 word_7F18 = 285; // weak
char aEgiqmQiuvy[15] = "ÐeƒiQm=qIuvyÈ}"; // weak
_UNKNOWN I16V_INIT_VALUE; // weak
_UNKNOWN unk_7FDA; // weak
_UNKNOWN unk_7FDC; // weak
int GLOBAL_OFFSET_TABLE_[] = { 0 }; // weak
void *off_A000 = &off_A000; // weak
__int16 word_A004; // weak
__int16 word_A006; // weak
__int16 word_A008; // weak
__int16 word_A0F4; // weak
__int16 word_A0F6; // weak
__int16 word_A0F8; // weak
__int16 word_A0FA; // weak
__int16 word_A0FC; // weak
__int16 word_A0FE; // weak
_UNKNOWN unk_A100; // weak
int dword_A2F4; // weak
_UNKNOWN unk_A302; // weak
char byte_A312; // weak
_UNKNOWN unk_A313; // weak
char byte_A323; // weak
__int16 word_A324; // weak
__int16 word_A326; // weak
__int16 word_A328; // weak
__int16 word_A32A; // weak
__int16 word_A32C; // weak
int dword_A344; // weak
int dword_A348; // weak
int dword_A34C; // weak
__int16 word_A35C; // weak
__int16 word_A360; // weak
__int16 word_A362; // weak
int dword_A364; // weak
_UNKNOWN g_opmode; // weak
// extern _UNKNOWN _stack_chk_guard; weak
// extern _UNKNOWN _sF; weak
// extern _UNKNOWN __gnu_Unwind_Find_exidx; weak
// extern _UNKNOWN _cxa_call_unexpected; weak


//----- (00001960) --------------------------------------------------------
int sub_1960()
{
  return _cxa_finalize(&off_A000);
}
// 1870: using guessed type int __fastcall _cxa_finalize(_DWORD);
// A000: using guessed type void *off_A000;

//----- (000019BC) --------------------------------------------------------
int getFormation()
{
  return word_A360;
}
// A360: using guessed type __int16 word_A360;

//----- (000019CC) --------------------------------------------------------
void AKMD_Release()
{
  if ( word_A362 )
  {
    word_A362 = 0;
    word_A35C = 0;
    JUMPOUT(&loc_753C);
  }
}
// A35C: using guessed type __int16 word_A35C;
// A362: using guessed type __int16 word_A362;

//----- (00001A04) --------------------------------------------------------
signed int __fastcall AKMD_Init(int a1, int a2)
{
  int v2; // r6@1
  int v3; // r5@1
  const char *v4; // r1@4
  const char *v5; // r2@4
  __int16 v7; // r0@8

  v2 = a1;
  v3 = a2;
  if ( word_A362 )
    _android_log_print(3, "AKMD2", "AK8963PRMS is already initialized.");
  if ( v2 != 1 )
  {
    v4 = "AKMD2";
    v5 = "AKMD_Init: Invalid formFactorNumber.";
LABEL_7:
    _android_log_print(6, v4, v5);
    return -1;
  }
  if ( !v3 )
  {
    v4 = "AKMD2";
    v5 = "AKMD_Init: regs can't be NULL.";
    goto LABEL_7;
  }
  *(_WORD *)(v3 + 2) = 128;
  *(_WORD *)v3 = 72;
  *(_WORD *)(v3 + 4) = 128;
  *(_WORD *)(v3 + 6) = 128;
  AKMD_Release();
  memset(&word_A004, 0, 0x35Cu);
  word_A35C = 1;
  InitAK8963PRMS(&word_A004);
  word_A0FA = *(_WORD *)(v3 + 2);
  word_A0FC = *(_WORD *)(v3 + 4);
  v7 = *(_WORD *)(v3 + 6);
  word_A324 = 8963;
  word_A0FE = v7;
  word_A326 = *(_WORD *)v3;
  word_A328 = *(_WORD *)(v3 + 2);
  word_A32A = *(_WORD *)(v3 + 4);
  word_A32C = *(_WORD *)(v3 + 6);
  strncpy((char *)&unk_A302, "ASAHIKASEI", 0x10u);
  byte_A312 = 0;
  strncpy((char *)&unk_A313, "LGE_63_GB", 0x10u);
  byte_A323 = 0;
  word_A362 = 1;
  return 0;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// A004: using guessed type __int16 word_A004;
// A0FA: using guessed type __int16 word_A0FA;
// A0FC: using guessed type __int16 word_A0FC;
// A0FE: using guessed type __int16 word_A0FE;
// A312: using guessed type char byte_A312;
// A323: using guessed type char byte_A323;
// A324: using guessed type __int16 word_A324;
// A326: using guessed type __int16 word_A326;
// A328: using guessed type __int16 word_A328;
// A32A: using guessed type __int16 word_A32A;
// A32C: using guessed type __int16 word_A32C;
// A35C: using guessed type __int16 word_A35C;
// A362: using guessed type __int16 word_A362;

//----- (00001B04) --------------------------------------------------------
int __fastcall AKMD_Start(const char *a1)
{
  const char *v1; // r1@2
  const char *v2; // r2@2
  int v3; // r1@5
  int result; // r0@7

  if ( !word_A362 )
  {
    v1 = "AKMD2";
    v2 = "AKMD_Start: PRMS are not initialized.";
LABEL_9:
    _android_log_print(6, v1, v2);
    return -1;
  }
  if ( !a1 )
  {
    v1 = "AKMD2";
    v2 = "AKMD_Start: path can't be NULL.";
    goto LABEL_9;
  }
  if ( !LoadParameters(a1, (int)&word_A004) )
  {
    _android_log_print(4, "AKMD2", "AKMD_Start: Setting file cannot be read.");
    SetDefaultPRMS((int)&word_A004);
  }
  result = InitAK8963_Measure((int (__cdecl *)(_DWORD, _DWORD))&word_A004, v3);
  if ( result )
  {
    v1 = "AKMD2";
    v2 = "AKMD_Start: Start error.";
    goto LABEL_9;
  }
  return result;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// A004: using guessed type __int16 word_A004;
// A362: using guessed type __int16 word_A362;

//----- (00001B94) --------------------------------------------------------
signed int __fastcall AKMD_Stop(const char *a1)
{
  const char *v1; // r1@2
  const char *v2; // r2@2

  if ( !word_A362 )
  {
    v1 = "AKMD2";
    v2 = "AKMD_Start: PRMS are not initialized.";
LABEL_7:
    _android_log_print(6, v1, v2);
    return -1;
  }
  if ( !a1 )
  {
    v1 = "AKMD2";
    v2 = "AKMD_Start: path can't be NULL.";
    goto LABEL_7;
  }
  if ( !SaveParameters(a1, (int)&word_A004) )
  {
    v1 = "AKMD2";
    v2 = "AKMD_Stop: Setting file cannot be written.";
    goto LABEL_7;
  }
  return 0;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// A004: using guessed type __int16 word_A004;
// A362: using guessed type __int16 word_A362;

//----- (00001C00) --------------------------------------------------------
signed int __fastcall AKMD_GetData(signed int a1, signed int a2, signed int a3, int a4, signed int a5, int a6, int a7, int a8, int a9, int a10, int a11, _DWORD *a12)
{
  const char *v15; // r1@4
  const char *v16; // r2@4
  signed int v24; // r0@9
  __int16 v32; // [sp+8h] [bp-20h]@9
  __int16 v33; // [sp+Ah] [bp-1Eh]@9
  __int16 v34; // [sp+Ch] [bp-1Ch]@9
  __int16 v35; // [sp+Eh] [bp-1Ah]@9
  __int16 v36; // [sp+10h] [bp-18h]@9
  __int16 v37; // [sp+12h] [bp-16h]@9
  __int16 v38; // [sp+14h] [bp-14h]@9
  __int16 v39; // [sp+16h] [bp-12h]@9

  _R4 = a3;
  _R5 = a1;
  _R3 = a2;
  if ( !word_A362 )
  {
    _android_log_print(6, "AKMD2", "AKMD_SaveMag: PRMS are not initialized.", a2);
    return -1;
  }
  if ( (unsigned int)(a1 + 3219128) > 0x623D70 )
  {
    _R3 = a1;
    v15 = "AKMD2";
    v16 = "AKMD_SaveMag: Invalid ix value (%d).";
LABEL_18:
    _android_log_print(6, v15, v16, _R3);
    return -1;
  }
  if ( (unsigned int)(a2 + 3219128) > 0x623D70 )
  {
    v15 = "AKMD2";
    v16 = "AKMD_SaveMag: Invalid iy value (%d).";
    goto LABEL_18;
  }
  if ( (unsigned int)(a3 + 3219128) > 0x623D70 )
  {
    _R3 = a3;
    v15 = "AKMD2";
    v16 = "AKMD_SaveMag: Invalid iz value (%d).";
    goto LABEL_18;
  }
  __asm
  {
    VMOV            S2, R3
    VCVT.F64.S32    D2, S2
    VLDR            D16, =0.010172526
    VMOV            S15, R5
    VMUL.F64        D3, D2, D16
    VMOV            S5, R4
    VCVT.F64.S32    D4, S5
    VCVT.F64.S32    D17, S15
    VMUL.F64        D5, D4, D16
    VMUL.F64        D0, D17, D16
    VCVTR.S32.F64   S3, D3
    VCVTR.S32.F64   S7, D5
    VMOV            R5, S3
    VCVTR.S32.F64   S1, D0
    VMOV            R4, S7
    VMOV            R6, S1
  }
  _android_log_print(3, "AKMD2", "REG DATA:%d,%d,%d", (signed __int16)_R6, (signed __int16)_R5, (signed __int16)_R4);
  v32 = 1;
  v33 = (unsigned __int8)_R6;
  v36 = (unsigned __int16)_R5 >> 8;
  v35 = _R5;
  v37 = (unsigned __int8)_R4;
  v39 = 16;
  v38 = (unsigned __int16)_R4 >> 8;
  v34 = (unsigned __int16)_R6 >> 8;
  v24 = GetMagneticVector((int)&v32, (int)&word_A004, word_A360, a5 / 10);
  _R3 = v24;
  if ( !v24 )
  {
    _R0 = word_A0F4;
    __asm
    {
      VMOV            S9, R0
      VCVT.F64.S32    D6, S9
      VLDR            D18, =0.06
      VMUL.F64        D7, D6, D18
      VCVT.F32.F64    S11, D7
      VSTR            S11, [R2]
    }
    _R1 = word_A0F6;
    __asm
    {
      VMOV            S13, R1
      VCVT.F64.S32    D19, S13
      VMUL.F64        D20, D19, D18
      VCVT.F32.F64    S15, D20
      VSTR            S15, [R0]
    }
    _LR = word_A0F8;
    __asm
    {
      VMOV            S0, LR
      VCVT.F64.S32    D21, S0
      VMUL.F64        D22, D21, D18
      VCVT.F32.F64    S1, D22
      VSTR            S1, [R2]
    }
    _R0 = word_A004 + dword_A344;
    __asm
    {
      VMOV            S2, R0
      VCVT.F64.S32    D23, S2
      VMUL.F64        D24, D23, D18
      VCVT.F32.F64    S4, D24
      VSTR            S4, [R2]
    }
    _R0 = word_A006 + dword_A348;
    __asm
    {
      VMOV            S6, R0
      VCVT.F64.S32    D25, S6
      VMUL.F64        D26, D25, D18
      VCVT.F32.F64    S3, D26
      VSTR            S3, [R2]
    }
    _R0 = word_A008 + dword_A34C;
    __asm
    {
      VMOV            S5, R0
      VCVT.F64.S32    D27, S5
      VMUL.F64        D28, D27, D18
      VCVT.F32.F64    S8, D28
      VSTR            S8, [R2]
    }
    *a12 = dword_A2F4;
    return _R3;
  }
  if ( v24 != 1 && v24 != 2 && v24 != 4 && v24 != 8 && v24 != 16 && v24 != 32 && v24 != 64 )
  {
    v15 = "AKMD2";
    v16 = "GetMagneticVector has failed (0x%04X).\n";
    goto LABEL_18;
  }
  return -1;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// A004: using guessed type __int16 word_A004;
// A006: using guessed type __int16 word_A006;
// A008: using guessed type __int16 word_A008;
// A0F4: using guessed type __int16 word_A0F4;
// A0F6: using guessed type __int16 word_A0F6;
// A0F8: using guessed type __int16 word_A0F8;
// A2F4: using guessed type int dword_A2F4;
// A344: using guessed type int dword_A344;
// A348: using guessed type int dword_A348;
// A34C: using guessed type int dword_A34C;
// A360: using guessed type __int16 word_A360;
// A362: using guessed type __int16 word_A362;

//----- (00001E70) --------------------------------------------------------
int AKMD_ResetDOE()
{
  return AKSC_SetHDOELevel((int)&unk_A100, (int)&word_A004, 0, 1);
}
// A004: using guessed type __int16 word_A004;

//----- (00001E84) --------------------------------------------------------
signed int __fastcall AKMD_ChangeFormation(signed int a1)
{
  const char *v1; // r1@2
  const char *v2; // r2@2

  if ( !word_A362 )
  {
    v1 = "AKMD2";
    v2 = "AKMD_ChangeFormFactor: PRMS are not initialized.";
LABEL_6:
    _android_log_print(6, v1, v2);
    return -1;
  }
  if ( a1 < 0 || word_A35C <= a1 )
  {
    v1 = "AKMD2";
    v2 = "AKMD_ChangeFormFactor: Invalid formFactorNumber.";
    goto LABEL_6;
  }
  word_A360 = a1;
  return 0;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// A35C: using guessed type __int16 word_A35C;
// A360: using guessed type __int16 word_A360;
// A362: using guessed type __int16 word_A362;

//----- (00001EE8) --------------------------------------------------------
signed int __fastcall LoadInt(FILE *a1, const char *a2, int a3)
{
  const char *v3; // r4@1
  FILE *v4; // r7@1
  int v5; // r6@1
  signed int result; // r0@5
  char s; // [sp+Ch] [bp-5Ch]@1
  int v8; // [sp+4Ch] [bp-1Ch]@1

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v8 = _stack_chk_guard;
  memset(&s, 0, 0x40u);
  if ( fscanf(v4, "%63s = %11d", &s, v5) != 2 )
  {
    _android_log_print(6, "AKMD2", "%s: scanf error.");
LABEL_5:
    result = 0;
    goto LABEL_7;
  }
  if ( strncmp(&s, v3, 0x40u) )
  {
    _android_log_print(6, "AKMD2", "%s: strncmp (%s) error.", "LoadInt", v3);
    goto LABEL_5;
  }
  result = 1;
LABEL_7:
  if ( v8 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 18C4: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00001F88) --------------------------------------------------------
signed int __fastcall LoadInt16(FILE *a1, const char *a2, _WORD *a3)
{
  _WORD *v3; // r4@1
  signed int result; // r0@1
  const char *v5; // [sp+4h] [bp-Ch]@1

  v5 = a2;
  v3 = a3;
  result = LoadInt(a1, a2, (int)&v5);
  if ( result == 1 )
    *v3 = (_WORD)v5;
  else
    LOWORD(result) = 0;
  return (signed __int16)result;
}

//----- (00001FA0) --------------------------------------------------------
signed int __fastcall LoadInt32(FILE *a1, const char *a2, const char **a3)
{
  const char **v3; // r4@1
  signed int result; // r0@1
  const char *v5; // [sp+4h] [bp-Ch]@1

  v5 = a2;
  v3 = a3;
  result = LoadInt(a1, a2, (int)&v5);
  if ( result == 1 )
    *v3 = v5;
  else
    LOWORD(result) = 0;
  return (signed __int16)result;
}

//----- (00001FB8) --------------------------------------------------------
signed int __fastcall LoadInt16vec(FILE *a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r6@1
  FILE *v5; // r5@1
  signed int v6; // r8@1
  signed int result; // r0@3
  char s; // [sp+4h] [bp-5Ch]@1
  int v9; // [sp+44h] [bp-1Ch]@1

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v9 = _stack_chk_guard;
  snprintf(&s, 0x40u, "%s.x", a2);
  v6 = LoadInt16(v5, &s, (_WORD *)v3);
  snprintf(&s, 0x40u, "%s.y", v4);
  if ( v6 )
    v6 = LoadInt16(v5, &s, (_WORD *)(v3 + 2)) != 0;
  snprintf(&s, 0x40u, "%s.z", v4);
  result = v6;
  if ( v6 )
    result = LoadInt16(v5, &s, (_WORD *)(v3 + 4)) != 0;
  if ( v9 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 18C4: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (0000205C) --------------------------------------------------------
signed int __fastcall LoadInt32vec(FILE *a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r6@1
  FILE *v5; // r5@1
  signed int v6; // r8@1
  signed int result; // r0@3
  char s; // [sp+4h] [bp-5Ch]@1
  int v9; // [sp+44h] [bp-1Ch]@1

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v9 = _stack_chk_guard;
  snprintf(&s, 0x40u, "%s.x", a2);
  v6 = LoadInt32(v5, &s, (const char **)v3);
  snprintf(&s, 0x40u, "%s.y", v4);
  if ( v6 )
    v6 = LoadInt32(v5, &s, (const char **)(v3 + 4)) != 0;
  snprintf(&s, 0x40u, "%s.z", v4);
  result = v6;
  if ( v6 )
    result = LoadInt32(v5, &s, (const char **)(v3 + 8)) != 0;
  if ( v9 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 18C4: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00002104) --------------------------------------------------------
int __fastcall LoadParameters(const char *a1, int a2)
{
  int v2; // r6@1
  FILE *v3; // r4@1
  signed int v4; // r8@2
  int v5; // r6@7
  int *v6; // r0@12
  char *v7; // r0@12
  int *v8; // r0@13
  char *v9; // r0@13
  int *v10; // r0@15
  char *v11; // r0@15
  int *v12; // r0@16
  char *v13; // r0@16
  int result; // r0@17
  __int16 v15; // [sp+12h] [bp-66h]@2
  char s; // [sp+14h] [bp-64h]@2
  int v17; // [sp+54h] [bp-24h]@1

  v2 = a2;
  v17 = _stack_chk_guard;
  v3 = fopen(a1, "r");
  if ( v3 )
  {
    snprintf(&s, 0x40u, "HSUC_HDST_FORM%d", 0);
    v15 = 0;
    v4 = LoadInt16(v3, &s, &v15);
    *(_DWORD *)(v2 + 756) = v15;
    snprintf(&s, 0x40u, "HSUC_HO_FORM%d", 0);
    if ( v4 )
      v4 = LoadInt16vec(v3, (int)&s, v2 + 6) != 0;
    snprintf(&s, 0x40u, "HFLUCV_HREF_FORM%d", 0);
    if ( v4 )
      v4 = LoadInt16vec(v3, (int)&s, v2 + 30) != 0;
    snprintf(&s, 0x40u, "HSUC_HBASE_FORM%d", 0);
    if ( v4 )
      v5 = LoadInt32vec(v3, (int)&s, v2 + 844) != 0;
    else
      v5 = 0;
    if ( fclose(v3) )
    {
      if ( g_opmode )
      {
        v12 = (int *)_errno();
        v13 = strerror(*v12);
        fprintf((FILE *)((char *)&_sF + 168), "%s:%d %s Error (%s).\n", "LoadParameters", 67, "fclose", v13);
      }
      else
      {
        v10 = (int *)_errno();
        v11 = strerror(*v10);
        _android_log_print(6, "AKMD2", "%s:%d %s Error (%s).", "LoadParameters", 67, "fclose", v11);
      }
    }
    else
    {
      LOWORD(result) = 1;
      if ( v5 )
        goto LABEL_20;
    }
    _android_log_print(6, "AKMD2", "%s: failed.", "LoadParameters");
  }
  else if ( g_opmode )
  {
    v8 = (int *)_errno();
    v9 = strerror(*v8);
    fprintf((FILE *)((char *)&_sF + 168), "%s:%d %s Error (%s).\n", "LoadParameters", 43, "fopen", v9);
  }
  else
  {
    v6 = (int *)_errno();
    v7 = strerror(*v6);
    _android_log_print(6, "AKMD2", "%s:%d %s Error (%s).", "LoadParameters", 43, "fopen", v7);
  }
  LOWORD(result) = 0;
LABEL_20:
  result = (signed __int16)result;
  if ( v17 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 18C4: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 18F4: using guessed type int _errno(void);

//----- (0000232C) --------------------------------------------------------
signed int __fastcall SaveInt16(FILE *a1, int a2, int a3)
{
  int v3; // r4@1
  signed int result; // r0@2

  v3 = a2;
  if ( fprintf(a1, "%s = %d\n", a2, a3, a1, a2) >= 0 )
  {
    result = 1;
  }
  else
  {
    _android_log_print(6, "AKMD2", "%s: printf (%s) error.", "SaveInt16", v3);
    result = 0;
  }
  return result;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (0000236C) --------------------------------------------------------
signed int __fastcall SaveInt16vec(FILE *a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r6@1
  FILE *v5; // r5@1
  signed int v6; // r8@1
  signed int result; // r0@3
  char s; // [sp+4h] [bp-5Ch]@1
  int v9; // [sp+44h] [bp-1Ch]@1

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v9 = _stack_chk_guard;
  snprintf(&s, 0x40u, "%s.x", a2);
  v6 = SaveInt16(v5, (int)&s, *(_WORD *)v3);
  snprintf(&s, 0x40u, "%s.y", v4);
  if ( v6 )
    v6 = SaveInt16(v5, (int)&s, *(_WORD *)(v3 + 2)) != 0;
  snprintf(&s, 0x40u, "%s.z", v4);
  result = v6;
  if ( v6 )
    result = SaveInt16(v5, (int)&s, *(_WORD *)(v3 + 4)) != 0;
  if ( v9 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 18C4: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00002418) --------------------------------------------------------
signed int __fastcall SaveInt32(FILE *a1, int a2, int a3)
{
  int v3; // r4@1
  signed int result; // r0@2

  v3 = a2;
  if ( fprintf(a1, "%s = %ld\n", a2, a3, a1, a2) >= 0 )
  {
    result = 1;
  }
  else
  {
    _android_log_print(6, "AKMD2", "%s: printf (%s) error.", "SaveInt32", v3);
    result = 0;
  }
  return result;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00002458) --------------------------------------------------------
signed int __fastcall SaveInt32vec(FILE *a1, int a2, int a3)
{
  int v3; // r4@1
  int v4; // r6@1
  FILE *v5; // r5@1
  signed int v6; // r8@1
  signed int result; // r0@3
  char s; // [sp+4h] [bp-5Ch]@1
  int v9; // [sp+44h] [bp-1Ch]@1

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v9 = _stack_chk_guard;
  snprintf(&s, 0x40u, "%s.x", a2);
  v6 = SaveInt32(v5, (int)&s, *(_DWORD *)v3);
  snprintf(&s, 0x40u, "%s.y", v4);
  if ( v6 )
    v6 = SaveInt32(v5, (int)&s, *(_DWORD *)(v3 + 4)) != 0;
  snprintf(&s, 0x40u, "%s.z", v4);
  result = v6;
  if ( v6 )
    result = SaveInt32(v5, (int)&s, *(_DWORD *)(v3 + 8)) != 0;
  if ( v9 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 18C4: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (000024FC) --------------------------------------------------------
int __fastcall SaveParameters(const char *a1, int a2)
{
  int v2; // r6@1
  FILE *v3; // r4@1
  signed int v4; // r8@2
  int v5; // r6@7
  int *v6; // r0@12
  char *v7; // r0@12
  int *v8; // r0@13
  char *v9; // r0@13
  int *v10; // r0@15
  char *v11; // r0@15
  int *v12; // r0@16
  char *v13; // r0@16
  int result; // r0@17
  char s; // [sp+14h] [bp-5Ch]@2
  int v16; // [sp+54h] [bp-1Ch]@1

  v2 = a2;
  v16 = _stack_chk_guard;
  v3 = fopen(a1, "w");
  if ( v3 )
  {
    snprintf(&s, 0x40u, "HSUC_HDST_FORM%d", 0);
    v4 = SaveInt16(v3, (int)&s, *(_WORD *)(v2 + 756));
    snprintf(&s, 0x40u, "HSUC_HO_FORM%d", 0);
    if ( v4 )
      v4 = SaveInt16vec(v3, (int)&s, v2 + 6) != 0;
    snprintf(&s, 0x40u, "HFLUCV_HREF_FORM%d", 0);
    if ( v4 )
      v4 = SaveInt16vec(v3, (int)&s, v2 + 30) != 0;
    snprintf(&s, 0x40u, "HSUC_HBASE_FORM%d", 0);
    if ( v4 )
      v5 = SaveInt32vec(v3, (int)&s, v2 + 844) != 0;
    else
      v5 = 0;
    if ( fclose(v3) )
    {
      if ( g_opmode )
      {
        v12 = (int *)_errno();
        v13 = strerror(*v12);
        fprintf((FILE *)((char *)&_sF + 168), "%s:%d %s Error (%s).\n", "SaveParameters", 227, "fclose", v13);
      }
      else
      {
        v10 = (int *)_errno();
        v11 = strerror(*v10);
        _android_log_print(6, "AKMD2", "%s:%d %s Error (%s).", "SaveParameters", 227, "fclose", v11);
      }
    }
    else
    {
      LOWORD(result) = 1;
      if ( v5 )
        goto LABEL_20;
    }
    _android_log_print(6, "AKMD2", "%s: failed.", "SaveParameters");
  }
  else if ( g_opmode )
  {
    v8 = (int *)_errno();
    v9 = strerror(*v8);
    fprintf((FILE *)((char *)&_sF + 168), "%s:%d %s Error (%s).\n", "SaveParameters", 208, "fopen", v9);
  }
  else
  {
    v6 = (int *)_errno();
    v7 = strerror(*v6);
    _android_log_print(6, "AKMD2", "%s:%d %s Error (%s).", "SaveParameters", 208, "fopen", v7);
  }
  LOWORD(result) = 0;
LABEL_20:
  result = (signed __int16)result;
  if ( v16 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 18C4: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 18F4: using guessed type int _errno(void);

//----- (00002718) --------------------------------------------------------
int __fastcall RegisterFormClass(int result)
{
  dword_A364 = result;
  return result;
}
// A364: using guessed type int dword_A364;

//----- (00002724) --------------------------------------------------------
signed int __fastcall InitAK8963PRMS(_WORD *a1)
{
  _WORD *v1; // r4@1
  signed int result; // r0@1

  v1 = a1;
  memset(a1, 0, 0x35Cu);
  result = 1;
  v1[12] = 833;
  v1[13] = 833;
  v1[14] = 833;
  v1[118] = 1;
  return result;
}

//----- (00002744) --------------------------------------------------------
int __fastcall SetDefaultPRMS(int result)
{
  *(_DWORD *)(result + 756) = 0;
  *(_WORD *)(result + 6) = 0;
  *(_WORD *)(result + 8) = 0;
  *(_WORD *)(result + 10) = 0;
  *(_WORD *)(result + 30) = 0;
  *(_WORD *)(result + 32) = 0;
  *(_WORD *)(result + 34) = 0;
  *(_DWORD *)(result + 844) = 0;
  *(_DWORD *)(result + 848) = 0;
  *(_DWORD *)(result + 852) = 0;
  return result;
}

//----- (00002764) --------------------------------------------------------
int __fastcall InitAK8963_Measure(int (__cdecl *a1)(_DWORD, _DWORD), int a2)
{
  int v2; // r4@1
  int v3; // lr@4
  int v4; // r3@4
  int v5; // r5@4
  int v6; // r12@4
  int v7; // r1@4
  int v8; // r2@4
  int result; // r0@4

  v2 = (int)a1;
  LOWORD(a1) = dword_A364;
  if ( dword_A364 )
  {
    a1 = *(int (__cdecl **)(_DWORD, _DWORD))(dword_A364 + 8);
    if ( a1 )
      LOWORD(a1) = a1(a1, a2);
  }
  *(_WORD *)(v2 + 760) = (_WORD)a1;
  v3 = v2 + 832;
  v4 = v2 + 6 * (signed __int16)a1;
  v5 = v2 + 6 * (signed __int16)a1;
  *(_DWORD *)v2 = *(_DWORD *)(v5 + 6);
  *(_WORD *)(v2 + 4) = *(_WORD *)(v5 + 10);
  *(_DWORD *)(v2 + 12) = *(_WORD *)(v4 + 6);
  *(_DWORD *)(v2 + 16) = *(_WORD *)(v4 + 8);
  *(_DWORD *)(v2 + 20) = *(_WORD *)(v4 + 10);
  v6 = v2 + 12 * (signed __int16)a1;
  *(_DWORD *)(v2 + 752) = *(_DWORD *)(v2 + 4 * (signed __int16)a1 + 756);
  v7 = *(_DWORD *)(v6 + 848);
  v8 = *(_DWORD *)(v6 + 852);
  *(_DWORD *)v3 = *(_DWORD *)(v6 + 844);
  *(_DWORD *)(v3 + 4) = v7;
  *(_DWORD *)(v3 + 8) = v8;
  AKSC_InitDecomp8963(v2 + 44);
  zzAKSC_InitHDOEProcPrmsS3(v2 + 252, 0, 0, 1, v2, *(_DWORD *)(v2 + 752));
  AKSC_InitHFlucCheck(v2 + 36, v2 + 6 * *(_WORD *)(v2 + 760) + 30, 2500);
  result = 0;
  *(_WORD *)(v2 + 762) = 0;
  *(_WORD *)(v2 + 764) = 0;
  return result;
}
// A364: using guessed type int dword_A364;

//----- (00002804) --------------------------------------------------------
signed int __fastcall GetMagneticVector(int a1, int a2, int a3, __int16 a4)
{
  int v4; // r4@1
  int v5; // r7@1
  int v6; // r12@1
  int v7; // r6@1
  int v8; // r11@1
  int v9; // r0@1
  int v10; // r1@1
  int v11; // r2@1
  __int16 v12; // r10@1
  int v13; // lr@2
  int v14; // r2@3
  int v15; // r3@3
  int v16; // r1@3
  int v17; // r12@3
  int v18; // r1@3
  int v19; // r2@3
  signed int result; // r0@7
  signed int v21; // r5@14
  __int16 v22; // r2@25
  int v23; // r0@26
  int v24; // lr@32
  int v25; // r2@32
  int v26; // r3@32
  int v27; // r0@32
  int v28; // r1@32
  int v29; // r1@32
  int v30; // r2@32
  int v31; // r3@32
  __int16 v32; // [sp+42h] [bp-4Eh]@1
  __int16 v33; // [sp+44h] [bp-4Ch]@1
  __int16 v34; // [sp+46h] [bp-4Ah]@1
  __int16 v35; // [sp+48h] [bp-48h]@1
  __int16 v36; // [sp+4Ah] [bp-46h]@1
  __int16 v37; // [sp+4Ch] [bp-44h]@1
  __int16 v38; // [sp+4Eh] [bp-42h]@1
  __int16 v39; // [sp+50h] [bp-40h]@1
  __int16 v40; // [sp+54h] [bp-3Ch]@1
  __int16 v41; // [sp+56h] [bp-3Ah]@1
  __int16 v42; // [sp+58h] [bp-38h]@1
  int v43; // [sp+5Ch] [bp-34h]@1
  int v44; // [sp+60h] [bp-30h]@1
  int v45; // [sp+64h] [bp-2Ch]@1

  v4 = a2;
  v5 = a2 + 832;
  v6 = *(_WORD *)(a2 + 762);
  v7 = a1;
  v8 = a3;
  v9 = *(_DWORD *)(a2 + 832);
  v10 = *(_DWORD *)(a2 + 836);
  v11 = *(_DWORD *)(v5 + 8);
  v12 = a4;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v43 = v9;
  v44 = v10;
  v45 = v11;
  v36 = 0;
  if ( v6 > 0 )
  {
    v13 = v6 - 1;
    *(_WORD *)(v4 + 762) = v6 - 1;
    if ( v6 == 1 )
    {
      v14 = *(_WORD *)(v4 + 760);
      v15 = v4 + 6 * v14;
      v16 = v4 + 6 * v14;
      *(_DWORD *)v4 = *(_DWORD *)(v16 + 6);
      *(_WORD *)(v4 + 4) = *(_WORD *)(v16 + 10);
      *(_DWORD *)(v4 + 12) = *(_WORD *)(v15 + 6);
      *(_DWORD *)(v4 + 16) = *(_WORD *)(v15 + 8);
      *(_DWORD *)(v4 + 20) = *(_WORD *)(v15 + 10);
      v17 = v4 + 12 * v14;
      *(_DWORD *)(v4 + 752) = *(_DWORD *)(v4 + 4 * v14 + 756);
      v18 = *(_DWORD *)(v17 + 848);
      v19 = *(_DWORD *)(v17 + 852);
      *(_DWORD *)v5 = *(_DWORD *)(v17 + 844);
      *(_DWORD *)(v5 + 4) = v18;
      *(_DWORD *)(v5 + 8) = v19;
      AKSC_InitDecomp8963(v4 + 44);
      zzAKSC_InitHDOEProcPrmsS3(v4 + 252, v13, v13, 1, v4, *(_DWORD *)(v4 + 752));
      AKSC_InitHFlucCheck(v4 + 36, v4 + 6 * *(_WORD *)(v4 + 760) + 30, 2500);
    }
  }
  if ( !AKSC_Decomp8963(
          v7,
          *(_WORD *)(v4 + 236),
          v4 + 246,
          v4 + 44,
          v4 + 832,
          (_WORD *)(v4 + 238),
          (int)&v40,
          &v32,
          &v33,
          &v34,
          &v35) )
  {
    _android_log_print(
      3,
      "AKMD2",
      "AKSC_Decomp8963 failed.\n"
      "  ST1=0x%02X, ST2=0x%02X\n"
      "  XYZ(HEX)=%02X,%02X,%02X,%02X,%02X,%02X\n"
      "  asa(dec)=%d,%d,%d\n"
      "  hbase(dec)=%ld,%ld,%ld\n",
      *(_WORD *)v7,
      *(_WORD *)(v7 + 14),
      *(_WORD *)(v7 + 2),
      *(_WORD *)(v7 + 4),
      *(_WORD *)(v7 + 6),
      *(_WORD *)(v7 + 8),
      *(_WORD *)(v7 + 10),
      *(_WORD *)(v7 + 12),
      *(_WORD *)(v4 + 246),
      *(_WORD *)(v4 + 248),
      *(_WORD *)(v4 + 250),
      *(_DWORD *)(v4 + 832),
      *(_DWORD *)(v4 + 836),
      *(_DWORD *)(v4 + 840));
    return 128;
  }
  if ( *(_WORD *)(v4 + 760) != v8 )
  {
    *(_WORD *)(v4 + 760) = v8;
    result = 1;
    *(_WORD *)(v4 + 762) = 8;
    *(_WORD *)(v4 + 764) = 0;
    return result;
  }
  if ( v33 == 1 )
  {
    result = 2;
  }
  else if ( v34 == 1 )
  {
    if ( (signed int)*(_WORD *)(v4 + 762) <= 0 )
    {
      AKSC_SetHDOELevel(v4 + 252, v4, 0, 1);
      *(_DWORD *)(v4 + 752) = 0;
    }
    result = 4;
  }
  else if ( v35 == 1 )
  {
    AKSC_TransByHbase(&v43, (_DWORD *)(v4 + 832), v4, (int *)(v4 + 12), &v36);
    if ( v36 == 1 )
      v21 = 8;
    else
      v21 = 0;
    AKSC_InitHFlucCheck(v4 + 36, (int)&v37, 2500);
    if ( (signed int)*(_WORD *)(v4 + 762) <= 0 )
    {
      AKSC_SetHDOELevel(v4 + 252, v4, 0, 1);
      *(_DWORD *)(v4 + 752) = 0;
    }
    if ( v21 )
      result = 24;
    else
      result = 16;
  }
  else
  {
    if ( (signed int)*(_WORD *)(v4 + 762) <= 0 )
    {
      if ( AKSC_HFlucCheck(v4 + 36, v4 + 44) == 1 )
      {
        AKSC_SetHDOELevel(v4 + 252, v4, 0, 1);
        result = 32;
        *(_DWORD *)(v4 + 752) = 0;
        return result;
      }
      v22 = *(_WORD *)(v4 + 764) - 1;
      *(_WORD *)(v4 + 764) = v22;
      if ( v22 <= 0 )
      {
        v23 = zzAKSC_HDOEProcessS3(
                v4 + 766,
                v4 + 783,
                v4 + 800,
                v4 + 252,
                v4 + 44,
                *(_WORD *)(v4 + 238),
                0,
                1,
                v4,
                (_DWORD *)(v4 + 752));
        if ( v23 == -32768 )
        {
          if ( g_opmode )
            fprintf((FILE *)((char *)&_sF + 168), "%s:%d Error.\n", "GetMagneticVector", 653);
          else
            _android_log_print(6, "AKMD2", "%s:%d Error.", "GetMagneticVector", 653);
          return 128;
        }
        if ( v23 > 0 )
        {
          v24 = *(_WORD *)(v4 + 760);
          v25 = v4 + 6 * v24;
          *(_DWORD *)(v25 + 6) = *(_DWORD *)v4;
          *(_WORD *)(v25 + 10) = *(_WORD *)(v4 + 4);
          v26 = *(_WORD *)v4;
          v27 = *(_WORD *)(v4 + 4);
          *(_DWORD *)(v4 + 16) = *(_WORD *)(v4 + 2);
          v28 = *(_DWORD *)(v4 + 752);
          *(_DWORD *)(v4 + 12) = v26;
          *(_DWORD *)(v4 + 20) = v27;
          *(_DWORD *)(v4 + 4 * v24 + 756) = v28;
          *(_DWORD *)(v25 + 30) = *(_DWORD *)(v4 + 36);
          *(_WORD *)(v25 + 34) = *(_WORD *)(v4 + 40);
          v29 = *(_DWORD *)(v4 + 836);
          v30 = *(_DWORD *)(v4 + 840);
          v31 = v4 + 12 * v24 + 844;
          *(_DWORD *)v31 = *(_DWORD *)(v4 + 832);
          *(_DWORD *)(v31 + 4) = v29;
          *(_DWORD *)(v31 + 8) = v30;
        }
        *(_WORD *)(v4 + 764) = v12;
      }
    }
    if ( AKSC_VNorm((int)&v40, v4, v4 + 24, 833, v4 + 240) )
    {
      result = 0;
    }
    else
    {
      _android_log_print(
        3,
        "AKMD2",
        "AKSC_VNorm failed.\n  have=%6d,%6d,%6d  ho=%6d,%6d,%6d  hs=%6d,%6d,%6d\n",
        v40,
        v41,
        v42,
        *(_WORD *)v4,
        *(_WORD *)(v4 + 2),
        *(_WORD *)(v4 + 4),
        *(_WORD *)(v4 + 24),
        *(_WORD *)(v4 + 26),
        *(_WORD *)(v4 + 28));
      result = 64;
    }
  }
  return result;
}
// 1888: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00002BF4) --------------------------------------------------------
int __fastcall AKSC_InitDecomp8963(int result)
{
  int v1; // r2@1
  int v2; // r3@2

  v1 = 0;
  do
  {
    v2 = result + v1;
    v1 += 6;
    *(_WORD *)v2 = I16V_INIT_VALUE;
    v2 += 2;
    *(_WORD *)(v2 + 2) = unk_7FDC;
    *(_WORD *)v2 = unk_7FDA;
  }
  while ( v1 != 192 );
  return result;
}

//----- (00002C24) --------------------------------------------------------
int __fastcall sub_2C24(int a1, int a2)
{
  int v2; // r7@2
  int v3; // r6@2
  int v4; // r6@2
  int v5; // r5@2
  unsigned int v6; // r4@2
  int v7; // ST04_4@2
  unsigned int v8; // r2@2
  int v9; // r4@2
  int v10; // r2@2
  int v11; // r4@2
  int result; // r0@4
  unsigned int v13; // [sp+Ch] [bp-24h]@2
  unsigned int v14; // [sp+10h] [bp-20h]@2
  int v15; // [sp+14h] [bp-1Ch]@2

  if ( a1
    && (v2 = ((~*(_BYTE *)(a1 + 20) << 8) | ~*(_BYTE *)(a1 + 5) & 0xFF) & 0xFFFF,
        *(_WORD *)a2 = (~*(_BYTE *)(a1 + 20) << 8) | ~*(_BYTE *)(a1 + 5) & 0xFF,
        v3 = (~*(_BYTE *)(a1 + 17) & 0xFF | ((*(_BYTE *)(a1 + 21) + 4) << 8)) & 0xFF,
        *(_WORD *)(a2 + 2) = ~*(_BYTE *)(a1 + 17) & 0xFF | ((*(_BYTE *)(a1 + 21) + 4) << 8),
        v15 = v3,
        v4 = ((*(_BYTE *)(a1 + 19) + 102) & 0xFF | ((*(_BYTE *)(a1 + 9) - 55) << 8)) & 0xFFFF,
        *(_WORD *)(a2 + 4) = (*(_BYTE *)(a1 + 19) + 102) & 0xFF | ((*(_BYTE *)(a1 + 9) - 55) << 8),
        v5 = ((*(_BYTE *)(a1 + 12) - 38) & 0xFF | ((*(_BYTE *)(a1 + 1) - 82) << 8)) & 0xFFFF,
        *(_WORD *)(a2 + 6) = (*(_BYTE *)(a1 + 12) - 38) & 0xFF | ((*(_BYTE *)(a1 + 1) - 82) << 8),
        v6 = ((*(_BYTE *)a1 - 32) & 0xFF | ((*(_BYTE *)(a1 + 8) + 106) << 8)) << 24,
        *(_WORD *)(a2 + 8) = (*(_BYTE *)a1 - 32) & 0xFF | ((*(_BYTE *)(a1 + 8) + 106) << 8),
        v14 = v6 >> 24,
        v7 = ((~*(_BYTE *)(a1 + 6) << 8) | ~*(_BYTE *)(a1 + 22) & 0xFF) & 0xFFFF,
        *(_WORD *)(a2 + 10) = (~*(_BYTE *)(a1 + 6) << 8) | ~*(_BYTE *)(a1 + 22) & 0xFF,
        v8 = ((*(_BYTE *)(a1 + 4) - 49) & 0xFF | (~*(_BYTE *)(a1 + 14) << 8)) << 24,
        *(_WORD *)(a2 + 12) = (*(_BYTE *)(a1 + 4) - 49) & 0xFF | (~*(_BYTE *)(a1 + 14) << 8),
        v13 = v8 >> 24,
        v9 = ((*(_BYTE *)(a1 + 18) - 127) & 0xFF | (~*(_BYTE *)(a1 + 16) << 8)) & 0xFFFF,
        *(_WORD *)(a2 + 14) = (*(_BYTE *)(a1 + 18) - 127) & 0xFF | (~*(_BYTE *)(a1 + 16) << 8),
        v10 = (unsigned __int8)v9,
        v11 = (((*(_BYTE *)(a1 + 24) + 55) << 8) | (*(_BYTE *)(a1 + 11) - 85) & 0xFF) & 0xFFFF,
        *(_WORD *)(a2 + 16) = ((*(_BYTE *)(a1 + 24) + 55) << 8) | (*(_BYTE *)(a1 + 11) - 85) & 0xFF,
        ((unsigned __int8)v11 + v10 + v13 + v14 + v15 + v2 + v4 + v5 + v7) << 24 == ~*(_BYTE *)(a1 + 23) << 24)
    && ((unsigned __int8)v11 + v13 + v10) << 24 == (*(_BYTE *)(a1 + 2) + 70) << 24 )
  {
    result = (~*(_BYTE *)(a1 + 26) & 0xFF) - ((v10 + v14 + v15) & 0xFF) <= 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00002D80) --------------------------------------------------------
signed int __fastcall sub_2D80(int a1, int *a2)
{
  char *v2; // r3@1
  int *v3; // r4@1
  int v4; // r2@2
  unsigned int v5; // r0@2
  signed int v6; // r5@3
  int v7; // r5@4
  bool v8; // cf@8
  signed int result; // r0@10
  int v10; // r5@12
  int v11; // r3@12
  int *v12; // r12@12
  int v13; // r2@13
  signed int v14; // r0@13
  int v15; // r4@13
  int *v16; // r6@13
  int v17; // r1@14
  int v18; // r7@14
  int v19; // r3@14
  int v20; // r7@14
  int v21; // r1@14
  signed int v22; // r4@15
  int v23; // [sp+4h] [bp-54h]@13
  int v24; // [sp+1Ch] [bp-3Ch]@1
  char v25[12]; // [sp+20h] [bp-38h]@13
  char v26[4]; // [sp+2Ch] [bp-2Ch]@13
  int v27; // [sp+30h] [bp-28h]@16
  int v28; // [sp+34h] [bp-24h]@16
  char v29; // [sp+38h] [bp-20h]@1
  __int16 v30; // [sp+3Eh] [bp-1Ah]@11

  v24 = a1;
  v2 = &v29;
  v3 = a2;
  do
  {
    *(_WORD *)v2 = 0;
    v4 = *v3;
    v5 = 3;
    do
    {
      v6 = 0x4000 << v5;
      if ( v4 > -(0x4000 << v5) )
      {
        if ( v4 < v6 )
          goto LABEL_8;
        v4 -= v6;
        v7 = *(_WORD *)v2 + (1 << v5);
      }
      else
      {
        v4 += v6;
        v7 = *(_WORD *)v2 - (1 << v5);
      }
      *(_WORD *)v2 = v7;
LABEL_8:
      v8 = v5-- >= 1;
    }
    while ( v8 );
    *v3 = v4;
    if ( (unsigned __int16)(*(_WORD *)v2 + 7) > 0xEu )
      return 0;
    v2 += 2;
    ++v3;
  }
  while ( (__int16 *)v2 != &v30 );
  v10 = v24;
  v11 = 0;
  v12 = a2;
  do
  {
    v13 = 0;
    *(_DWORD *)&v26[v11] = 0;
    *(_DWORD *)&v25[v11] = 0;
    v14 = 0;
    v15 = 0;
    v16 = v12;
    v23 = v11;
    do
    {
      v17 = *(_WORD *)(v10 + v13);
      v18 = *v16;
      ++v16;
      v19 = v18 * v17;
      v20 = v17 << 10;
      v14 += v19;
      v21 = *(_WORD *)(&v29 + v13);
      v13 += 2;
      v15 += v21 * v20;
    }
    while ( v13 != 6 );
    *(_DWORD *)&v25[v23] = v15;
    v22 = (v14 >> 4) + v15 + ((v14 >> 3) & 1);
    *(_DWORD *)&v26[v23] = ((v22 >> 9) & 1) + (v22 >> 10);
    v11 = v23 + 4;
    v10 += 6;
  }
  while ( v23 != 8 );
  *v12 = *(_DWORD *)v26;
  result = 1;
  v12[1] = v27;
  v12[2] = v28;
  return result;
}
// 2D80: using guessed type char var_2C[4];
// 2D80: using guessed type char var_38[12];

//----- (00002E5C) --------------------------------------------------------
signed int __fastcall sub_2E5C(signed int a1, int a2, int a3)
{
  int v3; // r12@1
  int v4; // r3@2
  signed int v5; // r3@4
  int v6; // r2@12
  signed int v7; // r3@12
  signed int v8; // r4@12
  signed int v9; // r5@12
  int v10; // r6@12
  signed int v11; // r7@19
  signed int v12; // r6@27
  signed int result; // r0@28
  signed int v14; // [sp+8h] [bp-38h]@11
  int v15; // [sp+Ch] [bp-34h]@17
  int v16; // [sp+10h] [bp-30h]@0
  int v17; // [sp+14h] [bp-2Ch]@0
  int v18; // [sp+18h] [bp-28h]@18
  signed int v19; // [sp+1Ch] [bp-24h]@0
  __int16 v20; // [sp+20h] [bp-20h]@10
  __int16 v21; // [sp+24h] [bp-1Ch]@9

  v3 = a3;
  if ( (unsigned __int16)a1 > 0x20u )
    goto LABEL_32;
  v4 = 0;
  do
  {
    if ( a1 == 1 << v4 )
    {
      v5 = 1;
      goto LABEL_7;
    }
    ++v4;
  }
  while ( v4 != 6 );
  v5 = 0;
LABEL_7:
  if ( !v5 && a1 )
    goto LABEL_32;
  v21 = *(_WORD *)a2;
  if ( *(_WORD *)a2 == 0x7FFF
    || (v20 = *(_WORD *)(a2 + 2), *(_WORD *)(a2 + 2) == 0x7FFF)
    || (v14 = *(_WORD *)(a2 + 4), v14 == 0x7FFF) )
  {
LABEL_32:
    result = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 1;
    while ( (signed __int16)v6 < a1 )
    {
      if ( (signed __int16)v6 == (signed __int16)v10 )
        v10 = 2 * v6 & 0xFFFF;
      if ( (_WORD)v6 )
      {
        v15 = *(_WORD *)a2;
        if ( v15 != 0x7FFF && (v18 = *(_WORD *)(a2 + 2), v18 != 0x7FFF) && (v11 = *(_WORD *)(a2 + 4), v11 != 0x7FFF) )
        {
          v19 = *(_WORD *)(a2 + 4);
          v17 = *(_WORD *)a2;
          v9 += v15;
          v16 = *(_WORD *)(a2 + 2);
          v8 += v18;
        }
        else
        {
          v9 += v17;
          v8 += v16;
          v11 = v19;
        }
        v7 += v11;
      }
      else
      {
        v16 = v20;
        v17 = v21;
        v19 = v14;
        v7 = v14;
        v9 = v21;
        v8 = v20;
      }
      ++v6;
      a2 += 6;
    }
    while ( 1 )
    {
      v12 = v10 << 16;
      if ( v12 >> 16 <= 1 )
        break;
      v9 >>= 1;
      v8 >>= 1;
      v7 >>= 1;
      v10 = (v12 >> 17) & 0xFFFF;
    }
    *(_WORD *)v3 = v9;
    *(_WORD *)(v3 + 2) = v8;
    *(_WORD *)(v3 + 4) = v7;
    result = 1;
  }
  return result;
}

//----- (00002F74) --------------------------------------------------------
int __fastcall AKSC_Decomp8963S3(int a1, signed int a2, int a3, int a4, int a5, int a6, _WORD *a7, int a8, signed __int16 *a9, signed __int16 *a10, _WORD *a11, _WORD *a12, _WORD *a13)
{
  signed int v13; // r6@1
  int v14; // r2@2
  signed __int16 *v15; // r3@4
  signed int v16; // r2@4
  signed __int16 v17; // r2@9
  signed __int16 v18; // r2@11
  signed int v19; // r2@13
  int v20; // r3@17
  int v21; // r2@17
  signed int v22; // r1@18
  int v23; // r1@19
  __int16 v24; // r0@22
  int v25; // r3@23
  int result; // r0@24
  int v27; // r2@26
  int v28; // r7@26
  signed int v29; // r2@26
  __int16 v30; // r3@30
  int v31; // [sp+4h] [bp-5Ch]@1
  int v32; // [sp+8h] [bp-58h]@1
  char v33; // [sp+14h] [bp-4Ch]@22
  int v34; // [sp+28h] [bp-38h]@21
  __int16 v35; // [sp+2Ch] [bp-34h]@31
  __int16 v36; // [sp+30h] [bp-30h]@31
  int v37; // [sp+34h] [bp-2Ch]@18
  int v38; // [sp+38h] [bp-28h]@30
  int v39; // [sp+3Ch] [bp-24h]@30
  __int16 v40[16]; // [sp+40h] [bp-20h]@17
  __int16 v41; // [sp+42h] [bp-1Eh]@17
  __int16 v42; // [sp+44h] [bp-1Ch]@17

  v13 = a2;
  v31 = a3;
  v32 = a4;
  if ( (unsigned __int16)a2 > 0x20u )
    goto LABEL_38;
  v14 = 0;
  do
  {
    if ( a2 == 1 << v14 )
    {
      v15 = a10;
      v16 = 1;
      goto LABEL_7;
    }
    ++v14;
  }
  while ( v14 != 6 );
  v15 = a10;
  v16 = 0;
LABEL_7:
  if ( v16 )
    goto LABEL_39;
  if ( a2 )
  {
LABEL_38:
    LOWORD(result) = 0;
  }
  else
  {
LABEL_39:
    *a7 = 1;
    *a12 = 0;
    *a13 = 0;
    *a9 = 0;
    *v15 = 0;
    *a11 = 0;
    v17 = 1;
    if ( !(*(_WORD *)a1 & 2) )
      v17 = *a9;
    *a9 = v17;
    v18 = 1;
    if ( !(*(_WORD *)(a1 + 14) & 4) )
      v18 = *v15;
    *v15 = v18;
    v19 = 1;
    if ( !(*(_WORD *)(a1 + 14) & 8) )
      v19 = *a11;
    *a11 = v19;
    if ( *v15 == 1 || v19 == 1 )
    {
      LOWORD(result) = 1;
    }
    else
    {
      v40[0] = (*(_WORD *)(a1 + 4) << 8) + *(_WORD *)(a1 + 2);
      v41 = (*(_WORD *)(a1 + 8) << 8) + *(_WORD *)(a1 + 6);
      v42 = (*(_WORD *)(a1 + 12) << 8) + *(_WORD *)(a1 + 10);
      v20 = 0;
      v21 = 0;
      do
      {
        v22 = (signed __int16)(*(_WORD *)(v31 + v21 * 2) + 128) * 10 * v40[v21];
        *(int *)((char *)&v37 + v20 * 4) = v22;
        if ( *(_WORD *)(a1 + 14) & 0x10 )
          v23 = v22 >> 10;
        else
          v23 = v22 >> 8;
        *(int *)((char *)&v34 + v20 * 4) = v23;
        ++v20;
        ++v21;
      }
      while ( v20 != 3 );
      v24 = sub_2C24(v32, (int)&v33);
      *a13 = v24;
      if ( v24 != 1 || (result = (unsigned __int16)sub_2D80((int)&v33, &v34)) != 0 )
      {
        v25 = 0;
        do
        {
          v27 = *(int *)((char *)&v34 + v25);
          *(int *)((char *)&v37 + v25) = v27;
          v28 = v27 - *(_DWORD *)(a6 + v25);
          *(int *)((char *)&v34 + v25) = v28;
          v29 = 1;
          if ( (unsigned int)(v28 + 29999) <= 0xEA5E )
            v29 = *a12;
          v25 += 4;
          *a12 = v29;
        }
        while ( v25 != 12 );
        if ( v29 == 1 )
        {
          AKSC_InitDecomp8963(a5);
          *(_DWORD *)a6 = v37;
          *(_DWORD *)(a6 + 4) = v38;
          v30 = 0;
          *(_DWORD *)(a6 + 8) = v39;
          v40[0] = 0;
          v41 = 0;
        }
        else
        {
          v30 = v36;
          v40[0] = v34;
          v41 = v35;
        }
        v42 = v30;
        AKSC_buffer((int)v40, 32, *a7, a5);
        LOWORD(result) = sub_2E5C(v13, a5, a8);
      }
    }
  }
  return (signed __int16)result;
}
// 2F74: using guessed type __int16 var_20[16];

//----- (0000312C) --------------------------------------------------------
signed int __fastcall AKSC_Decomp8963(int a1, signed int a2, int a3, int a4, int a5, _WORD *a6, int a7, signed __int16 *a8, signed __int16 *a9, _WORD *a10, _WORD *a11)
{
  int v11; // r2@2
  signed __int16 v12; // r2@6
  signed __int16 v13; // r2@8
  signed int v14; // r2@10
  __int16 v15; // r0@14
  int v16; // r3@14
  int v17; // r1@14
  signed int v18; // r0@15
  int v19; // r0@16
  int v20; // r0@18
  unsigned int v21; // r12@18
  signed int v22; // r0@18
  __int16 v23; // r3@22
  int v24; // r5@24
  int v25; // r4@24
  signed int v26; // r2@24
  signed int v27; // r1@24
  signed int v28; // r0@24
  int v29; // r3@24
  int v30; // r7@30
  signed int v31; // r3@35
  signed int result; // r0@37
  int v33; // [sp+10h] [bp-50h]@1
  signed int v34; // [sp+14h] [bp-4Ch]@1
  _WORD *v35; // [sp+18h] [bp-48h]@8
  int v36; // [sp+18h] [bp-48h]@26
  int v37; // [sp+1Ch] [bp-44h]@1
  int v38; // [sp+20h] [bp-40h]@14
  int v39; // [sp+24h] [bp-3Ch]@14
  int v40; // [sp+28h] [bp-38h]@14
  int v41; // [sp+2Ch] [bp-34h]@14
  int v42; // [sp+30h] [bp-30h]@14
  int v43; // [sp+34h] [bp-2Ch]@14
  __int16 v44[4]; // [sp+38h] [bp-28h]@14
  __int16 v45; // [sp+3Ah] [bp-26h]@14
  __int16 v46; // [sp+3Ch] [bp-24h]@14
  __int16 v47; // [sp+40h] [bp-20h]@22
  __int16 v48; // [sp+42h] [bp-1Eh]@22
  __int16 v49; // [sp+44h] [bp-1Ch]@24

  v34 = a2;
  v37 = a3;
  v33 = a4;
  if ( a2 > 32 )
  {
LABEL_37:
    result = 0;
  }
  else
  {
    v11 = 0;
    while ( a2 != 1 << v11 )
    {
      if ( ++v11 == 6 )
        goto LABEL_37;
    }
    *a6 = 1;
    *a8 = 0;
    *a9 = 0;
    *a10 = 0;
    *a11 = 0;
    v12 = 1;
    if ( !(*(_WORD *)a1 & 2) )
      v12 = *a8;
    *a8 = v12;
    v35 = (_WORD *)(a1 + 14);
    v13 = 1;
    if ( !(*(_WORD *)(a1 + 14) & 4) )
      v13 = *a9;
    *a9 = v13;
    v14 = 1;
    if ( !(*(_WORD *)(a1 + 14) & 8) )
      v14 = *a10;
    *a10 = v14;
    if ( *a9 != 1 && v14 != 1 )
    {
      v44[0] = (*(_WORD *)(a1 + 4) << 8) + *(_WORD *)(a1 + 2);
      v45 = (*(_WORD *)(a1 + 8) << 8) + *(_WORD *)(a1 + 6);
      v15 = (*(_WORD *)(a1 + 12) << 8) + *(_WORD *)(a1 + 10);
      v16 = 0;
      v40 = 0;
      v39 = 0;
      v46 = v15;
      v43 = 0;
      v42 = 0;
      v41 = 0;
      v38 = 0;
      v17 = 0;
      do
      {
        v18 = (signed __int16)(*(_WORD *)(v37 + v17 * 2) + 128) * 10 * v44[v17];
        *(int *)((char *)&v41 + v16) = v18;
        if ( *v35 & 0x10 )
          v19 = v18 >> 10;
        else
          v19 = v18 >> 8;
        *(int *)((char *)&v41 + v16) = v19;
        v20 = *(int *)((char *)&v41 + v16) - *(_DWORD *)(a5 + v16);
        *(int *)((char *)&v38 + v16) = v20;
        v21 = v20 + 29999;
        v22 = 1;
        if ( v21 <= 0xEA5E )
          v22 = *a11;
        v16 += 4;
        *a11 = v22;
        ++v17;
      }
      while ( v16 != 12 );
      if ( v22 == 1 )
      {
        AKSC_InitDecomp8963(v33);
        *(_DWORD *)a5 = v41;
        v23 = 0;
        *(_DWORD *)(a5 + 4) = v42;
        *(_DWORD *)(a5 + 8) = v43;
        v47 = 0;
        v48 = 0;
      }
      else
      {
        v23 = v40;
        v47 = v38;
        v48 = v39;
      }
      v49 = v23;
      AKSC_buffer((int)&v47, 32, *a6, v33);
      v24 = 0;
      v25 = v33;
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 1;
      while ( (signed __int16)v24 < v34 )
      {
        if ( (signed __int16)v24 == (signed __int16)v29 )
        {
          v29 = 2 * v24 & 0xFFFF;
          v36 = v33 + 6 * ((signed __int16)(2 * v24) - 1);
          if ( *(_WORD *)v36 == 0x7FFF && *(_WORD *)(v36 + 2) == 0x7FFF && *(_WORD *)(v36 + 4) == 0x7FFF )
          {
            v29 = v24 << 17 >> 17;
            goto LABEL_34;
          }
        }
        ++v24;
        v28 += *(_WORD *)v25;
        v27 += *(_WORD *)(v25 + 2);
        v30 = *(_WORD *)(v25 + 4);
        v25 += 6;
        v26 += v30;
      }
      while ( 1 )
      {
        v31 = v29 << 16;
        if ( v31 >> 16 <= 1 )
          break;
        v28 >>= 1;
        v27 >>= 1;
        v26 >>= 1;
        v29 = v31 >> 17;
LABEL_34:
        v29 = (unsigned __int16)v29;
      }
      *(_WORD *)a7 = v28;
      *(_WORD *)(a7 + 2) = v27;
      *(_WORD *)(a7 + 4) = v26;
    }
    result = 1;
  }
  return result;
}
// 312C: using guessed type __int16 var_28[4];

//----- (00003334) --------------------------------------------------------
int __fastcall AKSC_div16(int a1, int a2)
{
  int v2; // r3@1
  int v3; // r2@1
  signed int v4; // r4@4

  v2 = 0;
  v3 = 0;
  do
  {
    a1 *= 2;
    v2 = 2 * v2 & 0xFFFF;
    if ( a1 >= a2 )
    {
      a1 -= a2;
      v2 = (v2 + 1) & 0xFFFF;
    }
    v4 = (v3 + 1) << 16;
    v3 = (v3 + 1) & 0xFFFF;
  }
  while ( v4 >> 16 != 15 );
  return (signed __int16)v2;
}

//----- (00003360) --------------------------------------------------------
int __fastcall AKSC_div32(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // r3@1
  int v3; // r2@1
  int result; // r0@1
  signed int v5; // r4@4

  v2 = a1;
  v3 = 0;
  result = 0;
  do
  {
    v2 *= 2;
    result *= 2;
    if ( v2 >= a2 )
    {
      v2 -= a2;
      ++result;
    }
    v5 = (v3 + 1) << 16;
    v3 = (v3 + 1) & 0xFFFF;
  }
  while ( v5 >> 16 != 31 );
  return result;
}

//----- (00003384) --------------------------------------------------------
int __fastcall AKSC_norm16(int a1)
{
  int i; // r3@2

  if ( a1 <= 0 )
  {
    LOWORD(i) = 15;
    if ( a1 )
    {
      for ( i = 0; ; i = (i + 1) & 0xFFFF )
      {
        a1 = (signed __int16)a1;
        if ( (signed __int16)a1 < -16384 )
          break;
        a1 = 2 * a1 & 0xFFFF;
      }
    }
  }
  else
  {
    for ( i = 0; ; i = (i + 1) & 0xFFFF )
    {
      a1 = (signed __int16)a1;
      if ( (signed __int16)a1 > 0x3FFF )
        break;
      a1 = 2 * a1 & 0xFFFF;
    }
  }
  return (signed __int16)i;
}

//----- (000033D8) --------------------------------------------------------
int __fastcall AKSC_norm32(signed int a1)
{
  int v1; // r3@2

  if ( a1 <= 0 )
  {
    LOWORD(v1) = 31;
    if ( a1 )
    {
      v1 = 0;
      while ( a1 >= -1073741824 )
      {
        a1 *= 2;
        v1 = (v1 + 1) & 0xFFFF;
      }
    }
  }
  else
  {
    v1 = 0;
    while ( a1 <= 0x3FFFFFFF )
    {
      a1 *= 2;
      v1 = (v1 + 1) & 0xFFFF;
    }
  }
  return (signed __int16)v1;
}

//----- (00003414) --------------------------------------------------------
int __fastcall AKSC_abs16(signed int a1)
{
  int result; // r0@2

  if ( a1 == -32768 )
    LOWORD(result) = 0x7FFF;
  else
    result = ((a1 + (a1 >> 31)) ^ (a1 >> 31)) & 0xFFFF;
  return (signed __int16)result;
}

//----- (00003438) --------------------------------------------------------
int __fastcall AKSC_div16f(int a1, int a2, _WORD *a3)
{
  int v3; // r6@1
  _WORD *v4; // r4@1
  int v5; // r5@1
  unsigned __int16 v6; // r0@1
  int v7; // r3@1
  int v8; // r5@1
  int v9; // r6@1

  v3 = a2;
  v4 = a3;
  v5 = a1;
  *a3 = AKSC_norm16(a1);
  v6 = AKSC_norm16(v3);
  v7 = *v4;
  v8 = (v5 << v7) & 0xFFFF;
  v9 = v3 << v6 << 16;
  if ( v9 >= v8 << 16 )
  {
    LOWORD(v7) = v7 - v6;
  }
  else
  {
    v8 = (v8 << 16 >> 17) & 0xFFFF;
    v7 += ~v6;
  }
  *v4 = v7;
  return (signed __int16)AKSC_div16((signed __int16)v8, SHIWORD(v9));
}

//----- (0000348C) --------------------------------------------------------
int __fastcall sub_348C(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r4@1
  signed int v5; // r1@1
  signed int v6; // r2@1
  int v7; // r0@1
  unsigned int v8; // r3@2
  int v9; // r1@2
  signed int v10; // r3@2
  int v11; // r1@3
  int v12; // r7@8
  unsigned int v13; // r3@8
  int v14; // r0@10
  int v15; // r1@13
  int v16; // r7@16
  unsigned int v17; // r3@16
  int v18; // r0@18
  int v19; // r1@21
  int v20; // r1@27
  int v21; // r1@33
  int v22; // r1@39
  int v23; // r2@45
  int v24; // r3@46
  int v25; // r2@47
  int v26; // r3@48
  int v27; // r5@49
  int v28; // r2@49
  int v29; // r3@50
  int v30; // r7@51
  int v31; // r2@51
  int result; // r0@52
  int v33; // [sp+4h] [bp-54h]@1
  char v34[12]; // [sp+Ch] [bp-4Ch]@1
  char dest[12]; // [sp+18h] [bp-40h]@1
  int v36; // [sp+24h] [bp-34h]@1
  int v37; // [sp+28h] [bp-30h]@1
  __int16 v38; // [sp+2Ch] [bp-2Ch]@1
  int v39; // [sp+30h] [bp-28h]@1
  int v40; // [sp+34h] [bp-24h]@1
  __int16 v41; // [sp+38h] [bp-20h]@1
  int v42; // [sp+3Ch] [bp-1Ch]@1

  v33 = a3;
  v3 = a2;
  v4 = a1;
  v42 = _stack_chk_guard;
  memcpy(dest, &unk_7D10, 0xBu);
  v39 = 1206631600;
  v41 = 92;
  v40 = 1553417105;
  memcpy(v34, "ASAHIKASEI", 0xBu);
  v36 = 1598375756;
  v37 = 1197421366;
  v38 = 66;
  v5 = 1;
  v6 = 0;
  v7 = 2;
  while ( 1 )
  {
    v8 = (v5 + v6) << 16;
    v6 = v5;
    v9 = (signed __int16)(v7 + 1);
    v10 = v8 >> 16;
    v7 = (v7 + 1) & 0xFFFF;
    if ( v9 == 10 )
      break;
    v5 = v10;
  }
  v11 = 0;
  while ( dest[v11] )
  {
    v12 = (v10 + v6) & 0xFFFF;
    dest[v11] = dest[v11] + 2 - (v10 + v6);
    ++v11;
    v6 = v10;
    v13 = v12 << 16;
    if ( v11 == 16 )
      goto LABEL_11;
    v10 = (unsigned __int16)v12;
  }
  v11 = (unsigned __int16)v11;
  while ( (signed __int16)v11 <= 15 )
  {
    v14 = v10 + v6;
    v6 = v10;
    v11 = (v11 + 1) & 0xFFFF;
    v13 = v14 << 16;
LABEL_11:
    v10 = v13 >> 16;
  }
  v15 = 0;
  while ( *((_BYTE *)&v39 + v15) )
  {
    v16 = (v10 + v6) & 0xFFFF;
    *((_BYTE *)&v39 + v15) = *((_BYTE *)&v39 + v15) - 51 - (v10 + v6);
    ++v15;
    v6 = v10;
    v17 = v16 << 16;
    if ( v15 == 16 )
      goto LABEL_19;
    v10 = (unsigned __int16)v16;
  }
  v15 = (unsigned __int16)v15;
  while ( (signed __int16)v15 <= 15 )
  {
    v18 = v10 + v6;
    v6 = v10;
    v15 = (v15 + 1) & 0xFFFF;
    v17 = v18 << 16;
LABEL_19:
    v10 = v17 >> 16;
  }
  v19 = 0;
  do
  {
    if ( !dest[v19] && !*(_BYTE *)(v4 + v19) )
      goto LABEL_27;
    if ( *(_BYTE *)(v4 + v19) != (unsigned __int8)dest[v19] )
      goto LABEL_53;
    ++v19;
  }
  while ( v19 != 16 );
  if ( *(_BYTE *)(v4 + 16) )
  {
LABEL_53:
    LOWORD(result) = -32768;
    goto LABEL_54;
  }
LABEL_27:
  v20 = 0;
  while ( *((_BYTE *)&v39 + v20) || *(_BYTE *)(v3 + v20) )
  {
    if ( *(_BYTE *)(v3 + v20) != *((_BYTE *)&v39 + v20) )
      goto LABEL_53;
    if ( ++v20 == 16 )
    {
      if ( *(_BYTE *)(v3 + 16) )
        goto LABEL_53;
      break;
    }
  }
  v21 = 0;
  while ( v34[v21] || *(_BYTE *)(v4 + v21) )
  {
    if ( *(_BYTE *)(v4 + v21) != (unsigned __int8)v34[v21] )
      goto LABEL_53;
    if ( ++v21 == 16 )
    {
      if ( *(_BYTE *)(v4 + 16) )
        goto LABEL_53;
      break;
    }
  }
  v22 = 0;
  while ( *((_BYTE *)&v36 + v22) || *(_BYTE *)(v3 + v22) )
  {
    if ( *(_BYTE *)(v3 + v22) != *((_BYTE *)&v36 + v22) )
      goto LABEL_53;
    if ( ++v22 == 16 )
    {
      if ( *(_BYTE *)(v3 + 16) )
        goto LABEL_53;
      break;
    }
  }
  v23 = (v10 + v6) & 0xFFFF;
  if ( *(_WORD *)v33 != (signed __int16)(12091 - v23) )
    goto LABEL_53;
  v24 = (v23 + v10) & 0xFFFF;
  if ( *(_WORD *)(v33 + 2) != (signed __int16)(-26131 - v24) )
    goto LABEL_53;
  v25 = (v24 + v23) & 0xFFFF;
  if ( (-23074 - v25) << 16 > *(_WORD *)(v33 + 4) << 16 )
    goto LABEL_53;
  v26 = (v25 + v24) & 0xFFFF;
  if ( (signed __int16)(16512 - v26) < (signed int)*(_WORD *)(v33 + 4) )
    goto LABEL_53;
  v27 = *(_WORD *)(v33 + 6);
  v28 = (v26 + v25) & 0xFFFF;
  if ( (-6816 - v28) << 16 > v27 << 16 )
    goto LABEL_53;
  v29 = (v28 + v26) & 0xFFFF;
  if ( (signed __int16)(9695 - v29) < (signed __int16)v27 )
    goto LABEL_53;
  v30 = *(_WORD *)(v33 + 8);
  v31 = (v29 + v28) & 0xFFFF;
  if ( (2625 - v31) << 16 > v30 << 16 )
    goto LABEL_53;
  LOWORD(result) = 1;
  if ( (signed __int16)(12319 - v29 - v31) < (signed __int16)v30 )
    goto LABEL_53;
LABEL_54:
  result = (signed __int16)result;
  if ( v42 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 18C4: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 348C: using guessed type char dest[12];
// 348C: using guessed type char var_4C[12];

//----- (00003730) --------------------------------------------------------
int __fastcall AKSC_SetLayout(int result, int a2)
{
  int v2; // r5@1
  int v3; // r4@1
  int v4; // r2@1
  int v5; // r3@1
  int v6; // r6@2

  v2 = *(_WORD *)result;
  v3 = *(_WORD *)(result + 2);
  v4 = *(_WORD *)(result + 4);
  v5 = 0;
  do
  {
    v6 = *(_WORD *)(a2 + 2) * v3 + *(_WORD *)a2 * v2 + *(_WORD *)(a2 + 4) * v4;
    if ( v6 > 0x7FFF )
      v6 = 0x7FFF;
    if ( v6 < -32768 )
      LOWORD(v6) = -32768;
    *(_WORD *)(result + v5) = v6;
    v5 += 2;
    a2 += 6;
  }
  while ( v5 != 6 );
  return result;
}

//----- (000037A4) --------------------------------------------------------
int __fastcall AKSC_ThetaFilter(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r4@1
  __int16 v5; // r7@1
  __int16 v6; // r0@1
  int v7; // r6@1
  int v8; // r0@1
  unsigned int v9; // r7@1
  __int16 v10; // r0@1
  __int16 v11; // r5@1
  int v12; // r3@1
  unsigned int v13; // r3@3

  v3 = a2;
  v4 = a3;
  v5 = AKSC_angRng(a1, 1);
  v6 = AKSC_angRng(v3, 1);
  v7 = v6;
  v8 = AKSC_angRng(v5 - v6, 1) << 16;
  v9 = (unsigned int)v8 >> 16;
  v10 = AKSC_abs16(v8 >> 16);
  v11 = v10;
  LOWORD(v12) = 0;
  if ( v4 > 0 )
    v12 = (-(v4 * (signed __int16)AKSC_cos(v10) >> 27) >> 9) & 0xFFFF;
  v13 = (unsigned int)(v11 * (signed __int16)(0x7FFF * (v12 + 1) - ((_WORD)v12 << 12)) + 0x8000) >> 16;
  if ( v9 & 0x8000 )
    v13 = 0xFFFF * v13 & 0xFFFF;
  return (signed __int16)AKSC_angRng((signed __int16)v13 + v7, 0);
}

//----- (00003838) --------------------------------------------------------
signed int __fastcall sub_3838(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r3@1
  int v4; // r6@1
  int v5; // r2@1
  int v6; // r1@1
  int *v7; // r5@1
  int v8; // r7@1
  signed int v9; // r0@2
  signed int v10; // r0@5
  int v11; // r0@8
  int v12; // r3@9
  signed int v13; // r2@9
  int v14; // r0@15
  int v15; // r6@15
  int v16; // r12@15
  int v17; // r5@15
  int v18; // r4@15
  int v19; // r0@17
  int v20; // r1@17
  int *v21; // r3@17
  int v22; // r2@17
  int v23; // r1@19
  int *v24; // r3@19
  int v25; // r2@22
  _WORD *v27; // [sp+4h] [bp-34h]@1
  int v28; // [sp+4h] [bp-34h]@15
  int v29; // [sp+10h] [bp-28h]@1
  int v30; // [sp+14h] [bp-24h]@1
  int v31; // [sp+18h] [bp-20h]@1
  int v32; // [sp+1Ch] [bp-1Ch]@1
  int v33; // [sp+20h] [bp-18h]@8

  v2 = a1;
  v3 = *(_WORD *)a1;
  v4 = a2;
  v5 = *(_WORD *)(a1 + 8);
  v6 = *(_WORD *)(a1 + 16);
  v29 = v3 + v5 + 0x4000 + v6;
  v7 = &v29;
  v30 = v3 - v5 - v6 + 0x4000;
  v31 = v5 - v3 - v6 + 0x4000;
  v32 = v6 + 0x4000 - v5 - v3;
  v8 = v4;
  v27 = (_WORD *)v4;
  do
  {
    v9 = *v7;
    if ( *v7 > 0 )
    {
      if ( v9 <= 0xFFFF )
        v10 = (signed __int16)AKSC_sqrt32(v9 << 12);
      else
        v10 = 0x4000;
      *v7 = v10;
    }
    else
    {
      *v7 = 0;
    }
    v11 = *v7;
    ++v7;
    *v27 = v11;
    ++v27;
  }
  while ( v7 != &v33 );
  v12 = (((*(_WORD *)v4 << 16 >> 31) - *(_WORD *)v4) >> 31) & *(_WORD *)v4;
  v13 = 0;
  if ( v12 < *(_WORD *)(v4 + 2) )
  {
    v12 = *(_WORD *)(v4 + 2);
    v13 = 1;
  }
  if ( v12 < *(_WORD *)(v4 + 4) )
  {
    v12 = *(_WORD *)(v4 + 4);
    v13 = 2;
  }
  if ( v12 < *(_WORD *)(v4 + 6) )
  {
    v21 = &v29;
    v29 = *(_WORD *)(v2 + 2) - *(_WORD *)(v2 + 6);
    v30 = *(_WORD *)(v2 + 4) + *(_WORD *)(v2 + 12);
    v31 = *(_WORD *)(v2 + 14) + *(_WORD *)(v2 + 10);
    v22 = 1;
  }
  else
  {
    if ( v13 != 1 )
    {
      v28 = *(_WORD *)(v2 + 10);
      v14 = *(_WORD *)(v2 + 14);
      v15 = *(_WORD *)(v2 + 4);
      v16 = *(_WORD *)(v2 + 12);
      v17 = *(_WORD *)(v2 + 2);
      v18 = *(_WORD *)(v2 + 6);
      if ( v13 == 2 )
      {
        v29 = v16 - v15;
        v30 = v18 + v17;
        v31 = 1;
        v32 = v14 + v28;
      }
      else
      {
        v29 = 1;
        v30 = v28 - v14;
        v31 = v16 - v15;
        v32 = v17 - v18;
      }
      goto LABEL_19;
    }
    v19 = *(_WORD *)(v2 + 10);
    v20 = *(_WORD *)(v2 + 14);
    v21 = &v29;
    v30 = 1;
    v29 = v19 - v20;
    v31 = *(_WORD *)(v2 + 6) + *(_WORD *)(v2 + 2);
    v22 = *(_WORD *)(v2 + 4) + *(_WORD *)(v2 + 12);
  }
  v21[3] = v22;
LABEL_19:
  v23 = v29;
  v24 = &v30;
  do
  {
    v25 = *v24;
    if ( v23 >= 0 )
    {
      if ( v25 >= 0 )
        goto LABEL_27;
LABEL_26:
      *(_WORD *)(v8 + 2) = -*(_WORD *)(v8 + 2);
      goto LABEL_27;
    }
    if ( v25 > 0 )
      goto LABEL_26;
LABEL_27:
    ++v24;
    v8 += 2;
  }
  while ( v24 != &v33 );
  return 1;
}

//----- (000039B8) --------------------------------------------------------
signed int __fastcall sub_39B8(int a1, _WORD *a2)
{
  int v2; // r4@1
  int v3; // r2@1
  int v4; // r6@2
  int v5; // r6@3
  int v6; // r0@4
  int v7; // r7@4
  int v8; // r3@4
  signed int v9; // r0@5
  int v10; // r2@5
  signed int v11; // r0@5
  signed int result; // r0@10
  char v13; // [sp+16h] [bp-1Ah]@4

  v2 = a1;
  v3 = *(_WORD *)a1 * *(_WORD *)a1;
  if ( v3 == 0x40000000
    || (v4 = *(_WORD *)(a1 + 2) * *(_WORD *)(a1 + 2) + v3, v4 > 0x3FFFFFFF)
    || (v5 = v4 + *(_WORD *)(a1 + 4) * *(_WORD *)(a1 + 4), v5 > 0x3FFFFFFF) )
  {
    result = 0;
  }
  else
  {
    *a2 = AKSC_sqrt32(v5);
    v6 = AKSC_invSqrt(v5, &v13);
    v7 = (signed __int16)(v6 >> (16 - v13));
    *(_WORD *)&v13 += 3;
    v8 = 0;
    do
    {
      v9 = 1 << (v13 - 1);
      v10 = (v9 + *(_WORD *)(v2 + v8) * v7) >> v13 << 16;
      v11 = (signed __int16)((v9 + *(_WORD *)(v2 + v8) * v7) >> v13);
      *(_WORD *)(v2 + v8) = HIWORD(v10);
      if ( SHIWORD(v10) >= -2048 )
      {
        if ( v11 > 2048 )
          *(_WORD *)(v2 + v8) = 2048;
      }
      else
      {
        *(_WORD *)(v2 + v8) = -2048;
      }
      v8 += 2;
    }
    while ( v8 != 6 );
    result = 1;
  }
  return result;
}

//----- (00003A74) --------------------------------------------------------
signed int __fastcall sub_3A74(int a1, int a2, int a3)
{
  int v3; // r4@1
  signed int v4; // r6@1
  int v5; // r2@1
  signed int v6; // r7@1
  int v7; // r6@1
  signed int v8; // r0@1
  int v9; // r3@1
  signed int v10; // r0@1
  signed int v11; // r0@1
  int v12; // r0@1
  int v13; // r6@1
  int v14; // r3@1
  int v15; // r3@3
  signed int v16; // r2@3
  signed int v17; // r2@5
  signed int v18; // r2@7
  signed int v19; // r2@9
  signed int v20; // r2@11
  int v21; // r6@13
  signed int v22; // r2@13
  signed int result; // r0@15
  char v24; // [sp+Eh] [bp-1Ah]@1

  v3 = a3;
  v4 = *(_WORD *)(a1 + 2) * *(_WORD *)(a2 + 4) - *(_WORD *)(a1 + 4) * *(_WORD *)(a2 + 2);
  *(_WORD *)(a3 + 6) = ((v4 >> 7) & 1) + (v4 >> 8);
  v5 = (signed __int16)(((v4 >> 7) & 1) + (v4 >> 8));
  v6 = *(_WORD *)(a1 + 4) * *(_WORD *)a2 - *(_WORD *)a1 * *(_WORD *)(a2 + 4);
  v7 = (((v6 >> 7) & 1) + (v6 >> 8)) & 0xFFFF;
  *(_WORD *)(v3 + 8) = ((v6 >> 7) & 1) + (v6 >> 8);
  v8 = *(_WORD *)a1 * *(_WORD *)(a2 + 2) - *(_WORD *)a2 * *(_WORD *)(a1 + 2);
  *(_WORD *)(v3 + 10) = ((v8 >> 7) & 1) + (v8 >> 8);
  v9 = (signed __int16)(((v8 >> 7) & 1) + (v8 >> 8));
  v10 = *(_WORD *)(a2 + 2) * v9 - *(_WORD *)(a2 + 4) * (signed __int16)(((v6 >> 7) & 1) + (v6 >> 8));
  *(_WORD *)v3 = ((v10 >> 10) & 1) + (v10 >> 11);
  *(_WORD *)(v3 + 2) = (((*(_WORD *)(a2 + 4) * v5 - *(_WORD *)a2 * v9) >> 10) & 1)
                     + ((*(_WORD *)(a2 + 4) * v5 - *(_WORD *)a2 * v9) >> 11);
  v11 = *(_WORD *)a2 * (signed __int16)(((v6 >> 7) & 1) + (v6 >> 8)) - *(_WORD *)(a2 + 2) * v5;
  *(_WORD *)(v3 + 4) = ((v11 >> 10) & 1) + (v11 >> 11);
  *(_WORD *)(v3 + 12) = -8 * *(_WORD *)a2;
  *(_WORD *)(v3 + 14) = -8 * *(_WORD *)(a2 + 2);
  *(_WORD *)(v3 + 16) = -8 * *(_WORD *)(a2 + 4);
  v12 = AKSC_invSqrt((signed __int16)v7 * (signed __int16)v7 + v5 * v5 + v9 * v9, &v24);
  v13 = (signed __int16)(16 - *(_WORD *)&v24);
  v14 = v12 << 16;
  if ( v13 > 0 )
    v14 = (((v12 >> (v13 - 1)) & 1) + (v12 >> v13)) << 16;
  v15 = SHIWORD(v14);
  v16 = *(_WORD *)(v3 + 6) * v15;
  if ( *(signed __int16 *)&v24 > 0 )
    v16 = ((v16 >> (v24 - 1)) & 1) + (v16 >> v24);
  *(_WORD *)(v3 + 6) = v16;
  v17 = *(_WORD *)(v3 + 8) * v15;
  if ( *(signed __int16 *)&v24 > 0 )
    v17 = ((v17 >> (v24 - 1)) & 1) + (v17 >> v24);
  *(_WORD *)(v3 + 8) = v17;
  v18 = *(_WORD *)(v3 + 10) * v15;
  if ( *(signed __int16 *)&v24 > 0 )
    LOWORD(v18) = ((v18 >> (v24 - 1)) & 1) + (v18 >> v24);
  *(_WORD *)(v3 + 10) = v18;
  v19 = *(_WORD *)v3 * v15;
  if ( *(signed __int16 *)&v24 > 0 )
    v19 = ((v19 >> (v24 - 1)) & 1) + (v19 >> v24);
  *(_WORD *)v3 = v19;
  v20 = *(_WORD *)(v3 + 2) * v15;
  if ( *(signed __int16 *)&v24 > 0 )
    v20 = ((v20 >> (v24 - 1)) & 1) + (v20 >> v24);
  v21 = *(_WORD *)(v3 + 4);
  *(_WORD *)(v3 + 2) = v20;
  v22 = v21 * v15;
  if ( *(signed __int16 *)&v24 > 0 )
    v22 = ((v22 >> (v24 - 1)) & 1) + (v22 >> v24);
  result = 1;
  *(_WORD *)(v3 + 4) = v22;
  return result;
}

//----- (00003CDC) --------------------------------------------------------
int __fastcall sub_3CDC(int a1, int a2, _WORD *a3)
{
  _WORD *v3; // r4@1
  __int16 v4; // r1@1
  int result; // r0@1

  v3 = a3;
  v4 = AKSC_atan2(
         (*(_WORD *)a2 * (signed int)*(_WORD *)a1
        + *(_WORD *)(a2 + 2) * (signed int)*(_WORD *)(a1 + 2)
        + 64
        + *(_WORD *)(a2 + 4) * (signed int)*(_WORD *)(a1 + 4)) << 9 >> 16,
         -(signed __int16)((*(_WORD *)a2 * (signed int)*(_WORD *)(a1 + 6)
                          + *(_WORD *)(a2 + 2) * (signed int)*(_WORD *)(a1 + 8)
                          + 64
                          + *(_WORD *)(a2 + 4) * (signed int)*(_WORD *)(a1 + 10)) >> 7));
  result = v4 + 1 - (v4 + ((unsigned int)v4 >= 0xFFFFFFFF));
  *v3 = v4;
  return result;
}

//----- (00003D4C) --------------------------------------------------------
int __fastcall sub_3D4C(int a1, int a2, signed __int16 *a3)
{
  signed __int16 *v3; // r5@1
  int v4; // r4@1
  __int16 v5; // r0@1
  int result; // r0@1
  signed __int16 v7; // r3@4

  v3 = a3;
  v4 = (*(_WORD *)a1 * (signed int)*(_WORD *)a2
      + *(_WORD *)(a1 + 2) * (signed int)*(_WORD *)(a2 + 2)
      + 64
      + *(_WORD *)(a1 + 4) * (signed int)*(_WORD *)(a2 + 4)) >> 7;
  v5 = AKSC_sqrt32(0x40000000 - (signed __int16)v4 * (signed __int16)v4);
  result = (unsigned __int16)AKSC_atan2(v5, (signed __int16)v4);
  *v3 = result;
  if ( (signed __int16)result > 5760 )
  {
    result -= 23040;
    *v3 = result;
  }
  if ( v4 > 0x7FFF )
  {
    v7 = 5760;
LABEL_9:
    *v3 = v7;
    return result;
  }
  if ( !v4 )
  {
    *v3 = 0;
    return result;
  }
  if ( v4 < -32767 )
  {
    v7 = -5760;
    goto LABEL_9;
  }
  return result;
}

//----- (00003DE0) --------------------------------------------------------
signed int __fastcall sub_3DE0(int a1, _WORD *a2, __int16 *a3, _WORD *a4, __int16 *a5)
{
  _WORD *v5; // r6@1
  int v6; // r4@1
  __int16 *v7; // r5@1
  __int16 v8; // r0@1
  __int16 v9; // r0@1
  int v10; // r3@1
  __int16 v11; // r0@2
  __int16 v12; // r0@2
  __int16 v13; // r3@2
  signed __int16 v14; // r2@4
  __int16 v15; // r3@6
  __int16 v16; // r3@7
  _WORD *v18; // [sp+4h] [bp-1Ch]@1

  v18 = a4;
  v5 = a2;
  v6 = a1;
  v7 = a3;
  v8 = AKSC_sqrt32(*(_WORD *)(a1 + 16) * *(_WORD *)(a1 + 16) + *(_WORD *)(a1 + 14) * *(_WORD *)(a1 + 14));
  v9 = AKSC_atan2(v8, -*(_WORD *)(v6 + 12));
  *v7 = v9;
  v10 = 0;
  if ( v9 != -1 )
  {
    *v7 = AKSC_angRng(v9, 1);
    v11 = AKSC_sqrt32(*(_WORD *)(v6 + 16) * *(_WORD *)(v6 + 16) + *(_WORD *)(v6 + 12) * *(_WORD *)(v6 + 12));
    v12 = AKSC_atan2(v11, *(_WORD *)(v6 + 14));
    *a5 = v12;
    *a5 = AKSC_angRng(v12, 1);
    v13 = *v7;
    if ( (signed int)*(_WORD *)(v6 + 16) >= 0 )
    {
      *v5 = v13;
      v16 = *a5;
    }
    else
    {
      if ( *v7 & 0x8000 )
        v14 = -11520;
      else
        v14 = 11520;
      *v5 = v14 - v13;
      v15 = *a5;
      if ( !(*a5 & 0x8000) )
      {
        *v18 = 11520 - v15;
        return 1;
      }
      v16 = -11520 - v15;
    }
    *v18 = v16;
    return 1;
  }
  return v10;
}

//----- (00003EAC) --------------------------------------------------------
int __fastcall sub_3EAC(int a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  int v4; // r4@1
  int v5; // r0@1
  _WORD *v6; // r7@1
  _WORD *v7; // r5@1
  __int16 v8; // r6@5
  __int16 v9; // r0@5
  int v10; // r5@5
  __int16 v11; // r0@5
  int v12; // r3@5
  int result; // r0@5
  __int16 v14; // r0@6
  _WORD *v15; // [sp+4h] [bp-1Ch]@1

  v15 = a2;
  v4 = a1;
  v5 = *(_WORD *)(a1 + 4);
  v6 = a3;
  v7 = a4;
  if ( v5 || *(_WORD *)(v4 + 10) )
    *a4 = AKSC_atan2((signed __int16)v5, *(_WORD *)(v4 + 10));
  else
    *a4 = 0;
  v8 = AKSC_sin(*v7);
  v9 = AKSC_cos(*v7);
  v10 = v9;
  v11 = AKSC_atan2(*(_WORD *)(v4 + 16), 2 * (*(_WORD *)(v4 + 4) * v9 + *(_WORD *)(v4 + 10) * v8 + 0x4000) >> 16);
  v12 = v11;
  *v6 = v11;
  result = 0;
  if ( v12 != -1 )
  {
    v14 = AKSC_atan2(
            2 * (*(_WORD *)(v4 + 8) * v10 + 0x4000 + *(_WORD *)(v4 + 2) * -v8) >> 16,
            2 * (*(_WORD *)(v4 + 6) * v10 + 0x4000 + *(_WORD *)v4 * -v8) >> 16);
    *v15 = v14;
    result = v14 + 1 - (v14 + ((unsigned int)v14 >= 0xFFFFFFFF));
  }
  return result;
}

//----- (00003F7C) --------------------------------------------------------
signed int __fastcall sub_3F7C(int a1, _WORD *a2)
{
  _WORD *v2; // r6@1
  int v3; // r3@1
  signed int result; // r0@1
  __int16 v5; // [sp+2h] [bp-16h]@1
  char v6; // [sp+4h] [bp-14h]@1
  __int16 v7; // [sp+6h] [bp-12h]@1

  v2 = a2;
  v3 = sub_3EAC(a1, &v5, &v6, &v7) << 16;
  result = 0;
  if ( v3 )
  {
    *v2 = AKSC_angRng(-v5 - v7, 0);
    result = 1;
  }
  return result;
}

//----- (00003FB8) --------------------------------------------------------
int __fastcall AKSC_DirectionS3(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _WORD *a9, signed __int16 *a10, _WORD *a11, _WORD *a12, _WORD *a13, _WORD *a14, __int16 *a15, _WORD *a16, __int16 *a17, int a18, int a19)
{
  int v19; // r4@1
  int v20; // r5@1
  signed int v21; // r5@2
  int v22; // r0@7
  __int16 v23; // r0@11
  __int16 v25; // [sp+8h] [bp-28h]@2
  __int16 v26; // [sp+Ah] [bp-26h]@2
  __int16 v27; // [sp+Ch] [bp-24h]@2
  __int16 v28; // [sp+10h] [bp-20h]@2
  __int16 v29; // [sp+12h] [bp-1Eh]@2
  __int16 v30; // [sp+14h] [bp-1Ch]@2

  v19 = a4;
  LOWORD(v20) = sub_348C(a1, a2, a3);
  if ( (signed __int16)v20 != -32768 )
  {
    v28 = *(_WORD *)v19;
    v29 = *(_WORD *)(v19 + 2);
    v30 = *(_WORD *)(v19 + 4);
    v25 = *(_WORD *)a5;
    v26 = *(_WORD *)(a5 + 2);
    v27 = *(_WORD *)(a5 + 4);
    v21 = sub_39B8((int)&v28, a11) << 16;
    v20 = ((__PAIR__(v21, v21) - __PAIR__((unsigned int)(v21 - 1), 1)) >> 32) + 2;
    if ( !(sub_39B8((int)&v25, a13) << 16) )
      LOWORD(v20) = v20 & 0xFFFC;
    AKSC_SetLayout((int)&v28, a7);
    AKSC_SetLayout((int)&v25, a8);
    sub_3A74((int)&v28, (int)&v25, a18);
    sub_3838(a18, a19);
    if ( *(_WORD *)a6 || *(_WORD *)(a6 + 2) || *(_WORD *)(a6 + 4) )
      v22 = sub_3CDC(a18, a6, a9);
    else
      v22 = sub_3F7C(a18, a9);
    if ( !(v22 << 16) )
      LOWORD(v20) = v20 & 0xFFFE;
    sub_3D4C((int)&v28, (int)&v25, a10);
    v23 = AKSC_cos(*a10);
    *a12 = ((unsigned int)(*a11 * v23 << 17) >> 31) + (*a11 * v23 >> 15);
    if ( !(sub_3DE0(a18, a14, a15, a16, a17) << 16) )
      LOWORD(v20) = v20 & 0xFFFD;
  }
  return (signed __int16)v20;
}

//----- (000040D8) --------------------------------------------------------
signed int __fastcall AKSC_VNorm(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r7@1
  int v6; // r5@1
  int v7; // r4@2
  int v8; // r1@3
  __int16 v9; // r0@4
  int v10; // r2@4
  signed int v11; // r3@4
  int v13; // [sp+0h] [bp-28h]@1
  int v14; // [sp+4h] [bp-24h]@1
  signed __int16 v15[13]; // [sp+Eh] [bp-1Ah]@4

  v13 = a1;
  v14 = a2;
  v5 = a3;
  v6 = a4;
  if ( a4 > 0 )
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = *(_WORD *)(v5 + v7);
      if ( v8 <= 0 )
        break;
      v9 = AKSC_div16f(v6, v8, v15);
      v10 = v15[0];
      v11 = v9 * (*(_WORD *)(v13 + v7) - *(_WORD *)(v14 + v7));
      if ( !((v10 + 14 < 0) ^ __OFADD__(v10, 14)) )
        v11 = ((v11 >> (LOBYTE(v15[0]) + 14)) & 1)
            + (v9 * (*(_WORD *)(v13 + v7) - (signed int)*(_WORD *)(v14 + v7)) >> (LOBYTE(v15[0]) + 15));
      if ( (unsigned int)(v11 + 0x8000) > 0xFFFF )
        break;
      *(_WORD *)(a5 + v7) = v11;
      v7 += 2;
      if ( v7 == 6 )
        return 1;
    }
  }
  return 0;
}

//----- (00004154) --------------------------------------------------------
int __fastcall AKSC_cholSl(int a1, signed int a2, int a3, int a4, int a5, int a6)
{
  int v6; // r4@1
  int v7; // r1@1
  int v8; // r3@1
  int v9; // r0@1
  int v10; // r5@2
  int v11; // r2@2
  int v12; // r12@2
  int v13; // r7@3
  int v14; // r3@3
  signed int v15; // r5@5
  int v16; // r3@7
  int v17; // r4@7
  int v18; // r2@7
  int result; // r0@7
  signed int v20; // r1@8
  _WORD *v21; // r6@8
  _WORD *v22; // r5@8
  int v23; // r12@8
  int i; // r7@8
  int v25; // r0@9
  int v26; // r3@9
  int v27; // [sp+4h] [bp-44h]@8
  int v28; // [sp+10h] [bp-38h]@2
  int v29; // [sp+10h] [bp-38h]@8
  int v30; // [sp+14h] [bp-34h]@7
  signed int v31; // [sp+18h] [bp-30h]@1
  int v32; // [sp+1Ch] [bp-2Ch]@1
  int v33; // [sp+20h] [bp-28h]@1
  int v34; // [sp+24h] [bp-24h]@1

  v31 = a2;
  v32 = a1;
  v34 = a4;
  v33 = a3;
  v6 = a1 - 2;
  v7 = a6 - 2;
  v8 = 0;
  v9 = 0;
  while ( (signed __int16)v9 < v31 )
  {
    v28 = -v8;
    v10 = 0;
    v11 = 0;
    v12 = v8;
    while ( v11 != v28 )
    {
      v13 = *(_WORD *)(v7 + v11);
      v14 = *(_WORD *)(v6 + v11);
      v11 -= 2;
      v10 += v14 * v13;
    }
    v15 = (*(_WORD *)(a5 + v12) << 15) - 4 * v10;
    v9 = (v9 + 1) & 0xFFFF;
    v6 += 8;
    v8 = v12 + 2;
    *(_WORD *)(v7 + 2) = 2
                       * (*(_WORD *)(v33 + v12) * HIWORD(v15)
                        + (*(_WORD *)(v34 + v12) * (v15 >> 16) >> 15)
                        + ((signed int)(*(_WORD *)(v33 + v12) * ((unsigned int)(v15 << 16) >> 17)) >> 15));
    v7 += 2;
  }
  v16 = 0;
  v17 = 0;
  v18 = (unsigned __int16)v31;
  v30 = ((v31 << 16) - 0x10000) >> 16;
  result = 2 * v30;
  while ( !((v18 - 1) & 0x8000) )
  {
    v29 = a6 + result;
    v20 = *(_WORD *)(a6 + result + v16) << 15;
    v21 = (_WORD *)(2 * (v30 - v17) + v32 + 6 * (signed __int16)v18);
    v27 = result;
    v22 = (_WORD *)(a6 + 2 * (signed __int16)v18);
    v23 = v16;
    for ( i = v18; v31 > (signed __int16)i; i = (i + 1) & 0xFFFF )
    {
      v25 = *v22;
      ++v22;
      v26 = *v21;
      v21 += 3;
      v20 -= 4 * v26 * v25;
    }
    result = v27;
    ++v17;
    *(_WORD *)(v29 + v23) = 2
                          * (*(_WORD *)(v33 + v27 + v23) * HIWORD(v20)
                           + (*(_WORD *)(v34 + v27 + v23) * (v20 >> 16) >> 15)
                           + ((signed int)(*(_WORD *)(v33 + v27 + v23) * ((unsigned int)(v20 << 16) >> 17)) >> 15));
    v18 = (v18 - 1) & 0xFFFF;
    v16 = v23 - 2;
  }
  return result;
}

//----- (000042A8) --------------------------------------------------------
signed int __fastcall AKSC_cholDc(int a1, signed int a2, int a3, int a4)
{
  int v4; // r6@1
  int v5; // r7@1
  signed int v6; // r5@1
  int v7; // r0@2
  int v8; // r3@2
  int v9; // r2@2
  __int16 v10; // r12@2
  int v11; // ST18_4@3
  int v12; // r4@3
  signed __int64 v13; // kr00_8@7
  int v14; // r4@9
  int v16; // [sp+8h] [bp-58h]@2
  int v17; // [sp+10h] [bp-50h]@1
  int v18; // [sp+14h] [bp-4Ch]@1
  int v19; // [sp+1Ch] [bp-44h]@1
  signed int v20; // [sp+20h] [bp-40h]@1
  int v21; // [sp+24h] [bp-3Ch]@1
  int v22; // [sp+28h] [bp-38h]@1
  int v23; // [sp+34h] [bp-2Ch]@2
  __int16 v24; // [sp+46h] [bp-1Ah]@7

  v21 = a3;
  v20 = a2;
  v22 = a4;
  v4 = 0;
  v19 = a1;
  v18 = (a2 - 1) & 0xFFFF;
  v5 = a1;
  v6 = -1;
  v17 = 0;
LABEL_11:
  if ( (signed __int16)v17 >= v20 )
    return 1;
  v14 = 0;
  while ( 1 )
  {
    v7 = *(_WORD *)(v5 + 2 * v14) << 15;
    v23 = 3 * (v14 + v17) + v6;
    v16 = v14;
    v8 = 0;
    v9 = (unsigned __int16)v6;
    v10 = v14 + v17;
    while ( !(v9 & 0x8000) )
    {
      v11 = *(_WORD *)(v19 + 2 * v23 + v8);
      v12 = *(_WORD *)(v5 - 2 + v8);
      v8 -= 2;
      v7 -= 4 * v12 * v11;
      v9 = (v9 - 1) & 0xFFFF;
    }
    if ( (signed __int16)v17 != v10 )
    {
      *(_WORD *)(v5 + 6 * v16) = 2
                               * (*(_WORD *)(v21 + v4) * HIWORD(v7)
                                + (*(_WORD *)(v22 + v4) * (v7 >> 16) >> 15)
                                + ((signed int)(*(_WORD *)(v21 + v4) * ((unsigned int)(v7 << 16) >> 17)) >> 15));
      goto LABEL_9;
    }
    if ( v7 <= 0 )
      return 0;
    v13 = (signed __int64)AKSC_invSqrt(v7, &v24) << 16;
    *(_WORD *)(v21 + v4) = WORD2(v13);
    *(_WORD *)(v22 + v4) = (unsigned int)v13 >> 17;
LABEL_9:
    v14 = v16 + 1;
    if ( v16 + 1 == v18 + 1 )
    {
      v4 += 2;
      ++v17;
      v5 += 8;
      ++v6;
      v18 = (v18 - 1) & 0xFFFF;
      goto LABEL_11;
    }
  }
}

//----- (000043C4) --------------------------------------------------------
signed int __fastcall AKSC_fitOnPlane(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // r4@1
  int v6; // r12@1
  __int16 v7; // r0@1
  int v8; // r5@1
  int v9; // r0@1
  int v10; // r5@1
  int v11; // r6@1
  signed int v12; // r1@1
  __int16 v13; // r7@7
  signed int v14; // r3@8
  __int16 v15; // r12@9
  signed int v16; // r3@12
  __int16 v17; // r0@13
  int v18; // r0@15
  int v19; // r12@15
  int v20; // r3@15
  unsigned int v21; // r6@15
  unsigned int v22; // r5@15
  int v23; // r3@15
  unsigned int v24; // r1@15
  int v25; // r3@15
  int v26; // r5@15
  int v27; // r2@15
  int v28; // r1@15
  int i; // r0@15
  int v30; // r4@16
  int v31; // r4@22
  signed int v32; // r1@22
  signed int result; // r0@22
  __int16 v34; // [sp+14h] [bp-6Ch]@9
  int v35; // [sp+14h] [bp-6Ch]@15
  int v36; // [sp+18h] [bp-68h]@15
  int v37; // [sp+1Ch] [bp-64h]@1
  int v38; // [sp+1Ch] [bp-64h]@16
  __int16 v39; // [sp+20h] [bp-60h]@1
  __int16 v40; // [sp+24h] [bp-5Ch]@9
  __int16 v41; // [sp+28h] [bp-58h]@1
  int v42; // [sp+2Ch] [bp-54h]@1
  __int16 v43; // [sp+34h] [bp-4Ch]@7
  __int16 v44; // [sp+36h] [bp-4Ah]@7
  __int16 v45; // [sp+3Ah] [bp-46h]@7
  __int16 v46; // [sp+3Ch] [bp-44h]@7
  signed __int16 v47[8]; // [sp+48h] [bp-38h]@8
  signed __int16 v48; // [sp+4Ah] [bp-36h]@8
  signed __int16 v49[8]; // [sp+50h] [bp-30h]@7
  char v50; // [sp+58h] [bp-28h]@7
  __int16 v51; // [sp+60h] [bp-20h]@7
  __int16 v52; // [sp+62h] [bp-1Eh]@7
  __int16 v53; // [sp+66h] [bp-1Ah]@15

  v42 = a2;
  v37 = a1;
  v5 = a4;
  v6 = *(_WORD *)(a3 + 8);
  v7 = *(_WORD *)(a3 + 16);
  v41 = v7;
  v8 = v7;
  v9 = v6 * v7 - *(_WORD *)(a3 + 10) * *(_WORD *)(a3 + 10);
  v39 = *(_WORD *)a3;
  v10 = v8 * *(_WORD *)a3 - *(_WORD *)(a3 + 12) * *(_WORD *)(a3 + 12);
  v11 = v6 * *(_WORD *)a3;
  v12 = 0;
  if ( v10 > v9 )
  {
    v9 = v10;
    v12 = 1;
  }
  if ( v11 - *(_WORD *)(a3 + 2) * (signed int)*(_WORD *)(a3 + 2) > v9 )
  {
    v9 = v11 - *(_WORD *)(a3 + 2) * *(_WORD *)(a3 + 2);
    v12 = 2;
  }
  if ( v9 <= 0 )
    return 0;
  if ( !v12 )
  {
    v43 = *(_WORD *)(a3 + 8);
    v45 = *(_WORD *)(a3 + 10);
    v13 = *(_WORD *)(a3 + 2);
    v44 = v45;
    v51 = -v13;
    v46 = *(_WORD *)(a3 + 16);
    v52 = -*(_WORD *)(a3 + 12);
    if ( AKSC_cholDc((int)&v43, 2, (int)&v50, (int)v49) << 16 )
    {
      AKSC_cholSl((int)&v43, 2, (int)&v50, (int)v49, (int)&v51, (int)v47);
      *(_WORD *)v5 = 2048;
      *(_WORD *)(v5 + 2) = v47[0] >> 2;
      v14 = v48;
LABEL_12:
      v16 = v14 >> 2;
      goto LABEL_15;
    }
    return 0;
  }
  v40 = *(_WORD *)(a3 + 10);
  v15 = *(_WORD *)(a3 + 2);
  v34 = *(_WORD *)(a3 + 12);
  if ( v12 == 1 )
  {
    v43 = v41;
    v44 = v34;
    v51 = -v40;
    v45 = v34;
    v46 = *(_WORD *)a3;
    v52 = -v15;
    if ( AKSC_cholDc((int)&v43, 2, (int)&v50, (int)v49) << 16 )
    {
      AKSC_cholSl((int)&v43, 2, (int)&v50, (int)v49, (int)&v51, (int)v47);
      *(_WORD *)v5 = v48 >> 2;
      *(_WORD *)(v5 + 2) = 2048;
      v14 = v47[0];
      goto LABEL_12;
    }
    return 0;
  }
  v44 = *(_WORD *)(a3 + 2);
  v43 = v39;
  v51 = -v34;
  v45 = *(_WORD *)(a3 + 6);
  v17 = *(_WORD *)(a3 + 8);
  v52 = -v40;
  v46 = v17;
  if ( !(AKSC_cholDc((int)&v43, 2, (int)&v50, (int)v49) << 16) )
    return 0;
  AKSC_cholSl((int)&v43, 2, (int)&v50, (int)v49, (int)&v51, (int)v47);
  *(_WORD *)v5 = v47[0] >> 2;
  LOWORD(v16) = 2048;
  *(_WORD *)(v5 + 2) = v48 >> 2;
LABEL_15:
  *(_WORD *)(v5 + 4) = v16;
  v18 = AKSC_invSqrt(
          *(_WORD *)(v5 + 2) * *(_WORD *)(v5 + 2)
        + *(_WORD *)v5 * *(_WORD *)v5
        + *(_WORD *)(v5 + 4) * *(_WORD *)(v5 + 4),
          &v53) << 8 >> 16;
  v19 = v5;
  v20 = *(_WORD *)(v5 + 2);
  v21 = (unsigned int)(32 * *(_WORD *)v5 * v18) >> 16;
  *(_WORD *)v5 = v21;
  v22 = (unsigned int)(32 * v20 * v18) >> 16;
  v23 = *(_WORD *)(v5 + 4) * v18;
  *(_WORD *)(v5 + 2) = v22;
  v24 = (unsigned int)(32 * v23) >> 16;
  *(_WORD *)(v5 + 4) = v24;
  v36 = (signed __int16)v24;
  v35 = (signed __int16)v22;
  v25 = v37;
  v26 = *(_WORD *)(v37 + 2) * (signed __int16)v22
      + *(_WORD *)v37 * (signed __int16)v21
      + *(_WORD *)(v37 + 4) * (signed __int16)v24;
  v27 = v26;
  v28 = v26;
  for ( i = 1; ; i = (i + 1) & 0xFFFF )
  {
    v25 += 6;
    if ( (signed __int16)i >= v42 )
      break;
    v38 = *(_WORD *)(v25 + 2) * v35 + *(_WORD *)v25 * (signed __int16)v21;
    v30 = v38 + *(_WORD *)(v25 + 4) * v36;
    if ( v28 < v30 )
      v28 = v38 + *(_WORD *)(v25 + 4) * v36;
    if ( v27 > v30 )
      v27 = v38 + *(_WORD *)(v25 + 4) * v36;
    v26 += v30;
  }
  *a5 = (v28 - v27) >> 11;
  v31 = v19;
  v32 = (signed __int16)AKSC_div16(1, v42) * (32 * v26 >> 16);
  result = 1;
  *(_WORD *)(v31 + 6) = -(v32 >> 15);
  return result;
}

//----- (00004684) --------------------------------------------------------
signed int __fastcall AKSC_getCoeff(int a1, int a2, int a3, int a4)
{
  __int16 v4; // r0@2
  unsigned int v5; // r1@2
  int v6; // r2@2
  int v7; // r4@2
  int v8; // r5@2
  int v9; // r6@2
  int v10; // r3@3
  int v11; // r3@5
  int v12; // r2@5
  int v13; // r3@8
  int v14; // r2@8
  int v15; // r5@9
  __int16 v16; // r6@9
  char *v17; // r4@9
  int v18; // r5@11
  int v19; // r7@11
  int v20; // r0@11
  int v21; // r2@11
  int v22; // r6@11
  int v23; // ST04_4@12
  int v24; // ST3C_4@12
  int v25; // ST0C_4@12
  char *v26; // ST28_4@12
  int v27; // r1@12
  int v28; // ST34_4@12
  int v29; // ST3C_4@12
  int v30; // ST28_4@12
  int v31; // r7@12
  int v32; // r1@12
  int v33; // r7@12
  int v34; // r1@14
  int *v35; // r6@14
  int v36; // r7@14
  signed int v37; // r5@14
  int v38; // r0@15
  unsigned __int16 v39; // r3@15
  int v40; // r4@17
  signed int *v41; // r4@20
  int v42; // r0@21
  unsigned int v43; // r3@21
  unsigned int v44; // r0@21
  int v45; // r2@24
  int v46; // r1@24
  int v47; // r0@24
  int v48; // r2@24
  int v49; // r3@24
  signed int result; // r0@26
  int v51; // [sp+14h] [bp-17Ch]@1
  signed int v52; // [sp+14h] [bp-17Ch]@14
  signed int v53; // [sp+18h] [bp-178h]@1
  signed int v54; // [sp+18h] [bp-178h]@14
  int v55; // [sp+1Ch] [bp-174h]@1
  unsigned int v56; // [sp+20h] [bp-170h]@5
  int v57; // [sp+20h] [bp-170h]@11
  unsigned int v58; // [sp+24h] [bp-16Ch]@5
  int v59; // [sp+24h] [bp-16Ch]@11
  int v60; // [sp+2Ch] [bp-164h]@11
  int v61; // [sp+30h] [bp-160h]@11
  int v62; // [sp+34h] [bp-15Ch]@11
  int v63; // [sp+38h] [bp-158h]@1
  char v64[192]; // [sp+48h] [bp-148h]@9
  char v65[64]; // [sp+108h] [bp-88h]@6
  int v66; // [sp+148h] [bp-48h]@11
  int v67; // [sp+14Ch] [bp-44h]@11
  int v68; // [sp+150h] [bp-40h]@11
  int v69; // [sp+154h] [bp-3Ch]@11
  int v70; // [sp+158h] [bp-38h]@11
  int v71; // [sp+15Ch] [bp-34h]@11
  int v72; // [sp+160h] [bp-30h]@11
  int v73; // [sp+164h] [bp-2Ch]@11
  int v74; // [sp+168h] [bp-28h]@11
  int v75; // [sp+16Ch] [bp-24h]@11
  signed int v76; // [sp+170h] [bp-20h]@11
  signed int v77; // [sp+174h] [bp-1Ch]@11
  char v78; // [sp+178h] [bp-18h]@23

  v51 = a1;
  v53 = a2;
  v55 = a3;
  v63 = a4;
  if ( a2 > 32 )
    goto LABEL_30;
  v4 = AKSC_div16(1, a2);
  v5 = 0;
  v6 = v51;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  while ( (signed __int16)v9 < v53 )
  {
    v9 = (v9 + 1) & 0xFFFF;
    v8 += *(_WORD *)v6 * v4;
    v7 += *(_WORD *)(v6 + 2) * v4;
    v10 = *(_WORD *)(v6 + 4);
    v6 += 6;
    v5 += v10 * v4;
  }
  v11 = v51;
  v58 = (unsigned int)(2 * v8) >> 16;
  v56 = (unsigned int)(2 * v7) >> 16;
  v12 = 0;
  while ( (signed __int16)v12 < v53 )
  {
    *(_WORD *)&v65[2 * v12++] = (*(_WORD *)(v11 + 2) * (signed int)*(_WORD *)(v11 + 2)
                               + *(_WORD *)v11 * (signed int)*(_WORD *)v11
                               + *(_WORD *)(v11 + 4) * (signed int)*(_WORD *)(v11 + 4)) >> 11;
    v11 += 6;
  }
  v13 = 0;
  v14 = 0;
  while ( (signed __int16)v14 < v53 )
  {
    v14 = (v14 + 1) & 0xFFFF;
    *(_WORD *)&v64[v13] = *(_WORD *)(v51 + v13) - v58;
    v15 = v51 + v13;
    v16 = *(_WORD *)(v51 + v13 + 2);
    v17 = &v64[v13];
    v13 += 6;
    *((_WORD *)v17 + 1) = v16 - v56;
    *((_WORD *)v17 + 2) = *(_WORD *)(v15 + 4) - (v5 >> 15);
  }
  v18 = 0;
  v74 = 0;
  v70 = 0;
  v69 = 0;
  v67 = 0;
  v72 = 0;
  v68 = 0;
  v73 = 0;
  v71 = 0;
  v77 = 0;
  v76 = 0;
  v75 = 0;
  v66 = 0;
  v61 = 0;
  v60 = 0;
  v59 = 0;
  v19 = 0;
  v57 = 0;
  v20 = 0;
  v62 = 0;
  v21 = 0;
  v22 = 0;
  while ( (signed __int16)v20 < v53 )
  {
    v23 = *(_WORD *)&v64[v21];
    v61 += *(_WORD *)(v51 + v21) * v23;
    v24 = v51 + v21;
    v25 = *(_WORD *)(v51 + v21 + 2);
    v22 += v23 * v25;
    v26 = &v64[v21];
    v27 = *(_WORD *)&v64[v21 + 2];
    v21 += 6;
    v28 = v27;
    v60 += v25 * v27;
    v29 = *(_WORD *)(v24 + 4);
    v30 = *((_WORD *)v26 + 2);
    v59 += v29 * v30;
    v18 = v19 + v23 * v29;
    v57 += v27 * v29;
    v71 = v57;
    v31 = 2 * v20++;
    v32 = *(_WORD *)&v65[v31];
    v33 = v28;
    v75 += v23 * v32;
    v62 = v22;
    v76 += v33 * v32;
    v77 += v30 * v32;
    v19 = v18;
  }
  v34 = v22;
  v35 = &v66;
  v70 = v60;
  v66 = v61;
  v69 = v34;
  v72 = v19;
  v68 = v18;
  v73 = v57;
  v74 = v59;
  v67 = v62;
  v36 = v75 >> 1;
  v75 >>= 1;
  v54 = v76 >> 1;
  v76 >>= 1;
  v52 = v77 >> 1;
  v77 >>= 1;
  v37 = 32;
  do
  {
    v40 = 0;
    do
    {
      v38 = AKSC_norm32(v35[v40]);
      v39 = v38;
      if ( v37 << 16 < v38 << 16 )
        v39 = v37;
      ++v40;
      v37 = v39;
    }
    while ( v40 != 3 );
    v35 += 3;
  }
  while ( v35 != &v75 );
  v41 = &v75;
  do
  {
    v42 = AKSC_norm32(*v41);
    LOWORD(v43) = v37;
    v44 = v42 << 16;
    if ( (signed int)v44 < v37 << 16 )
      v43 = v44 >> 16;
    ++v41;
    v37 = (unsigned __int16)v43;
  }
  while ( (char *)v41 != &v78 );
  v45 = (v67 << v43 >> 18) & 0xFFFF;
  *(_WORD *)(v55 + 6) = v67 << v43 >> 18;
  v46 = v55 + 6;
  *(_WORD *)(v55 + 2) = v45;
  v47 = (v68 << v43 >> 18) & 0xFFFF;
  *(_WORD *)(v55 + 12) = v68 << v43 >> 18;
  v48 = v55 + 12;
  *(_WORD *)(v55 + 4) = v47;
  v49 = (v71 << v43 >> 18) & 0xFFFF;
  *(_WORD *)(v48 + 2) = v71 << v37 >> 18;
  *(_WORD *)(v46 + 4) = v49;
  *(_WORD *)v55 = v66 << v37 >> 18;
  *(_WORD *)(v46 + 2) = v70 << v37 >> 18;
  *(_WORD *)(v48 + 4) = v74 << v37 >> 18;
  *(_WORD *)v63 = v36 << v37 >> 18;
  *(_WORD *)(v63 + 2) = v54 << v37 >> 18;
  *(_WORD *)(v63 + 4) = v52 << v37 >> 18;
  if ( (signed int)*(_WORD *)v55 <= 5
    || (signed int)*(_WORD *)(v55 + 8) <= 5
    || (result = 4, (signed int)*(_WORD *)(v55 + 16) <= 5) )
  {
LABEL_30:
    result = 0;
  }
  return result;
}
// 4684: using guessed type char var_88[64];
// 4684: using guessed type char var_148[192];

//----- (00004984) --------------------------------------------------------
int __fastcall sub_4984(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r4@1
  signed int v5; // r1@1
  signed int v6; // r2@1
  int v7; // r0@1
  unsigned int v8; // r3@2
  int v9; // r1@2
  signed int v10; // r3@2
  int v11; // r1@3
  int v12; // r7@8
  unsigned int v13; // r3@8
  int v14; // r0@10
  int v15; // r1@13
  int v16; // r7@16
  unsigned int v17; // r3@16
  int v18; // r0@18
  int v19; // r1@21
  int v20; // r1@27
  int v21; // r1@33
  int v22; // r1@39
  int v23; // r2@45
  int v24; // r3@46
  int v25; // r2@47
  int v26; // r3@48
  int v27; // r5@49
  int v28; // r2@49
  int v29; // r3@50
  int v30; // r7@51
  int v31; // r2@51
  int result; // r0@52
  int v33; // [sp+4h] [bp-54h]@1
  char v34[12]; // [sp+Ch] [bp-4Ch]@1
  char dest[12]; // [sp+18h] [bp-40h]@1
  int v36; // [sp+24h] [bp-34h]@1
  int v37; // [sp+28h] [bp-30h]@1
  __int16 v38; // [sp+2Ch] [bp-2Ch]@1
  int v39; // [sp+30h] [bp-28h]@1
  int v40; // [sp+34h] [bp-24h]@1
  __int16 v41; // [sp+38h] [bp-20h]@1
  int v42; // [sp+3Ch] [bp-1Ch]@1

  v33 = a3;
  v3 = a2;
  v4 = a1;
  v42 = _stack_chk_guard;
  memcpy(dest, &unk_7D10, 0xBu);
  v39 = 1206631600;
  v41 = 92;
  v40 = 1553417105;
  memcpy(v34, "ASAHIKASEI", 0xBu);
  v36 = 1598375756;
  v37 = 1197421366;
  v38 = 66;
  v5 = 1;
  v6 = 0;
  v7 = 2;
  while ( 1 )
  {
    v8 = (v5 + v6) << 16;
    v6 = v5;
    v9 = (signed __int16)(v7 + 1);
    v10 = v8 >> 16;
    v7 = (v7 + 1) & 0xFFFF;
    if ( v9 == 10 )
      break;
    v5 = v10;
  }
  v11 = 0;
  while ( dest[v11] )
  {
    v12 = (v10 + v6) & 0xFFFF;
    dest[v11] = dest[v11] + 2 - (v10 + v6);
    ++v11;
    v6 = v10;
    v13 = v12 << 16;
    if ( v11 == 16 )
      goto LABEL_11;
    v10 = (unsigned __int16)v12;
  }
  v11 = (unsigned __int16)v11;
  while ( (signed __int16)v11 <= 15 )
  {
    v14 = v10 + v6;
    v6 = v10;
    v11 = (v11 + 1) & 0xFFFF;
    v13 = v14 << 16;
LABEL_11:
    v10 = v13 >> 16;
  }
  v15 = 0;
  while ( *((_BYTE *)&v39 + v15) )
  {
    v16 = (v10 + v6) & 0xFFFF;
    *((_BYTE *)&v39 + v15) = *((_BYTE *)&v39 + v15) - 51 - (v10 + v6);
    ++v15;
    v6 = v10;
    v17 = v16 << 16;
    if ( v15 == 16 )
      goto LABEL_19;
    v10 = (unsigned __int16)v16;
  }
  v15 = (unsigned __int16)v15;
  while ( (signed __int16)v15 <= 15 )
  {
    v18 = v10 + v6;
    v6 = v10;
    v15 = (v15 + 1) & 0xFFFF;
    v17 = v18 << 16;
LABEL_19:
    v10 = v17 >> 16;
  }
  v19 = 0;
  do
  {
    if ( !dest[v19] && !*(_BYTE *)(v4 + v19) )
      goto LABEL_27;
    if ( *(_BYTE *)(v4 + v19) != (unsigned __int8)dest[v19] )
      goto LABEL_53;
    ++v19;
  }
  while ( v19 != 16 );
  if ( *(_BYTE *)(v4 + 16) )
  {
LABEL_53:
    LOWORD(result) = -32768;
    goto LABEL_54;
  }
LABEL_27:
  v20 = 0;
  while ( *((_BYTE *)&v39 + v20) || *(_BYTE *)(v3 + v20) )
  {
    if ( *(_BYTE *)(v3 + v20) != *((_BYTE *)&v39 + v20) )
      goto LABEL_53;
    if ( ++v20 == 16 )
    {
      if ( *(_BYTE *)(v3 + 16) )
        goto LABEL_53;
      break;
    }
  }
  v21 = 0;
  while ( v34[v21] || *(_BYTE *)(v4 + v21) )
  {
    if ( *(_BYTE *)(v4 + v21) != (unsigned __int8)v34[v21] )
      goto LABEL_53;
    if ( ++v21 == 16 )
    {
      if ( *(_BYTE *)(v4 + 16) )
        goto LABEL_53;
      break;
    }
  }
  v22 = 0;
  while ( *((_BYTE *)&v36 + v22) || *(_BYTE *)(v3 + v22) )
  {
    if ( *(_BYTE *)(v3 + v22) != *((_BYTE *)&v36 + v22) )
      goto LABEL_53;
    if ( ++v22 == 16 )
    {
      if ( *(_BYTE *)(v3 + 16) )
        goto LABEL_53;
      break;
    }
  }
  v23 = (v10 + v6) & 0xFFFF;
  if ( *(_WORD *)v33 != (signed __int16)(12091 - v23) )
    goto LABEL_53;
  v24 = (v23 + v10) & 0xFFFF;
  if ( *(_WORD *)(v33 + 2) != (signed __int16)(-26131 - v24) )
    goto LABEL_53;
  v25 = (v24 + v23) & 0xFFFF;
  if ( (-23074 - v25) << 16 > *(_WORD *)(v33 + 4) << 16 )
    goto LABEL_53;
  v26 = (v25 + v24) & 0xFFFF;
  if ( (signed __int16)(16512 - v26) < (signed int)*(_WORD *)(v33 + 4) )
    goto LABEL_53;
  v27 = *(_WORD *)(v33 + 6);
  v28 = (v26 + v25) & 0xFFFF;
  if ( (-6816 - v28) << 16 > v27 << 16 )
    goto LABEL_53;
  v29 = (v28 + v26) & 0xFFFF;
  if ( (signed __int16)(9695 - v29) < (signed __int16)v27 )
    goto LABEL_53;
  v30 = *(_WORD *)(v33 + 8);
  v31 = (v29 + v28) & 0xFFFF;
  if ( (2625 - v31) << 16 > v30 << 16 )
    goto LABEL_53;
  LOWORD(result) = 1;
  if ( (signed __int16)(12319 - v29 - v31) < (signed __int16)v30 )
    goto LABEL_53;
LABEL_54:
  result = (signed __int16)result;
  if ( v42 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 18C4: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 4984: using guessed type char dest[12];
// 4984: using guessed type char var_4C[12];

//----- (00004C28) --------------------------------------------------------
int __fastcall AKSC_SetHDOELevel(int a1, int a2, __int16 a3, int a4)
{
  int v4; // r4@1
  int v5; // r3@2
  int v6; // r2@3
  int v7; // r3@4
  int v8; // r2@5
  int v9; // r3@6
  int v10; // r6@6
  int v11; // r7@7
  signed __int16 v12; // r2@9
  int result; // r0@9
  __int16 v14; // [sp+14h] [bp-1Ch]@1

  v4 = a1;
  v14 = a3;
  if ( a4 )
  {
    v5 = 0;
    do
    {
      v6 = a1 + v5;
      v5 += 6;
      *(_WORD *)(v6 + 4) = I16V_INIT_VALUE;
      *(_WORD *)(v6 + 8) = unk_7FDC;
      *(_WORD *)(v6 + 6) = unk_7FDA;
    }
    while ( v5 != 192 );
    v7 = 0;
    do
    {
      *(_WORD *)(a1 + v7 + 196) = I16V_INIT_VALUE;
      v8 = a1 + v7 + 198;
      v7 += 6;
      *(_WORD *)v8 = unk_7FDA;
      *(_WORD *)(v8 + 2) = unk_7FDC;
    }
    while ( v7 != 96 );
    v9 = a1 + 292;
    v10 = 0;
    do
    {
      *(_WORD *)(v9 + 2) = unk_7FDA;
      *(_WORD *)v9 = I16V_INIT_VALUE;
      *(_WORD *)(v9 + 4) = unk_7FDC;
      *(_WORD *)(v9 + 108) = I16V_INIT_VALUE;
      *(_WORD *)(v9 + 110) = unk_7FDA;
      *(_WORD *)(v9 + 112) = unk_7FDC;
      v11 = (signed __int16)(v10 + 1);
      v9 += 6;
      v10 = (v10 + 1) & 0xFFFF;
    }
    while ( v11 != 16 );
  }
  if ( v14 > 0 )
  {
    *(_WORD *)(a1 + 388) = 1;
    result = AKSC_buffer(a2, 16, 1, a1 + 292);
    if ( v14 <= 3 )
    {
      *(_WORD *)(v4 + 390) = v14 - 1;
      return result;
    }
    v12 = 2;
  }
  else
  {
    v12 = 0;
    result = 195;
    *(_WORD *)(v4 + 388) = 0;
  }
  *(_WORD *)(v4 + 390) = v12;
  return result;
}

//----- (00004D18) --------------------------------------------------------
signed int __fastcall zzAKSC_InitHDOEProcPrmsS3(int a1, int a2, int a3, __int16 a4, int a5, __int16 a6)
{
  int v6; // r4@1
  __int16 v7; // r5@1
  signed int result; // r0@1

  v6 = a1;
  *(_DWORD *)a1 = a2;
  v7 = a4;
  *(_DWORD *)(a1 + 396) = a3;
  AKSC_SetHDOELevel(a1, a5, a6, 1);
  *(_WORD *)(v6 + 392) = 0;
  result = 249;
  *(_WORD *)(v6 + 394) = v7;
  *(_WORD *)(v6 + 496) = 0;
  *(_WORD *)(v6 + 498) = 0;
  return result;
}

//----- (00004D50) --------------------------------------------------------
int __fastcall sub_4D50(int a1, int a2, int a3, int a4, _WORD *a5, _WORD *a6)
{
  int v6; // r7@1
  int v7; // r4@1
  int v8; // r6@2
  signed int v9; // r5@2
  int v10; // r6@3
  int v11; // r1@3
  int v12; // r3@3
  unsigned __int16 v13; // r0@3
  int v14; // r2@4
  int v15; // r1@4
  int v16; // r3@4
  unsigned int v17; // r0@4
  int v18; // r0@4
  unsigned __int16 v19; // r3@4
  unsigned __int16 v20; // r3@6
  int v21; // r0@10
  int v22; // r0@10
  int v23; // r3@10
  int result; // r0@10
  int v25; // [sp+4h] [bp-24h]@2
  int i; // [sp+8h] [bp-20h]@3
  int v27; // [sp+Ch] [bp-1Ch]@1

  v6 = a1;
  v27 = a2;
  v7 = a3;
  if ( a4 == 4 )
  {
    v10 = *(_WORD *)a1 - *(_WORD *)a3;
    v11 = *(_WORD *)(a1 + 2) - *(_WORD *)(a3 + 2);
    v12 = *(_WORD *)(a1 + 4) - *(_WORD *)(a3 + 4);
    v9 = v11 * v11 + v10 * v10 + v12 * v12;
    v13 = AKSC_sqrt32(v9);
    v8 = v13;
    v25 = v13;
    for ( i = 1; ; i = (i + 1) & 0xFFFF )
    {
      v6 += 6;
      if ( (signed __int16)i >= v27 )
        break;
      v14 = *(_WORD *)v6 - *(_WORD *)v7;
      v15 = *(_WORD *)(v6 + 2) - *(_WORD *)(v7 + 2);
      v16 = *(_WORD *)(v6 + 4) - *(_WORD *)(v7 + 4);
      v17 = v15 * v15 + v14 * v14 + v16 * v16;
      v9 += v17;
      v18 = (unsigned __int16)AKSC_sqrt32(v17);
      v19 = v18;
      if ( v25 << 16 > v18 << 16 )
        v19 = v25;
      v25 = v19;
      v20 = v18;
      if ( v8 << 16 < v18 << 16 )
        v20 = v8;
      v8 = v20;
    }
  }
  else
  {
    LOWORD(v8) = 0;
    LOWORD(v25) = 0;
    v9 = 0;
  }
  v21 = AKSC_div16(1, v27);
  v22 = AKSC_sqrt32((((v9 >> 6) & 1) + (v9 >> 7)) * (((v21 << 16 >> 19) & 1) + (v21 << 16 >> 20)));
  v23 = v22 << 16 >> 17;
  result = v22 << 16 >> 18;
  *a5 = (v23 & 1) + result;
  *a6 = v25 - v8;
  return result;
}

//----- (00004E64) --------------------------------------------------------
signed int __fastcall sub_4E64(int a1, int a2, int a3, int a4, _WORD *a5, _WORD *a6)
{
  int v6; // r4@1
  int v7; // r5@1
  signed int v8; // r0@1
  signed int v9; // r6@1
  char *v10; // r3@1
  __int16 v11; // r1@2
  int v13; // [sp+8h] [bp-60h]@1
  int v14; // [sp+Ch] [bp-5Ch]@1
  char v15; // [sp+1Ch] [bp-4Ch]@1
  __int16 v16; // [sp+2Eh] [bp-3Ah]@2
  int v17; // [sp+30h] [bp-38h]@4
  int v18; // [sp+38h] [bp-30h]@4
  char v19; // [sp+40h] [bp-28h]@6
  signed __int16 v20; // [sp+42h] [bp-26h]@6
  signed __int16 v21; // [sp+44h] [bp-24h]@6
  char v22; // [sp+48h] [bp-20h]@1

  v6 = a3;
  v7 = a4;
  v13 = a1;
  v14 = a2;
  v8 = AKSC_getCoeff(a1, a2, a4, (int)&v22);
  v9 = v8;
  v10 = &v15;
  do
  {
    *(_WORD *)v10 = *(_WORD *)v7;
    *((_WORD *)v10 + 1) = *(_WORD *)(v7 + 2);
    v11 = *(_WORD *)(v7 + 4);
    v7 += 6;
    *((_WORD *)v10 + 2) = v11;
    v10 += 6;
  }
  while ( (__int16 *)v10 != &v16 );
  if ( v8 != 4 )
  {
    *(_WORD *)v6 = 0;
    *(_WORD *)(v6 + 4) = 0;
    *(_WORD *)(v6 + 2) = 0;
    *a5 = 0;
    return 0;
  }
  if ( !(AKSC_cholDc((int)&v15, 3, (int)&v18, (int)&v17) & 0xFFFF) )
  {
    *(_WORD *)(v6 + 4) = 0;
    *(_WORD *)(v6 + 2) = 0;
    *(_WORD *)v6 = 0;
    *a5 = 0;
    return 0;
  }
  AKSC_cholSl((int)&v15, 3, (int)&v18, (int)&v17, (int)&v22, (int)&v19);
  *(_WORD *)v6 = *(_WORD *)&v19 >> 2;
  *(_WORD *)(v6 + 2) = v20 >> 2;
  *(_WORD *)(v6 + 4) = v21 >> 2;
  sub_4D50(v13, v14, v6, 4, a5, a6);
  return v9;
}

//----- (00004F18) --------------------------------------------------------
signed int __fastcall sub_4F18(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7)
{
  int v7; // r4@1
  signed int v8; // r3@5
  int v9; // r5@8
  signed int result; // r0@13
  int v11; // [sp+Ch] [bp-54h]@1
  int v12; // [sp+14h] [bp-4Ch]@1
  char v13; // [sp+18h] [bp-48h]@12
  char v14; // [sp+20h] [bp-40h]@5
  int v15; // [sp+28h] [bp-38h]@5
  char v16; // [sp+30h] [bp-30h]@5
  char v17; // [sp+38h] [bp-28h]@5
  __int16 v18; // [sp+3Ah] [bp-26h]@6
  __int16 v19; // [sp+3Ch] [bp-24h]@7
  unsigned __int16 v20[16]; // [sp+40h] [bp-20h]@8
  signed __int16 v21; // [sp+42h] [bp-1Eh]@9
  signed __int16 v22; // [sp+44h] [bp-1Ch]@10
  signed int v23; // [sp+46h] [bp-1Ah]@12

  v11 = a1;
  v7 = a3;
  v12 = a4;
  if ( a5 != 4
    || *(_WORD *)(a3 + 16) >= a6
    || *(_WORD *)(a3 + 14) <= a6
    || a7 << 11 >= *(_WORD *)(a3 + 18) * a6
    || (AKSC_vectorCalc(a2, *(_WORD *)(a3 + 2), (signed __int16 *)&v16, (signed __int16 *)&v15, (int)&v14, (int)&v17),
        v8 = *(_WORD *)(v7 + 10),
        *(signed __int16 *)&v17 >= v8)
    || v18 >= v8
    || v19 >= v8
    || (AKSC_vectorCalc(v11, *(_WORD *)v7, (signed __int16 *)&v16, (signed __int16 *)&v15, (int)&v14, (int)v20),
        v9 = *(_WORD *)(v7 + 6),
        v9 << 16 >= v20[0] << 16)
    || v21 <= (signed __int16)v9
    || v22 <= (signed __int16)v9
    || v21 + (signed __int16)v20[0] + v22 < *(_WORD *)(v7 + 8)
    || !(AKSC_fitOnPlane(v11, *(_WORD *)v7, v12, (int)&v13, &v23) << 16)
    || (result = 1, (signed __int16)v23 <= (signed int)*(_WORD *)(v7 + 12)) )
  {
    result = 0;
  }
  return result;
}

//----- (00005008) --------------------------------------------------------
signed int __fastcall sub_5008(_WORD *a1, _WORD *a2, _WORD *a3, int a4, int a5, __int16 *a6, _WORD *a7, __int16 a8)
{
  int v8; // r4@1
  int v9; // r5@1
  int v10; // r7@1
  signed int v11; // r3@5
  int v12; // r3@10
  int v13; // r2@13
  int v14; // r1@13
  int v15; // r12@13
  int v16; // r4@14
  int v17; // r3@18
  int v18; // r4@22
  int v19; // r6@22
  int v20; // r3@22
  int v21; // r7@23
  signed int result; // r0@28
  int v23; // r2@30
  signed int v24; // r4@30
  int v25; // r1@31
  int v26; // r3@35
  int v27; // [sp+10h] [bp-68h]@13
  signed int v28; // [sp+14h] [bp-64h]@13
  int v29; // [sp+18h] [bp-60h]@1
  char v30; // [sp+24h] [bp-54h]@22
  char v31; // [sp+38h] [bp-40h]@13
  char v32[8]; // [sp+40h] [bp-38h]@13
  char v33; // [sp+48h] [bp-30h]@13
  char v34; // [sp+50h] [bp-28h]@13
  int v35; // [sp+58h] [bp-20h]@2
  __int16 v36; // [sp+5Ch] [bp-1Ch]@2
  __int16 v37; // [sp+5Eh] [bp-1Ah]@22

  v29 = a4;
  v8 = (int)a3;
  v9 = (int)a2;
  v10 = (int)a1;
  if ( (signed int)*a2 <= 0 )
    return 0;
  v36 = 0;
  v35 = 0;
  *a7 = 0;
  if ( a8 )
  {
    if ( a8 == 1 )
      goto LABEL_10;
  }
  else
  {
    LOWORD(v35) = AKSC_abs16((signed __int16)(*a3 - *a1));
    HIWORD(v35) = AKSC_abs16((signed __int16)(*(_WORD *)(v8 + 2) - *(_WORD *)(v10 + 2)));
    v36 = AKSC_abs16((signed __int16)(*(_WORD *)(v8 + 4) - *(_WORD *)(v10 + 4)));
  }
  v11 = *(_WORD *)(v9 + 4);
  if ( (signed __int16)v35 < v11 || SHIWORD(v35) < v11 || v36 < v11 )
    return 0;
  if ( !a8 )
  {
    AKSC_buffer(v10, *(_WORD *)v9, 1, v8);
    *a7 = 1;
  }
LABEL_10:
  v12 = v8 + 6 * (*(_WORD *)v9 - 1);
  if ( *(_WORD *)v12 == 0x7FFF && *(_WORD *)(v12 + 2) == 0x7FFF && *(_WORD *)(v12 + 4) == 0x7FFF )
    return 0;
  AKSC_vectorCalc(v8, *(_WORD *)v9, (signed __int16 *)&v34, (signed __int16 *)&v33, (int)v32, (int)&v31);
  v13 = v8;
  v27 = v8;
  v14 = 0;
  v28 = *(_WORD *)v9;
  v15 = v8;
  while ( (signed __int16)v14 < v28 )
  {
    v17 = 0;
    do
    {
      v16 = *(_WORD *)(v13 + v17) - *(_WORD *)&v32[v17];
      if ( v16 >= -32768 )
      {
        if ( v16 > 0x7FFF )
          LOWORD(v16) = 0x7FFF;
      }
      else
      {
        LOWORD(v16) = -32768;
      }
      *(_WORD *)(v13 + v17) = v16;
      v17 += 2;
    }
    while ( v17 != 6 );
    v14 = (v14 + 1) & 0xFFFF;
    v13 += 6;
  }
  v18 = v15;
  v19 = sub_4E64(v15, *(_WORD *)v9, a5, (int)&v30, a6, &v37);
  v20 = 0;
  do
  {
    v21 = *(_WORD *)&v32[v20] + *(_WORD *)(a5 + v20);
    if ( v21 >= -32768 )
    {
      if ( v21 > 0x7FFF )
        LOWORD(v21) = 0x7FFF;
    }
    else
    {
      LOWORD(v21) = -32768;
    }
    *(_WORD *)(a5 + v20) = v21;
    v20 += 2;
  }
  while ( v20 != 6 );
  AKSC_buffer(a5, *(_WORD *)(v9 + 2), 1, v29);
  result = 0;
  if ( v19 )
    result = sub_4F18(v18, v29, v9, (int)&v30, v19, *a6, v37);
  v23 = 0;
  v24 = *(_WORD *)v9;
  while ( (signed __int16)v23 < v24 )
  {
    v26 = 0;
    do
    {
      v25 = *(_WORD *)&v32[v26] + *(_WORD *)(v27 + v26);
      if ( v25 >= -32768 )
      {
        if ( v25 > 0x7FFF )
          LOWORD(v25) = 0x7FFF;
      }
      else
      {
        LOWORD(v25) = -32768;
      }
      *(_WORD *)(v27 + v26) = v25;
      v26 += 2;
    }
    while ( v26 != 6 );
    v23 = (v23 + 1) & 0xFFFF;
    v27 += 6;
  }
  return result;
}
// 5008: using guessed type char var_38[8];

//----- (00005218) --------------------------------------------------------
int __fastcall zzAKSC_HDOEProcessS3(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9, _DWORD *a10)
{
  int v10; // r4@1
  int v11; // r5@1
  int v12; // r6@1
  int v13; // r7@1
  int v14; // r5@2
  unsigned int v15; // r3@3
  int v16; // r1@8
  __int16 v17; // r0@8
  int v18; // r6@9
  char *v19; // r3@9
  int v20; // r6@11
  char *v21; // r3@12
  int v22; // r0@12
  int v23; // r1@12
  int v24; // r7@12
  int v25; // r1@12
  int v26; // r7@12
  int v27; // r1@15
  signed int v28; // r0@16
  int v29; // r1@19
  signed int v30; // r0@20
  char *v31; // r6@24
  __int16 v32; // r2@28
  signed int v33; // r0@28
  signed __int16 v34; // r2@28
  int v35; // r1@30
  int v36; // r3@31
  int v37; // r1@34
  int v38; // r0@34
  int v39; // r3@34
  int v40; // r2@34
  int v41; // r7@34
  int v42; // r12@34
  int v43; // r4@35
  int v44; // r0@38
  int v45; // r7@38
  int v47; // [sp+14h] [bp-17Ch]@34
  __int16 v48; // [sp+24h] [bp-16Ch]@11
  signed int v49; // [sp+24h] [bp-16Ch]@34
  int v50; // [sp+28h] [bp-168h]@7
  __int16 v51; // [sp+2Ch] [bp-164h]@11
  __int16 v52; // [sp+2Ch] [bp-164h]@34
  int v53; // [sp+30h] [bp-160h]@7
  _WORD *v54; // [sp+34h] [bp-15Ch]@7
  int v55; // [sp+38h] [bp-158h]@7
  int v56; // [sp+3Ch] [bp-154h]@7
  __int16 *v57; // [sp+40h] [bp-150h]@7
  int v58; // [sp+44h] [bp-14Ch]@7
  __int16 *v59; // [sp+48h] [bp-148h]@7
  int v60; // [sp+4Ch] [bp-144h]@7
  int v61; // [sp+50h] [bp-140h]@7
  int v62; // [sp+54h] [bp-13Ch]@7
  char dest[168]; // [sp+58h] [bp-138h]@1
  char v64[84]; // [sp+100h] [bp-90h]@1
  int v65; // [sp+154h] [bp-3Ch]@12
  int v66; // [sp+158h] [bp-38h]@12
  int v67; // [sp+15Ch] [bp-34h]@12
  int v68; // [sp+160h] [bp-30h]@12
  int v69; // [sp+164h] [bp-2Ch]@12
  int v70; // [sp+168h] [bp-28h]@12
  int v71; // [sp+16Ch] [bp-24h]@12
  __int16 v72; // [sp+170h] [bp-20h]@7
  __int16 v73; // [sp+172h] [bp-1Eh]@7
  __int16 v74; // [sp+174h] [bp-1Ch]@7
  __int16 v75; // [sp+176h] [bp-1Ah]@14

  v10 = a4;
  v11 = a1;
  v12 = a2;
  v13 = a3;
  memcpy(dest, &unk_7D68, 0xA8u);
  memcpy(v64, &unk_7E10, 0x54u);
  if ( (signed __int16)sub_4984(v11, v12, v13) == -32768 )
  {
    LOWORD(v14) = -32768;
  }
  else
  {
    v15 = (a6 - 1) & 0xFFFF;
    if ( v15 > 0x1F
      || (unsigned int)*(_WORD *)(v10 + 394) > 1
      || (unsigned int)*(_WORD *)(v10 + 388) > 0x10
      || (unsigned int)*(_WORD *)(v10 + 390) > 2 )
    {
      LOWORD(v14) = 0;
    }
    else
    {
      v74 = 0;
      v73 = 0;
      v72 = 0;
      v60 = v10 + 400;
      v54 = (_WORD *)(v10 + 4);
      v57 = (__int16 *)(v10 + 392);
      v59 = (__int16 *)(v10 + 496);
      v58 = v10 + 196;
      v55 = -6 * v15 - 6;
      v61 = -((a7 - __PAIR__((unsigned int)(a7 - 1), 1)) >> 32);
      v56 = v10 + 292;
      v53 = -((a8 - __PAIR__((unsigned int)(a8 - 1), 1)) >> 32);
      v50 = 0;
      v62 = a5 + 6 * (signed __int16)(a6 - 1);
      v14 = 0;
      do
      {
        v16 = *(_WORD *)(v10 + 394);
        v17 = *(_WORD *)(v10 + 390);
        if ( *(_DWORD *)v10 )
        {
          v18 = 28 * v17;
          v19 = *(char **)((v16 << 16 >> 14) + *(_DWORD *)v10);
        }
        else
        {
          v18 = 28 * v17 + 84 * (signed __int16)v16;
          v19 = dest;
        }
        v20 = (int)&v19[v18];
        v48 = *(_WORD *)v20;
        v51 = *(_WORD *)(v20 + 4);
        if ( *(_DWORD *)(v10 + 396) )
        {
          memcpy(
            &v65,
            (const void *)(*(_DWORD *)(((v16 & v61) << 16 >> 14) + *(_DWORD *)(v10 + 396))
                         + 28 * (signed __int16)(v17 & v53)),
            0x1Cu);
        }
        else
        {
          v21 = &v64[84 * (signed __int16)(v16 & v61)] + 28 * (signed __int16)(v17 & v53);
          v22 = *(_DWORD *)v21;
          v23 = *((_DWORD *)v21 + 1);
          v24 = *((_DWORD *)v21 + 2);
          v21 += 12;
          v65 = v22;
          v66 = v23;
          v67 = v24;
          v25 = *((_DWORD *)v21 + 1);
          v26 = *((_DWORD *)v21 + 2);
          v68 = *(_DWORD *)v21;
          v69 = v25;
          v70 = v26;
          v71 = *((_DWORD *)v21 + 3);
        }
        LOWORD(v65) = v48;
        LOWORD(v66) = v51;
        if ( sub_5008((_WORD *)(v62 + v50), &v65, v54, v60, (int)&v72, v59, &v75, 0) == 1 )
        {
          v27 = *(_WORD *)(v10 + 394);
          if ( v27 << 16 <= 0 )
          {
            v28 = *(_WORD *)(v20 + 24);
            if ( v28 >= 0 && *(_WORD *)(v10 + 496) >= v28 )
              *(_WORD *)(v10 + 394) = v27 + 1;
          }
          v29 = *(_WORD *)(v10 + 394);
          if ( v29 << 16 > 0 )
          {
            v30 = *(_WORD *)(v20 + 26);
            if ( v30 >= 0 && *(_WORD *)(v10 + 496) <= v30 )
              *(_WORD *)(v10 + 394) = v29 - 1;
          }
        }
        if ( *(_DWORD *)v10 )
          v31 = (char *)(*(_DWORD *)((*(_WORD *)(v10 + 394) << 16 >> 14) + *(_DWORD *)v10) + 28 * *(_WORD *)(v10 + 390));
        else
          v31 = &dest[84 * *(_WORD *)(v10 + 394)] + 28 * *(_WORD *)(v10 + 390);
        if ( v75 == 1 && sub_5008((_WORD *)(v62 + v50), v31, v54, v58, (int)&v72, v57, &v75, 1) == 1 )
        {
          v32 = *(_WORD *)(v10 + 388);
          v33 = v32;
          v14 = (v14 + 1) & 0xFFFF;
          v34 = v32 + 1;
          if ( v33 > 15 )
            v34 = 16;
          *(_WORD *)(v10 + 388) = v34;
          AKSC_buffer((int)&v72, 16, 1, v56);
          v35 = *(_WORD *)(v10 + 388);
          if ( v35 > 1 && (v36 = *((_WORD *)v31 + 11), v36 > 1) )
          {
            if ( v35 >= v36 )
            {
              v52 = AKSC_div16(1, v36);
              v37 = 0;
              v44 = v10 + 292;
              v39 = 0;
              v40 = 0;
              v45 = 0;
              v47 = v14;
              v42 = v10;
              while ( (signed __int16)v45 < (signed int)*((_WORD *)v31 + 11) )
              {
                v37 += *(_WORD *)v44;
                v40 += *(_WORD *)(v44 + 2);
                v45 = (v45 + 1) & 0xFFFF;
                v39 += *(_WORD *)(v44 + 4);
                v44 += 6;
              }
            }
            else
            {
              v52 = AKSC_div16(1, v35);
              v37 = 0;
              v38 = v10 + 292;
              v49 = *(_WORD *)(v10 + 388);
              v39 = 0;
              v40 = 0;
              v47 = v14;
              v41 = 0;
              v42 = v10;
              while ( (signed __int16)v41 < v49 )
              {
                v37 += *(_WORD *)v38;
                v40 += *(_WORD *)(v38 + 2);
                v43 = *(_WORD *)(v38 + 4);
                v38 += 6;
                v39 += v43;
                v41 = (v41 + 1) & 0xFFFF;
              }
            }
            v14 = v47;
            v10 = v42;
            *(_WORD *)a9 = v37 * v52 >> 15;
            *(_WORD *)(a9 + 2) = v40 * v52 >> 15;
            *(_WORD *)(a9 + 4) = v39 * v52 >> 15;
          }
          else
          {
            *(_WORD *)a9 = v72;
            *(_WORD *)(a9 + 2) = v73;
            *(_WORD *)(a9 + 4) = v74;
          }
          if ( *(_WORD *)(v10 + 388) >= (signed int)*((_WORD *)v31 + 10) && (signed int)*(_WORD *)(v10 + 390) <= 1 )
          {
            *(_WORD *)(v10 + 388) = 0;
            ++*(_WORD *)(v10 + 390);
          }
        }
        v50 -= 6;
      }
      while ( v50 != v55 );
      if ( *(_WORD *)(v10 + 388) )
        *a10 = *(_WORD *)(v10 + 390) + 1;
      else
        *a10 = *(_WORD *)(v10 + 390);
    }
  }
  return (signed __int16)v14;
}
// 5218: using guessed type char dest[168];
// 5218: using guessed type char var_90[84];

//----- (00005640) --------------------------------------------------------
signed int __fastcall AKSC_InitHFlucCheck(int a1, int a2, int a3)
{
  signed int result; // r0@2

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_WORD *)(a1 + 2) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  if ( a3 >= 0 )
  {
    *(_WORD *)(a1 + 6) = a3;
    result = 1;
  }
  else
  {
    *(_WORD *)(a1 + 6) = 0;
    result = 0;
  }
  return result;
}

//----- (00005660) --------------------------------------------------------
signed int __fastcall AKSC_HFlucCheck(int a1, int a2)
{
  int v2; // r3@1
  signed int v3; // r5@1
  signed int v4; // r2@2
  signed int v5; // r4@3
  signed int v6; // r2@3

  v2 = *(_WORD *)(a1 + 6);
  v3 = *(_WORD *)a2 - *(_WORD *)a1;
  if ( ((v3 + (v3 >> 31)) ^ (v3 >> 31)) >= v2
    || (v4 = *(_WORD *)(a2 + 2) - *(_WORD *)(a1 + 2), ((v4 + (v4 >> 31)) ^ (v4 >> 31)) >= v2)
    || (v5 = *(_WORD *)(a2 + 4) - *(_WORD *)(a1 + 4), v6 = 0, ((v5 + (v5 >> 31)) ^ (v5 >> 31)) >= v2) )
  {
    v6 = 1;
    *(_WORD *)a1 = *(_WORD *)a2;
    *(_WORD *)(a1 + 2) = *(_WORD *)(a2 + 2);
    *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  }
  return v6;
}

//----- (000056B8) --------------------------------------------------------
_DWORD *__fastcall AKSC_TransByHbase(_DWORD *result, _DWORD *a2, int a3, int *a4, _WORD *a5)
{
  int v5; // r4@1
  signed __int16 v6; // r5@3
  int v7; // [sp+4h] [bp-1Ch]@2

  v5 = 0;
  *a5 = 0;
  do
  {
    v7 = *result + *a4 - *a2;
    *a4 = v7;
    if ( v7 < -32768 )
    {
      v6 = -32768;
LABEL_6:
      *(_WORD *)(a3 + v5) = v6;
      *a5 = 1;
      goto LABEL_8;
    }
    if ( v7 > 0x7FFF )
    {
      v6 = 0x7FFF;
      goto LABEL_6;
    }
    *(_WORD *)(a3 + v5) = v7;
LABEL_8:
    v5 += 2;
    ++a4;
    ++result;
    ++a2;
  }
  while ( v5 != 6 );
  return result;
}

//----- (00005710) --------------------------------------------------------
signed int __fastcall sub_5710(int a1, int a2, _WORD *a3, int a4, _WORD *a5)
{
  int v5; // ST10_4@2
  int v6; // r7@2
  int *v7; // r5@2
  int v8; // r4@2
  int *v9; // r4@2
  int *v10; // r6@2
  int v11; // ST1C_4@7
  int v12; // ST0C_4@7
  int v13; // r12@7
  _WORD *v14; // r2@7
  int v15; // r12@7
  int v16; // r6@8
  int v17; // r1@9
  _WORD *v18; // r3@9
  int v19; // r1@12
  int v21; // [sp+14h] [bp-34h]@2
  int v22; // [sp+18h] [bp-30h]@2
  int v23; // [sp+24h] [bp-24h]@2
  int v24; // [sp+28h] [bp-20h]@2
  int v25; // [sp+2Ch] [bp-1Ch]@2
  int v26; // [sp+30h] [bp-18h]@6

  if ( (unsigned __int16)a2 <= 2u )
  {
    v22 = a1 + 6;
    v5 = *(_WORD *)(2 * a2 + a1);
    v6 = *(_WORD *)(2 * a2 + a1 + 6);
    v7 = &v23;
    v23 = v5 - v6;
    v21 = a1 + 12;
    v8 = *(_WORD *)(2 * a2 + a1 + 12);
    v24 = v6 - v8;
    v25 = v8 - v5;
    v9 = &v23;
    v10 = &v23;
    while ( 1 )
    {
      if ( *v10 < 0 )
        *v10 = -*v10;
      if ( *v10 > 0x7FFF )
        break;
      *a3 = *v10;
      ++v10;
      ++a3;
      if ( v10 == &v26 )
      {
        v11 = *(_WORD *)(2 * a2 + a1);
        v12 = *(_WORD *)(2 * a2 + v22);
        v23 = v11 + v12;
        v13 = *(_WORD *)(2 * a2 + v21);
        v24 = v12 + v13;
        v25 = v11 + v13;
        v14 = (_WORD *)a4;
        v15 = a4;
        do
        {
          v16 = (*v7 & 1) + (*v7 >> 1);
          *v7 = v16;
          ++v7;
          *v14 = v16;
          ++v14;
        }
        while ( v7 != &v26 );
        v17 = 2 * a2;
        v23 = *(_WORD *)(v17 + v21) - *(_WORD *)a4;
        v24 = *(_WORD *)(v17 + a1) - *(_WORD *)(a4 + 2);
        v18 = a5;
        v25 = *(_WORD *)(v17 + v22) - *(_WORD *)(v15 + 4);
        do
        {
          if ( *v9 < 0 )
            *v9 = -*v9;
          v19 = *v9;
          ++v9;
          *v18 = v19;
          ++v18;
        }
        while ( v9 != &v26 );
        return 1;
      }
    }
  }
  return 0;
}

//----- (00005818) --------------------------------------------------------
signed int __fastcall AKSC_HOffsetCal(int a1, _WORD *a2)
{
  _WORD *v2; // r5@1
  int v3; // r6@1
  signed int result; // r0@2
  unsigned __int16 v5; // r2@3
  signed int v6; // r3@3
  __int16 v7; // r2@7
  int v8; // r3@7
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+10h] [bp-8h]@2
  int v11; // [sp+18h] [bp+0h]@2
  unsigned __int16 v12[6]; // [sp+20h] [bp+8h]@2
  unsigned __int16 v13; // [sp+22h] [bp+Ah]@3
  signed __int16 v14; // [sp+24h] [bp+Ch]@5

  v9 = a1;
  v2 = a2;
  v3 = 0;
  while ( 1 )
  {
    result = sub_5710(v9, (signed __int16)v3, v12, (int)&v11, &v10) << 16;
    if ( !result )
      break;
    v5 = v12[0];
    v6 = 0;
    if ( v12[0] << 16 < v13 << 16 )
    {
      v5 = v13;
      v6 = 1;
    }
    if ( v14 > (signed __int16)v5 )
      v6 = 2;
    v7 = *((_WORD *)&v11 + v6);
    v8 = (signed __int16)(v3 + 1);
    *v2 = v7;
    v3 = (v3 + 1) & 0xFFFF;
    ++v2;
    if ( v8 == 3 )
      return 1;
  }
  return result;
}

//----- (00005880) --------------------------------------------------------
unsigned int __fastcall AKSC_sqrt16(int a1)
{
  unsigned int v1; // r2@1
  unsigned int v2; // r0@2
  int v3; // r1@2
  unsigned int v4; // r3@2
  unsigned int v5; // r4@3
  unsigned int v6; // r3@3
  unsigned int v7; // r4@3

  v1 = 0;
  if ( a1 >= 0 )
  {
    v2 = 2 * a1 & 0xFFFF;
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = v1 << 17;
      v6 = ((4 * v4 & 0xFFFF) + (v2 >> 14)) << 16;
      v2 = 4 * v2 & 0xFFFF;
      v1 = 2 * v1 & 0xFFFF;
      v4 = v6 >> 16;
      v7 = (v5 + 0x10000) >> 16;
      if ( v7 <= v4 )
      {
        v4 = (v4 - v7) & 0xFFFF;
        v1 = (v7 + 1) & 0xFFFF;
      }
      v3 = (v3 + 1) & 0xFFFF;
    }
    while ( v3 != 8 );
    v1 = (v1 + 2) << 16 >> 18;
  }
  return v1;
}

//----- (000058D0) --------------------------------------------------------
int __fastcall AKSC_sqrt32(unsigned int a1)
{
  unsigned int v1; // r3@1
  int v2; // r1@2
  unsigned int v3; // r2@2

  v1 = 0;
  if ( (a1 & 0x80000000) == 0 )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      v1 *= 2;
      v3 = (a1 >> 30) + 4 * v3;
      a1 *= 4;
      if ( v1 + 1 <= v3 )
      {
        v3 -= v1 + 1;
        v1 += 2;
      }
      v2 = (v2 + 1) & 0xFFFF;
    }
    while ( v2 != 16 );
    v1 = v1 << 15 >> 16;
  }
  return (signed __int16)v1;
}

//----- (00005904) --------------------------------------------------------
int __fastcall AKSC_angRng(int result, int a2)
{
  unsigned int v2; // r3@2
  bool v3; // cf@5
  unsigned int v4; // r3@7

  if ( result < 0 )
  {
    v4 = 16;
    do
    {
      if ( result < -(23040 << v4) )
        result += 23040 << v4;
      v3 = v4-- >= 1;
    }
    while ( v3 );
    result += 23040;
  }
  else
  {
    v2 = 16;
    do
    {
      if ( result >= 23040 << v2 )
        result -= 23040 << v2;
      v3 = v2-- >= 1;
    }
    while ( v3 );
  }
  if ( a2 == 1 && result > 11519 )
    LOWORD(result) = result - 23040;
  return (signed __int16)result;
}

//----- (00005958) --------------------------------------------------------
unsigned int __fastcall AKSC_sin(int a1)
{
  unsigned __int16 v1; // r0@1
  int v2; // r2@1
  signed __int16 v3; // r4@1
  unsigned int v4; // r3@5
  int v5; // r0@6
  unsigned int v6; // r0@8
  unsigned int result; // r0@11

  v1 = AKSC_angRng(a1, 0);
  v2 = v1;
  v3 = 1;
  if ( (signed __int16)v1 > 11520 )
  {
    v2 = (v1 - 11520) & 0xFFFF;
    v3 = -1;
  }
  if ( (signed __int16)v2 > 5760 )
    v2 = (11520 - v2) & 0xFFFF;
  v2 = (signed __int16)v2;
  v4 = (unsigned int)(((signed __int16)v2 + 31) << 10) >> 16;
  if ( v4 )
  {
    if ( (signed __int16)((unsigned int)((signed __int16)v2 + 31) >> 6) <= 89 )
    {
      v6 = (word_7E64[(signed __int16)((unsigned int)((signed __int16)v2 + 31) >> 6)]
          * (-64 * (signed __int16)((unsigned int)((signed __int16)v2 + 31) >> 6) + 32 + v2)
          + word_7E64[(signed __int16)((unsigned int)((signed __int16)v2 + 31) >> 6) - 1]
          * (32 * (2 * (signed __int16)((unsigned int)((signed __int16)v2 + 31) >> 6) + 1) - v2)) << 10;
      goto LABEL_11;
    }
    v5 = 0x7FFF * (-64 * (signed __int16)((unsigned int)((signed __int16)v2 + 31) >> 6) + 32 + v2)
       + 32766 * (((signed __int16)((unsigned int)((signed __int16)v2 + 31) >> 6) << 6) - v2);
  }
  else
  {
    v5 = 286 * v2;
  }
  v6 = v5 << 11;
LABEL_11:
  result = v6 >> 16;
  if ( v3 == -1 )
    result = 0xFFFF * result & 0xFFFF;
  return (signed __int16)result;
}

//----- (00005A1C) --------------------------------------------------------
int __fastcall AKSC_cos(signed int a1)
{
  signed __int16 v1; // r3@2

  if ( a1 <= 17279 )
    v1 = 5760;
  else
    v1 = -17280;
  return (signed __int16)AKSC_sin((signed __int16)(a1 + v1));
}

//----- (00005A48) --------------------------------------------------------
int __fastcall sub_5A48(int a1)
{
  unsigned int v1; // r0@2
  int v2; // r0@4
  int v3; // r3@4
  int result; // r0@6
  int v5; // r4@7
  __int16 *v6; // r3@7
  __int16 v7; // r2@9
  int v8; // r2@11

  if ( a1 <= 284 )
  {
    v1 = (AKSC_div16(a1, 285) << 16 >> 10) + 0x8000;
LABEL_6:
    return (signed __int16)(v1 >> 16);
  }
  if ( a1 > (signed int)&unk_7DC7 )
  {
    v2 = ((signed __int16)AKSC_div16((signed __int16)(a1 - 32200), 567) + 512) >> 10;
    v3 = 2848;
LABEL_5:
    v1 = (v2 + v3) << 16;
    goto LABEL_6;
  }
  v5 = 1;
  v6 = &word_7F18;
  do
  {
    if ( *v6 <= a1 )
    {
      v7 = v6[1];
      if ( a1 < v7 )
      {
        v3 = ((signed __int16)AKSC_div16((signed __int16)(a1 - *v6), (signed __int16)(v7 - *v6)) + 256) >> 9;
        v2 = (v5 << 6) - 32;
        goto LABEL_5;
      }
    }
    v8 = (signed __int16)(v5 + 1);
    ++v6;
    v5 = (v5 + 1) & 0xFFFF;
  }
  while ( v8 != 45 );
  LOWORD(result) = 0;
  return (signed __int16)result;
}
// 7F18: using guessed type __int16 word_7F18;

//----- (00005AF8) --------------------------------------------------------
int __fastcall AKSC_atan2(int a1, int a2)
{
  signed int v2; // r5@2
  signed int v3; // r4@5
  unsigned int v4; // r3@9
  __int16 v5; // r0@10
  __int16 v6; // r0@13
  __int16 v7; // r0@16
  __int16 v8; // r0@19
  __int16 v9; // r0@22
  __int16 v10; // r0@25
  __int16 v11; // r0@28
  __int16 v12; // r0@31
  char v14; // [sp+6h] [bp-12h]@10

  if ( a1 == -32768 )
    v2 = 32769;
  else
    v2 = (unsigned __int16)a1;
  if ( a2 == -32768 )
    v3 = 32769;
  else
    v3 = (unsigned __int16)a2;
  if ( (signed __int16)v2 >= (signed __int16)v3 && (signed __int16)v3 > 0 )
  {
    v5 = AKSC_div16f((signed __int16)v3, (signed __int16)v2, &v14);
    v4 = sub_5A48(v5 >> v14) & 0xFFFF;
  }
  else
  {
    LOWORD(v4) = -1;
  }
  if ( (signed __int16)v2 < (signed __int16)v3 && (signed __int16)v2 >= 0 )
  {
    v6 = AKSC_div16f((signed __int16)v2, (signed __int16)v3, &v14);
    v4 = (5760 - (unsigned __int16)sub_5A48(v6 >> v14)) & 0xFFFF;
LABEL_18:
    if ( -(signed __int16)v2 > (signed __int16)v3 )
    {
      v8 = AKSC_div16f((signed __int16)v3, -(signed __int16)v2, &v14);
      v4 = (11520 - (unsigned __int16)sub_5A48(v8 >> v14)) & 0xFFFF;
    }
    goto LABEL_20;
  }
  if ( (signed __int16)v2 < 0 && -(signed __int16)v2 <= (signed __int16)v3 )
  {
    v7 = AKSC_div16f(-(signed __int16)v2, (signed __int16)v3, &v14);
    v4 = (unsigned int)((sub_5A48(v7 >> v14) << 16) + 377487360) >> 16;
  }
  if ( !(v3 & 0x8000) )
    goto LABEL_18;
LABEL_20:
  if ( v3 << 16 >= v2 << 16 && (signed __int16)v3 < 0 )
  {
    v9 = AKSC_div16f(-(signed __int16)v3, -(signed __int16)v2, &v14);
    v4 = (unsigned int)((sub_5A48(v9 >> v14) << 16) + 754974720) >> 16;
  }
  if ( v3 << 16 < v2 << 16 && (signed __int16)v2 <= 0 )
  {
    v10 = AKSC_div16f(-(signed __int16)v2, -(signed __int16)v3, &v14);
    v4 = (17280 - (unsigned __int16)sub_5A48(v10 >> v14)) & 0xFFFF;
LABEL_30:
    if ( -(signed __int16)v2 < (signed __int16)v3 )
    {
      v12 = AKSC_div16f(-(signed __int16)v3, (signed __int16)v2, &v14);
      v4 = (23040 - (sub_5A48(v12 >> v14) & 0xFFFF)) & 0xFFFF;
    }
    return (signed __int16)(v4 & -(signed __int16)(v4
                                                 - 23040
                                                 - (v4
                                                  - 23041
                                                  + ((unsigned int)((signed __int16)v4 - 23040) < 1))));
  }
  if ( (signed __int16)v2 > 0 && -(signed __int16)v2 >= (signed __int16)v3 )
  {
    v11 = AKSC_div16f((signed __int16)v2, -(signed __int16)v3, &v14);
    v4 = (unsigned int)((sub_5A48(v11 >> v14) << 16) + 1132462080) >> 16;
  }
  if ( v3 << 16 <= 0 )
    goto LABEL_30;
  return (signed __int16)(v4 & -(signed __int16)(v4
                                               - 23040
                                               - (v4
                                                - 23041
                                                + ((unsigned int)((signed __int16)v4 - 23040) < 1))));
}

//----- (00005D1C) --------------------------------------------------------
int __fastcall AKSC_invSqrt(signed int a1, _WORD *a2)
{
  signed int v2; // r4@1
  _WORD *v3; // r5@1
  int result; // r0@2
  unsigned __int16 v5; // r0@3
  signed int v6; // r4@3
  int v7; // r1@5

  v2 = a1;
  v3 = a2;
  if ( a1 > 0 )
  {
    v5 = AKSC_norm32(a1);
    v6 = v2 << v5;
    if ( !((30 - v5) & 1) )
      v6 >>= 1;
    *v3 = ((30 - v5) << 16 >> 17) + 1;
    v7 = *(_WORD *)&aEgiqmQiuvy[2 * ((v6 >> 25) - 16) + 16];
    result = (signed int)(2
                        * ((v7 << 16 >> 1)
                         - ((unsigned int)(v6 << 7) >> 17)
                         * (signed __int16)(v7 - *(_WORD *)&aEgiqmQiuvy[2 * ((v6 >> 25) - 15) + 16]))) >> (((30 - v5) << 16 >> 17) + 1);
  }
  else
  {
    *a2 = 0;
    result = 0x40000000;
  }
  return result;
}

//----- (00005D90) --------------------------------------------------------
int __fastcall AKSC_buffer(int result, signed int a2, signed int a3, int a4)
{
  int v4; // r6@3
  int v5; // r5@3
  int v6; // r7@3
  int v7; // r4@4
  int v8; // r1@4
  int v9; // r5@6
  int v10; // r4@6
  int v11; // r6@6
  int v12; // r1@7
  __int16 v13; // r7@7
  _WORD *v14; // r0@7
  int v15; // [sp+4h] [bp-1Ch]@1

  v15 = result;
  if ( a2 >= a3 && a3 > 0 )
  {
    v4 = (a2 - 1) & 0xFFFF;
    v5 = 0;
    v6 = 6 * (signed __int16)(a2 - 1);
    while ( 1 )
    {
      result = v4 << 16;
      if ( (signed __int16)v4 < a3 )
        break;
      v7 = a4 + v6 + -6 * a3 + v5;
      v8 = a4 + v6 + v5;
      *(_WORD *)v8 = *(_WORD *)v7;
      v7 += 2;
      v8 += 2;
      *(_WORD *)v8 = *(_WORD *)v7;
      v4 = (v4 - 1) & 0xFFFF;
      *(_WORD *)(v8 + 2) = *(_WORD *)(v7 + 2);
      v5 -= 6;
    }
    v9 = (a3 - 1) & 0xFFFF;
    v10 = 0;
    v11 = 6 * (signed __int16)(a3 - 1);
    while ( !(v9 & 0x8000) )
    {
      v12 = v15 + v11 + v10;
      v13 = *(_WORD *)v12;
      v14 = (_WORD *)(a4 + v11 + v10);
      v12 += 2;
      *v14 = v13;
      result = (int)(v14 + 1);
      *(_WORD *)result = *(_WORD *)v12;
      v9 = (v9 - 1) & 0xFFFF;
      v10 -= 6;
      *(_WORD *)(result + 2) = *(_WORD *)(v12 + 2);
    }
  }
  return result;
}

//----- (00005E24) --------------------------------------------------------
int __fastcall AKSC_vectorCalc(int result, signed int a2, signed __int16 *a3, signed __int16 *a4, int a5, int a6)
{
  int v6; // r5@1
  int v7; // r1@1
  int v8; // r12@2
  signed __int16 *v9; // r4@2
  int v10; // r6@2
  int v11; // r4@9
  int v12; // r4@12
  signed int v13; // [sp+14h] [bp-24h]@8
  signed int v14; // [sp+18h] [bp-20h]@1

  v14 = a2;
  v6 = 0;
  v7 = 0;
  do
  {
    v8 = v7;
    *a4 = *(_WORD *)(result + v7);
    *a3 = *(_WORD *)(result + v7);
    v9 = (signed __int16 *)(result + 6 + 2 * v6);
    v10 = 1;
    while ( 1 )
    {
      v13 = *a4;
      if ( (signed __int16)v10 >= v14 )
        break;
      if ( v13 > *v9 )
        *a4 = *v9;
      if ( *a3 < *v9 )
        *a3 = *v9;
      v10 = (v10 + 1) & 0xFFFF;
      v9 += 3;
    }
    v11 = ((v13 >> 1) + (*a3 >> 1)) & 0xFFFF;
    *(_WORD *)(a5 + v7) = (*a4 >> 1) + (*a3 >> 1);
    if ( *a3 & 1 || *a4 & 1 )
      *(_WORD *)(a5 + v7) = v11 + 1;
    v12 = ((unsigned __int16)*a3 - (unsigned __int16)*a4) << 16;
    *(_WORD *)(a6 + v7) = *a3 - *a4;
    if ( v12 < 0 )
      *(_WORD *)(a6 + v7) = 0x7FFF;
    v7 += 2;
    ++v6;
    ++a4;
    ++a3;
  }
  while ( v8 != 4 );
  return result;
}

//----- (00005EF0) --------------------------------------------------------
signed int AKSC_GetVersion_Major()
{
  return 1;
}

//----- (00005EF4) --------------------------------------------------------
int AKSC_GetVersion_Variation()
{
  return 0;
}

//----- (00005EF8) --------------------------------------------------------
signed int AKSC_GetVersion_DateCode()
{
  return 809;
}

//----- (00005F08) --------------------------------------------------------
int __fastcall sub_5F08(int result, unsigned int a2)
{
  char v2; // nf@0
  int v3; // r12@1
  unsigned int v4; // r3@4
  char v5; // r0@8
  unsigned int v6; // r1@8
  unsigned int v7; // r2@8
  bool v8; // zf@17

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      result = -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        result = (v3 >> 31) | 1;
    }
    else if ( a2 & (a2 - 1) )
    {
      v5 = __clz(a2) - __clz(v4);
      v6 = a2 << v5;
      v7 = 1 << v5;
      result = 0;
      while ( 1 )
      {
        if ( v4 >= v6 )
        {
          v4 -= v6;
          result |= v7;
        }
        if ( v4 >= v6 >> 1 )
        {
          v4 -= v6 >> 1;
          result |= v7 >> 1;
        }
        if ( v4 >= v6 >> 2 )
        {
          v4 -= v6 >> 2;
          result |= v7 >> 2;
        }
        if ( v4 >= v6 >> 3 )
        {
          v4 -= v6 >> 3;
          result |= v7 >> 3;
        }
        v8 = v4 == 0;
        if ( v4 )
        {
          v7 >>= 4;
          v8 = v7 == 0;
        }
        if ( v8 )
          break;
        v6 >>= 4;
      }
      if ( v3 < 0 )
        result = -result;
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        result = -result;
    }
  }
  return result;
}

//----- (00005FFC) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (0000600C) --------------------------------------------------------
int __fastcall sub_600C(char *a1)
{
  int v1; // r3@1
  unsigned int v2; // r3@2

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 & 0x40000000 )
    v2 = v1 | 0x80000000;
  else
    v2 = v1 & 0x7FFFFFFF;
  return (int)&a1[v2];
}

//----- (00006024) --------------------------------------------------------
int __fastcall sub_6024(int a1, int a2, unsigned int a3)
{
  int v3; // r10@1
  unsigned int v4; // r6@1
  int v5; // r8@2
  int v6; // r7@2
  int v7; // r9@2
  int v8; // r4@3
  int v9; // r5@3
  unsigned int v10; // r0@3
  unsigned int v11; // r11@3
  int v12; // r0@4

  v3 = a1;
  v4 = a3;
  if ( a2 )
  {
    v5 = a2 - 1;
    v6 = 0;
    v7 = a2 - 1;
    while ( 1 )
    {
      v8 = (v6 + v7) / 2;
      v9 = v3 + 8 * v8;
      v10 = sub_600C((char *)(v3 + 8 * v8));
      v11 = v10;
      if ( v8 == v5 )
      {
        if ( v4 >= v10 )
          return v9;
LABEL_5:
        if ( v8 == v6 )
          return 0;
        v7 = v8 - 1;
      }
      else
      {
        v12 = sub_600C((char *)(v3 + 8 * (v8 + 1)));
        if ( v4 < v11 )
          goto LABEL_5;
        if ( v4 <= v12 - 1 )
          return v9;
        v6 = v8 + 1;
      }
    }
  }
  return 0;
}

//----- (000060C8) --------------------------------------------------------
int __fastcall sub_60C8(int a1)
{
  signed int v1; // r2@4

  if ( a1 == 1 )
  {
    v1 = -6;
    return GLOBAL_OFFSET_TABLE_[v1];
  }
  if ( a1 == 2 )
  {
    v1 = -5;
    return GLOBAL_OFFSET_TABLE_[v1];
  }
  if ( !a1 )
  {
    v1 = -7;
    return GLOBAL_OFFSET_TABLE_[v1];
  }
  return 0;
}
// 9FA4: using guessed type int GLOBAL_OFFSET_TABLE_[];

//----- (0000611C) --------------------------------------------------------
_DWORD *__fastcall sub_611C(_DWORD *result)
{
  int v1; // r3@1
  _DWORD *v2; // r4@1
  int v3; // r0@2

  v1 = *result;
  v2 = result;
  if ( !(*result & 1) )
  {
    v3 = (int)(result + 18);
    if ( v1 & 2 )
      result = (_DWORD *)_gnu_Unwind_Restore_VFP_D(v3);
    else
      result = (_DWORD *)_gnu_Unwind_Restore_VFP(v3);
  }
  if ( !(*v2 & 4) )
    result = (_DWORD *)_gnu_Unwind_Restore_VFP_D_16_to_31((int)(v2 + 52));
  if ( !(*v2 & 8) )
    result = (_DWORD *)_gnu_Unwind_Restore_WMMXD(v2 + 108);
  if ( !(*v2 & 0x10) )
    result = (_DWORD *)_gnu_Unwind_Restore_WMMXC(v2 + 140);
  return result;
}

//----- (00006188) --------------------------------------------------------
signed int __fastcall sub_6188(int a1, int a2, int a3)
{
  int v3; // r4@1
  unsigned int v4; // r5@1
  int v5; // r0@2
  char *v6; // r0@6
  char *v7; // r5@6
  signed int result; // r0@8
  int v9; // r0@9
  int v10; // r3@9
  char *v11; // r0@11
  signed int v12; // r3@12
  int v13; // r0@13
  char *v14; // r0@14
  int v15; // r0@15
  int v16; // [sp+4h] [bp-14h]@1
  int v17; // [sp+8h] [bp-10h]@1

  v16 = a2;
  v17 = a3;
  v3 = a1;
  v4 = a2 - 2;
  if ( &__gnu_Unwind_Find_exidx )
  {
    v5 = _gnu_Unwind_Find_exidx(a2 - 2, &v16);
    if ( !v5 )
    {
      *(_DWORD *)(v3 + 16) = 0;
      return 9;
    }
  }
  else
  {
    v5 = 30028;
    v16 = 0x308 >> 3;
  }
  v6 = (char *)sub_6024(v5, v16, v4);
  v7 = v6;
  if ( !v6 )
  {
    *(_DWORD *)(v3 + 16) = v6;
    return 9;
  }
  v9 = sub_600C(v6);
  v10 = *((_DWORD *)v7 + 1);
  *(_DWORD *)(v3 + 72) = v9;
  if ( v10 == 1 )
  {
    result = 5;
    *(_DWORD *)(v3 + 16) = 0;
  }
  else
  {
    v11 = v7 + 4;
    if ( v10 >= 0 )
    {
      v13 = sub_600C(v11);
      v12 = 0;
      *(_DWORD *)(v3 + 76) = v13;
    }
    else
    {
      *(_DWORD *)(v3 + 76) = v11;
      v12 = 1;
    }
    v14 = *(char **)(v3 + 76);
    *(_DWORD *)(v3 + 80) = v12;
    if ( *(_DWORD *)v14 >= 0 )
    {
      *(_DWORD *)(v3 + 16) = sub_600C(v14);
      result = 0;
    }
    else
    {
      v15 = sub_60C8((*(_DWORD *)v14 >> 24) & 0xF);
      *(_DWORD *)(v3 + 16) = v15;
      if ( v15 )
        result = 0;
      else
        result = 9;
    }
  }
  return result;
}
// 1930: using guessed type int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD);

//----- (00006298) --------------------------------------------------------
int __fastcall sub_6298(char *a1)
{
  int v1; // r3@1

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
    v1 = *(_DWORD *)&a1[v1];
  return v1;
}

//----- (000062AC) --------------------------------------------------------
signed int sub_62AC()
{
  return 9;
}

//----- (000062B8) --------------------------------------------------------
signed int __fastcall sub_62B8(int a1, int a2, int a3)
{
  int v3; // lr@1
  int (__fastcall *v4)(signed int, signed int, int, int); // r8@1
  int v5; // r4@1
  int v6; // r10@1
  int v7; // r7@1
  int v8; // r0@1
  int v9; // r1@1
  int v10; // r2@1
  int v11; // r3@1
  int v12; // r9@1
  int v13; // r0@1
  int v14; // r1@1
  int v15; // r2@1
  int v16; // r3@1
  int v17; // r0@1
  int v18; // r1@1
  int v19; // r2@1
  int v20; // r3@1
  int v21; // r2@1
  int v22; // r1@1
  int v23; // r3@1
  signed int v24; // r0@2
  signed int v25; // r7@3
  signed int v26; // r5@5
  int v27; // r3@6
  int v28; // r0@7
  int v30; // [sp+8h] [bp-4A0h]@1
  int v31; // [sp+Ch] [bp-49Ch]@1
  int v32; // [sp+10h] [bp-498h]@1
  int v33; // [sp+14h] [bp-494h]@1
  int v34; // [sp+18h] [bp-490h]@1
  int v35; // [sp+1Ch] [bp-48Ch]@1
  int v36; // [sp+20h] [bp-488h]@1
  int v37; // [sp+24h] [bp-484h]@1
  int v38; // [sp+28h] [bp-480h]@1
  int v39; // [sp+2Ch] [bp-47Ch]@1
  int v40; // [sp+30h] [bp-478h]@1
  int v41; // [sp+34h] [bp-474h]@1
  int v42; // [sp+38h] [bp-470h]@1
  int v43; // [sp+3Ch] [bp-46Ch]@1
  int v44; // [sp+40h] [bp-468h]@1
  int v45; // [sp+44h] [bp-464h]@1
  int v46; // [sp+48h] [bp-460h]@1
  int v47; // [sp+4Ch] [bp-45Ch]@8
  char dest; // [sp+248h] [bp-260h]@7
  int v49; // [sp+280h] [bp-228h]@7

  v3 = a2 + 4;
  v4 = *(int (__fastcall **)(signed int, signed int, int, int))(a1 + 12);
  v5 = a1;
  v6 = *(_DWORD *)(a1 + 24);
  v7 = a3;
  v8 = *(_DWORD *)(a2 + 4);
  v9 = *(_DWORD *)(a2 + 8);
  v10 = *(_DWORD *)(v3 + 8);
  v11 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v12 = 0;
  v31 = v8;
  v32 = v9;
  v33 = v10;
  v34 = v11;
  v13 = *(_DWORD *)v3;
  v14 = *(_DWORD *)(v3 + 4);
  v15 = *(_DWORD *)(v3 + 8);
  v16 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v35 = v13;
  v36 = v14;
  v37 = v15;
  v38 = v16;
  v17 = *(_DWORD *)v3;
  v18 = *(_DWORD *)(v3 + 4);
  v19 = *(_DWORD *)(v3 + 8);
  v20 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v39 = v17;
  v40 = v18;
  v41 = v19;
  v42 = v20;
  v22 = *(_DWORD *)(v3 + 4);
  v21 = *(_DWORD *)(v3 + 8);
  v23 = *(_DWORD *)(v3 + 12);
  v43 = *(_DWORD *)v3;
  v44 = v22;
  v45 = v21;
  v46 = v23;
  v30 = 0;
  while ( 1 )
  {
    v24 = sub_6188(v5, v46, v21);
    v25 = v7 ? 10 : 9;
    v26 = v24;
    if ( v24 )
    {
      v25 |= 0x10u;
      v27 = v44;
    }
    else
    {
      *(_DWORD *)(v5 + 20) = v46;
      memcpy(&dest, &v30, 0x240u);
      v28 = (*(int (__fastcall **)(signed int, int, char *))(v5 + 16))(v25, v5, &dest);
      v27 = v49;
      v12 = v28;
    }
    v47 = v27;
    if ( v4(1, v25, v5, v5) )
      break;
    if ( v26 )
      return v26;
    v7 = 0;
    memcpy(&v30, &dest, 0x240u);
    if ( v12 != 8 )
    {
      if ( v12 == 7 )
      {
        nullsub_1(0, v46);
        restore_core_regs((int)&v31);
      }
      return 9;
    }
  }
  return 9;
}
// 62B4: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);

//----- (000063E0) --------------------------------------------------------
int __fastcall sub_63E0(int a1, int a2, int a3)
{
  int v3; // r5@1
  int v4; // r4@1
  int v5; // r0@4
  int v6; // r0@6

  v3 = a1;
  v4 = a2;
  do
  {
    if ( sub_6188(v3, *(_DWORD *)(v4 + 64), a3) )
      goto LABEL_3;
    *(_DWORD *)(v3 + 20) = *(_DWORD *)(v4 + 64);
    v5 = (*(int (__fastcall **)(signed int, int, int))(v3 + 16))(1, v3, v4);
  }
  while ( v5 == 8 );
  if ( v5 != 7 )
LABEL_3:
    abort();
  nullsub_1(0, *(_DWORD *)(v4 + 64));
  restore_core_regs(v4 + 4);
  return Unwind_GetCFA(v6);
}
// 62B4: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);

//----- (00006444) --------------------------------------------------------
int __fastcall Unwind_GetCFA(int a1)
{
  return *(_DWORD *)(a1 + 68);
}

//----- (0000644C) --------------------------------------------------------
signed int __fastcall _gnu_Unwind_RaiseException(int a1, int a2)
{
  int v2; // lr@1
  int v3; // r5@1
  int v4; // r4@1
  int v5; // r0@1
  int v6; // r1@1
  int v7; // r2@1
  int v8; // r3@1
  int v9; // r0@1
  int v10; // r1@1
  int v11; // r2@1
  int v12; // r3@1
  int v13; // r0@1
  int v14; // r1@1
  int v15; // r2@1
  int v16; // r3@1
  int v17; // r2@1
  int v18; // r1@1
  int v19; // r3@1
  int v20; // r7@3
  int v21; // r2@4
  signed int v23; // [sp+0h] [bp-258h]@1
  int v24; // [sp+4h] [bp-254h]@1
  int v25; // [sp+8h] [bp-250h]@1
  int v26; // [sp+Ch] [bp-24Ch]@1
  int v27; // [sp+10h] [bp-248h]@1
  int v28; // [sp+14h] [bp-244h]@1
  int v29; // [sp+18h] [bp-240h]@1
  int v30; // [sp+1Ch] [bp-23Ch]@1
  int v31; // [sp+20h] [bp-238h]@1
  int v32; // [sp+24h] [bp-234h]@1
  int v33; // [sp+28h] [bp-230h]@1
  int v34; // [sp+2Ch] [bp-22Ch]@1
  int v35; // [sp+30h] [bp-228h]@1
  int v36; // [sp+34h] [bp-224h]@1
  int v37; // [sp+38h] [bp-220h]@1
  int v38; // [sp+3Ch] [bp-21Ch]@1
  int v39; // [sp+40h] [bp-218h]@1

  v2 = a2 + 4;
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 60);
  v3 = a1;
  v4 = a2;
  v5 = *(_DWORD *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = *(_DWORD *)(v2 + 8);
  v8 = *(_DWORD *)(v2 + 12);
  v2 += 16;
  v24 = v5;
  v25 = v6;
  v26 = v7;
  v27 = v8;
  v9 = *(_DWORD *)v2;
  v10 = *(_DWORD *)(v2 + 4);
  v11 = *(_DWORD *)(v2 + 8);
  v12 = *(_DWORD *)(v2 + 12);
  v2 += 16;
  v28 = v9;
  v29 = v10;
  v30 = v11;
  v31 = v12;
  v13 = *(_DWORD *)v2;
  v14 = *(_DWORD *)(v2 + 4);
  v15 = *(_DWORD *)(v2 + 8);
  v16 = *(_DWORD *)(v2 + 12);
  v2 += 16;
  v32 = v13;
  v33 = v14;
  v34 = v15;
  v35 = v16;
  v18 = *(_DWORD *)(v2 + 4);
  v17 = *(_DWORD *)(v2 + 8);
  v19 = *(_DWORD *)(v2 + 12);
  v36 = *(_DWORD *)v2;
  v37 = v18;
  v38 = v17;
  v39 = v19;
  v23 = -1;
  while ( !sub_6188(v3, v39, v17) )
  {
    v20 = (*(int (__cdecl **)(_DWORD, int, signed int *, _DWORD, signed int, int, int, int, int, int, int, int, int, int, int, int))(v3 + 16))(
            0,
            v3,
            &v23,
            *(_DWORD *)(v3 + 16),
            v23,
            v24,
            v25,
            v26,
            v27,
            v28,
            v29,
            v30,
            v31,
            v32,
            v33,
            v34);
    if ( v20 != 8 )
    {
      sub_611C(&v23);
      if ( v20 == 6 )
        sub_63E0(v3, v4, v21);
      return 9;
    }
  }
  return 9;
}

//----- (000064F0) --------------------------------------------------------
signed int __fastcall _gnu_Unwind_ForcedUnwind(int a1, int a2, int a3, int a4)
{
  int v4; // r2@1

  *(_DWORD *)(a1 + 24) = a3;
  v4 = *(_DWORD *)(a4 + 60);
  *(_DWORD *)(a1 + 12) = a2;
  *(_DWORD *)(a4 + 64) = v4;
  return sub_62B8(a1, a4, 0);
}

//----- (0000650C) --------------------------------------------------------
void __fastcall _gnu_Unwind_Resume(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r6@1
  int v4; // r4@1
  int v5; // r0@3
  int v6; // r2@3

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 12);
  v4 = a2;
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 20);
  if ( v3 )
  {
    sub_62B8(a1, a2, 1);
    goto LABEL_8;
  }
  v5 = (*(int (__fastcall **)(signed int, int, int))(a1 + 16))(2, a1, a2);
  if ( v5 == 7 )
  {
    nullsub_1(0, *(_DWORD *)(v4 + 64));
    restore_core_regs(v4 + 4);
  }
  else if ( v5 != 8 )
  {
    goto LABEL_8;
  }
  sub_63E0(v2, v4, v6);
LABEL_8:
  abort();
}
// 62B4: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);

//----- (00006584) --------------------------------------------------------
signed int __fastcall _gnu_Unwind_Resume_or_Rethrow(int a1, int a2)
{
  signed int result; // r0@2

  if ( *(_DWORD *)(a1 + 12) )
  {
    *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 60);
    result = sub_62B8(a1, a2, 0);
  }
  else
  {
    result = _gnu_Unwind_RaiseException(a1, a2);
  }
  return result;
}

//----- (000065A8) --------------------------------------------------------
int __fastcall Unwind_DeleteException(int result)
{
  int (__fastcall *v1)(signed int, int); // r3@1

  v1 = *(int (__fastcall **)(signed int, int))(result + 8);
  if ( v1 )
    result = v1(1, result);
  return result;
}

//----- (000065C8) --------------------------------------------------------
signed int __fastcall Unwind_VRS_Get(int a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5)
{
  signed int result; // r0@3
  bool v6; // zf@6
  signed int v7; // r3@9

  if ( a2 )
  {
    if ( a2 <= 4 )
      result = 1;
    else
      result = 2;
  }
  else
  {
    v6 = a3 == 15;
    if ( a3 <= 0xF )
      v6 = a4 == 0;
    if ( v6 )
    {
      a3 = a1 + 4 * a3;
      v7 = 0;
    }
    else
    {
      v7 = 1;
    }
    if ( v6 )
    {
      a2 = *(_DWORD *)(a3 + 4);
      result = v7;
      a3 = a5;
    }
    else
    {
      result = 2;
    }
    if ( v6 )
      *(_DWORD *)a3 = a2;
  }
  return result;
}

//----- (0000660C) --------------------------------------------------------
int __fastcall sub_660C(int a1, unsigned int a2, int a3, int a4)
{
  int v5; // [sp+Ch] [bp-Ch]@1

  v5 = a4;
  Unwind_VRS_Get(a1, 0, a2, 0, (unsigned int)&v5);
  return v5;
}

//----- (00006634) --------------------------------------------------------
signed int __fastcall Unwind_VRS_Set(int a1, _DWORD *a2, unsigned int a3, int a4, _DWORD *a5)
{
  signed int result; // r0@3
  bool v6; // zf@6
  signed int v7; // r3@9

  if ( a2 )
  {
    if ( (unsigned int)a2 <= 4 )
      result = 1;
    else
      result = 2;
  }
  else
  {
    v6 = a3 == 15;
    if ( a3 <= 0xF )
      v6 = a4 == 0;
    if ( v6 )
    {
      a3 = a1 + 4 * a3;
      a2 = a5;
      v7 = 0;
    }
    else
    {
      v7 = 1;
    }
    if ( v6 )
      result = v7;
    else
      result = 2;
    if ( v6 )
      *(_DWORD *)(a3 + 4) = *a2;
  }
  return result;
}

//----- (00006678) --------------------------------------------------------
signed int __fastcall sub_6678(int a1, unsigned int a2, int a3)
{
  int v4; // [sp+Ch] [bp-Ch]@1

  v4 = a3;
  return Unwind_VRS_Set(a1, 0, a2, 0, &v4);
}

//----- (000066A4) --------------------------------------------------------
signed int __fastcall sub_66A4(int a1, int a2, int a3, signed int a4)
{
  int v4; // r6@1
  int *v5; // r5@1
  signed int v6; // r10@1
  int v7; // r4@1
  int v8; // r7@1
  unsigned int v9; // r2@1
  int v10; // r5@1
  int v11; // t1@1
  int v12; // r9@7
  int v13; // r3@11
  int v14; // r5@11
  int v15; // r8@12
  unsigned int v16; // r0@13
  int v17; // r0@14
  int v18; // r0@21
  int v19; // r0@24
  void *v20; // r5@24
  int v21; // r0@25
  unsigned int v22; // r1@25
  void *v23; // r2@25
  int v24; // r1@29
  unsigned int v25; // r8@29
  int v26; // r0@31
  int v27; // r8@31
  int v28; // r0@34
  int v29; // r3@34
  int v30; // r2@34
  int v31; // r3@38
  int v32; // r8@40
  int v33; // r0@42
  int v35; // r8@46
  int v36; // r3@48
  int v37; // ST04_4@52
  int v38; // r0@52
  int v39; // r0@52
  int v40; // r3@52
  int v41; // r12@52
  int v42; // r0@56
  int v43; // ST00_4@59
  int v44; // r0@62
  int v45; // r8@64
  signed int v46; // r0@69
  int v47; // r2@69
  int v48; // r3@69
  int v49; // r0@72
  char v50; // [sp+0h] [bp-48h]@13
  unsigned int v51; // [sp+4h] [bp-44h]@13
  unsigned int v52; // [sp+Ch] [bp-3Ch]@9
  int v53; // [sp+10h] [bp-38h]@30
  unsigned int v54; // [sp+14h] [bp-34h]@1
  int v55; // [sp+18h] [bp-30h]@1
  char v56; // [sp+1Ch] [bp-2Ch]@2
  unsigned __int8 v57; // [sp+1Dh] [bp-2Bh]@2

  v4 = a3;
  v5 = *(int **)(a2 + 76);
  v6 = a4;
  v7 = a2;
  v8 = a1 & 3;
  v11 = *v5;
  v10 = (int)(v5 + 1);
  v9 = v11;
  v54 = v11;
  v55 = v10;
  if ( a4 )
  {
    if ( a4 <= 2 )
    {
      v57 = v9 >> 16;
      v54 = v9 << 16;
      a4 = v57;
      v9 = 2;
      v56 = 2;
      v10 += 4 * v57;
    }
  }
  else
  {
    v9 <<= 8;
    a4 = 3;
    v54 = v9;
    v57 = v6;
    v56 = 3;
  }
  if ( v8 == 2 )
    v10 = *(_DWORD *)(a2 + 56);
  v12 = *(_DWORD *)(a2 + 80) & 1;
  if ( v12 )
  {
    v12 = 0;
LABEL_68:
    if ( v6 <= 2 )
      v46 = _gnu_unwind_execute(v4, (int)&v54, v9, a4);
    else
      v46 = sub_62AC();
    if ( v46 )
      return 9;
    if ( !v12 )
      return 8;
    v49 = sub_660C(v4, 0xFu, v47, v48);
    sub_6678(v4, 0xEu, v49);
    v21 = v4;
    v22 = 15;
    v23 = &_cxa_call_unexpected;
LABEL_44:
    sub_6678(v21, v22, (int)v23);
    return 7;
  }
  v52 = ((a1 ^ 8u) >> 3) & 1;
  while ( 1 )
  {
    while ( 1 )
    {
      v15 = *(_DWORD *)v10;
      if ( !*(_DWORD *)v10 )
        goto LABEL_68;
      if ( v6 == 2 )
      {
        v13 = *(_DWORD *)(v10 + 4);
        v14 = v10 + 8;
      }
      else
      {
        v13 = *(_WORD *)(v10 + 2);
        v15 = *(_WORD *)v10;
        v14 = v10 + 4;
      }
      v51 = (v13 & 0xFFFFFFFE) + *(_DWORD *)(v7 + 72);
      v50 = v13;
      v16 = sub_660C(v4, 0xFu, v51, v13);
      v9 = v51;
      if ( v51 <= v16 )
      {
        v9 = v51 + (v15 & 0xFFFFFFFE);
        v17 = v16 < v9;
      }
      else
      {
        v17 = 0;
      }
      a4 = v15 & 1 | 2 * (v50 & 1);
      if ( a4 == 1 )
        break;
      if ( (unsigned int)a4 < 1 )
      {
        if ( v8 )
          v18 = v17 & 1;
        else
          v18 = 0;
        if ( v18 )
        {
          v19 = sub_600C((char *)v14);
          *(_DWORD *)(v7 + 56) = v14 + 4;
          v20 = (void *)v19;
          if ( !_cxa_begin_cleanup(v7) )
            return 9;
          v21 = v4;
          v22 = 15;
          v23 = v20;
          goto LABEL_44;
        }
        v10 = v14 + 4;
      }
      else
      {
        if ( a4 != 2 )
          return 9;
        v35 = *(_DWORD *)v14 & 0x7FFFFFFF;
        if ( v8 )
        {
          v43 = *(_DWORD *)(v7 + 32);
          if ( v43 != sub_660C(v4, 0xDu, v9, *(_DWORD *)(v7 + 32)) || v14 != *(_DWORD *)(v7 + 40) )
            goto LABEL_64;
          *(_DWORD *)(v7 + 40) = v35;
          *(_DWORD *)(v7 + 48) = 4;
          *(_DWORD *)(v7 + 44) = 0;
          *(_DWORD *)(v7 + 52) = v14 + 4;
          if ( *(_DWORD *)v14 >= 0 )
          {
            v12 = 1;
            goto LABEL_64;
          }
          v44 = sub_600C((char *)(v14 + 4 * (v35 + 1)));
          sub_6678(v4, 0xFu, v44);
          v21 = v4;
          v22 = 0;
LABEL_43:
          v23 = (void *)v7;
          goto LABEL_44;
        }
        if ( v17 )
        {
          v36 = v52;
          if ( !v35 )
            v36 = v52 | 1;
          if ( v36 )
          {
            v41 = 0;
            v40 = v7 + 88;
            while ( v41 != v35 )
            {
              v37 = v41 + 1;
              v53 = v7 + 88;
              v38 = sub_6298((char *)(v14 + 4 * (v41 + 1)));
              v39 = _cxa_type_match(v7, v38, 0, &v53);
              v41 = v37;
              if ( v39 )
                goto LABEL_64;
            }
            v42 = sub_660C(v4, 0xDu, v9, v40);
            v31 = v53;
            *(_DWORD *)(v7 + 32) = v42;
LABEL_57:
            *(_DWORD *)(v7 + 36) = v31;
            goto LABEL_58;
          }
        }
LABEL_64:
        a4 = *(_DWORD *)v14;
        v45 = v35 + 1;
        if ( *(_DWORD *)v14 < 0 )
          v14 += 4;
        v10 = v14 + 4 * v45;
      }
    }
    if ( !v8 )
      break;
    v32 = *(_DWORD *)(v7 + 32);
    if ( v32 == sub_660C(v4, 0xDu, v9, 1) )
    {
      a4 = *(_DWORD *)(v7 + 40);
      if ( v14 == a4 )
      {
        v33 = sub_600C((char *)v14);
        sub_6678(v4, 0xFu, v33);
        v21 = v4;
        v22 = 0;
        goto LABEL_43;
      }
    }
LABEL_45:
    v10 = v14 + 8;
  }
  if ( !v17 )
    goto LABEL_45;
  v24 = *(_DWORD *)(v14 + 4);
  v25 = *(_DWORD *)v14;
  if ( v24 == -2 )
    return 9;
  v9 = v7 + 88;
  v53 = v7 + 88;
  if ( v24 != -1 )
  {
    v26 = sub_6298((char *)(v14 + 4));
    v27 = _cxa_type_match(v7, v26, v25 >> 31, &v53);
    if ( v27 )
      goto LABEL_34;
    goto LABEL_45;
  }
  v27 = 1;
LABEL_34:
  v28 = sub_660C(v4, 0xDu, v9, a4);
  v30 = v53;
  if ( v27 == 2 )
    v29 = v7;
  else
    *(_DWORD *)(v7 + 36) = v53;
  *(_DWORD *)(v7 + 32) = v28;
  if ( v27 == 2 )
  {
    *(_DWORD *)(v29 + 44) = v30;
    v31 = v29 + 44;
    goto LABEL_57;
  }
LABEL_58:
  *(_DWORD *)(v7 + 40) = v14;
  return 6;
}
// 1948: using guessed type int __fastcall _cxa_begin_cleanup(_DWORD);
// 1954: using guessed type int __fastcall _cxa_type_match(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00006AC0) --------------------------------------------------------
signed int __fastcall _aeabi_unwind_cpp_pr2(int a1, int a2, int a3)
{
  return sub_66A4(a1, a2, a3, 2);
}

//----- (00006AC8) --------------------------------------------------------
signed int __fastcall _aeabi_unwind_cpp_pr1(int a1, int a2, int a3)
{
  return sub_66A4(a1, a2, a3, 1);
}

//----- (00006AD0) --------------------------------------------------------
signed int __fastcall _aeabi_unwind_cpp_pr0(int a1, int a2, int a3)
{
  return sub_66A4(a1, a2, a3, 0);
}

//----- (00006AD8) --------------------------------------------------------
signed int __fastcall _gnu_Unwind_Backtrace(int (__fastcall *a1)(int *, int), int a2, int a3)
{
  int v3; // lr@1
  int (__fastcall *v4)(int *, int); // r5@1
  int v5; // r6@1
  int v6; // r0@1
  int v7; // r1@1
  int v8; // r2@1
  int v9; // r3@1
  int v10; // r0@1
  int v11; // r1@1
  int v12; // r2@1
  int v13; // r3@1
  int v14; // r0@1
  int v15; // r1@1
  int v16; // r2@1
  int v17; // r3@1
  int v18; // r2@1
  int v19; // r1@1
  int v20; // r3@1
  signed int v21; // r4@3
  int v22; // r0@5
  bool v23; // zf@5
  int v25; // [sp+0h] [bp-2A8h]@2
  int (__fastcall *v26)(signed int, int *, int *); // [sp+10h] [bp-298h]@5
  int v27; // [sp+58h] [bp-250h]@1
  int v28; // [sp+5Ch] [bp-24Ch]@1
  int v29; // [sp+60h] [bp-248h]@1
  int v30; // [sp+64h] [bp-244h]@1
  int v31; // [sp+68h] [bp-240h]@1
  int v32; // [sp+6Ch] [bp-23Ch]@1
  int v33; // [sp+70h] [bp-238h]@1
  int v34; // [sp+74h] [bp-234h]@1
  int v35; // [sp+78h] [bp-230h]@1
  int v36; // [sp+7Ch] [bp-22Ch]@1
  int v37; // [sp+80h] [bp-228h]@1
  int v38; // [sp+84h] [bp-224h]@1
  int v39; // [sp+88h] [bp-220h]@1
  int v40; // [sp+8Ch] [bp-21Ch]@1
  int v41; // [sp+90h] [bp-218h]@1
  int v42; // [sp+94h] [bp-214h]@1
  int v43; // [sp+98h] [bp-210h]@1

  v3 = a3 + 4;
  *(_DWORD *)(a3 + 64) = *(_DWORD *)(a3 + 60);
  v4 = a1;
  v5 = a2;
  v6 = *(_DWORD *)(a3 + 4);
  v7 = *(_DWORD *)(a3 + 8);
  v8 = *(_DWORD *)(a3 + 12);
  v9 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v28 = v6;
  v29 = v7;
  v30 = v8;
  v31 = v9;
  v10 = *(_DWORD *)v3;
  v11 = *(_DWORD *)(v3 + 4);
  v12 = *(_DWORD *)(v3 + 8);
  v13 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v32 = v10;
  v33 = v11;
  v34 = v12;
  v35 = v13;
  v14 = *(_DWORD *)v3;
  v15 = *(_DWORD *)(v3 + 4);
  v16 = *(_DWORD *)(v3 + 8);
  v17 = *(_DWORD *)(v3 + 12);
  v3 += 16;
  v36 = v14;
  v37 = v15;
  v38 = v16;
  v39 = v17;
  v19 = *(_DWORD *)(v3 + 4);
  v18 = *(_DWORD *)(v3 + 8);
  v20 = *(_DWORD *)(v3 + 12);
  v40 = *(_DWORD *)v3;
  v41 = v19;
  v42 = v18;
  v43 = v20;
  v27 = -1;
  while ( !sub_6188((int)&v25, v43, v18) )
  {
    sub_6678((int)&v27, 0xCu, (int)&v25);
    if ( v4(&v27, v5) )
      break;
    v22 = v26(8, &v25, &v27);
    v23 = v22 == 9;
    if ( v22 != 9 )
      v23 = v22 == 5;
    v21 = v22;
    if ( v23 )
      goto LABEL_9;
  }
  v21 = 9;
LABEL_9:
  sub_611C(&v27);
  return v21;
}

//----- (00006B98) --------------------------------------------------------
int __fastcall Unwind_VRS_Pop(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // r4@1
  unsigned int v5; // r5@1
  int result; // r0@2
  int v7; // r1@4
  int *v8; // r2@4
  bool v9; // zf@5
  int v10; // r12@5
  int v11; // t1@8
  unsigned int v12; // r6@14
  int v13; // r5@14
  unsigned int v14; // r2@14
  unsigned int v15; // r1@15
  int v16; // r10@18
  int v17; // r8@18
  signed int v18; // r7@23
  bool v19; // zf@25
  int v20; // r2@30
  int v21; // r0@31
  int v22; // r2@45
  int v23; // r3@45
  int v24; // r5@46
  unsigned int v25; // r1@46
  char *i; // r0@46
  bool v27; // cf@48
  signed int v28; // r0@52
  int v29; // r8@54
  int v30; // r2@54
  char *v31; // r0@54
  unsigned int v32; // r6@67
  int v33; // r5@67
  int v34; // r5@70
  char *v35; // r6@70
  int v36; // r1@70
  unsigned int v37; // r3@70
  char *j; // r2@70
  bool v39; // zf@74
  int *v40; // r2@80
  int v41; // r3@80
  int v42; // t1@82
  int v43; // [sp+0h] [bp-1B8h]@82
  char v44; // [sp+10h] [bp-1A8h]@43
  char v45[128]; // [sp+90h] [bp-128h]@70
  char v46[136]; // [sp+110h] [bp-A8h]@41
  char v47; // [sp+198h] [bp-20h]@54

  v4 = a1;
  v5 = a3;
  switch ( a2 )
  {
    case 0:
      if ( a4 )
        return 2;
      v7 = (unsigned __int16)a3;
      v8 = *(int **)(a1 + 56);
      do
      {
        v10 = v7 & (1 << a4);
        v9 = (v7 & (1 << a4)) == 0;
        if ( v7 & (1 << a4) )
          v10 = a1 + 4 * a4;
        ++a4;
        if ( !v9 )
        {
          v11 = *v8;
          ++v8;
          *(_DWORD *)(v10 + 4) = v11;
        }
      }
      while ( a4 != 16 );
      result = v5 & 0x2000;
      if ( v5 & 0x2000 )
        return 0;
      *(_DWORD *)(v4 + 56) = v8;
      return result;
    case 1:
      if ( (a4 & 0xFFFFFFFB) != 1 )
        return 2;
      v12 = a3 >> 16;
      v13 = (unsigned __int16)a3;
      v14 = (unsigned __int16)a3 + (a3 >> 16);
      v15 = a4 == 1 ? 16 : 32;
      if ( v14 > v15 )
        return 2;
      v16 = a4 - 1 + ((unsigned int)(a4 - 1) <= 0) - (a4 - 1);
      v17 = v12 > 0xF;
      if ( v17 & v16 )
        return 2;
      if ( v12 > 0xF )
      {
        v17 = v13;
      }
      else if ( v14 > 0x10 )
      {
        v17 = v14 - 16;
      }
      v18 = v17;
      if ( v17 )
        v18 = 1;
      v19 = a4 == 5;
      if ( a4 != 5 )
        v19 = v17 == 0;
      if ( !v19 )
        return 2;
      if ( v12 <= 0xF )
      {
        v20 = *(_DWORD *)a1;
        if ( *(_DWORD *)a1 & 1 )
        {
          *(_DWORD *)a1 = v20 & 0xFFFFFFFE;
          v21 = a1 + 72;
          if ( a4 == 5 )
          {
            *(_DWORD *)v4 = v20 & 0xFFFFFFFE | 2;
            _gnu_Unwind_Save_VFP_D(v21);
          }
          else
          {
            *(_DWORD *)v4 = v20 & 0xFFFFFFFC;
            _gnu_Unwind_Save_VFP();
          }
        }
      }
      if ( v18 && *(_DWORD *)v4 & 4 )
      {
        *(_DWORD *)v4 &= 0xFFFFFFFB;
        _gnu_Unwind_Save_VFP_D_16_to_31(v4 + 208);
      }
      if ( v16 )
      {
        _gnu_Unwind_Save_VFP();
        if ( !v18 )
          goto LABEL_45;
      }
      else
      {
        if ( v12 <= 0xF )
          _gnu_Unwind_Save_VFP_D((int)v46);
        if ( !v18 )
          goto LABEL_45;
        _gnu_Unwind_Save_VFP_D_16_to_31((int)&v44);
      }
      v13 = 16 - v12;
LABEL_45:
      v22 = *(_DWORD *)(v4 + 56);
      v23 = *(_DWORD *)(v4 + 56);
      if ( v13 > 0 )
      {
        v24 = 2 * v13;
        v25 = v24;
        for ( i = &v46[8 * v12]; ; i += 4 )
        {
          v27 = v25-- >= 1;
          if ( !v27 )
            break;
          *(_DWORD *)i = *(_DWORD *)(i - &v46[8 * v12] + v22);
        }
        v23 = v22 + 4 * v24;
      }
      if ( v18 )
      {
        if ( v12 < 0x10 )
          v28 = 16;
        else
          v28 = v12;
        v29 = 2 * v17;
        v30 = 0;
        v31 = &v47 + 8 * v28 - 520;
        while ( v30 != v29 )
        {
          *(_DWORD *)&v31[4 * v30] = *(_DWORD *)(v23 + 4 * v30);
          ++v30;
        }
        v23 += 4 * v30;
      }
      if ( v16 )
        v23 += 4;
      *(_DWORD *)(v4 + 56) = v23;
      if ( v16 )
      {
        _gnu_Unwind_Restore_VFP((int)v46);
      }
      else
      {
        if ( v12 <= 0xF )
          _gnu_Unwind_Restore_VFP_D((int)v46);
        if ( v18 )
          _gnu_Unwind_Restore_VFP_D_16_to_31((int)&v44);
      }
      return 0;
    case 2:
      return 1;
    case 3:
      if ( a4 != 3 )
        return 2;
      v32 = a3 >> 16;
      v33 = (unsigned __int16)a3;
      if ( (unsigned __int16)a3 + (a3 >> 16) > 0x10 )
        return 2;
      if ( *(_DWORD *)a1 & 8 )
      {
        *(_DWORD *)a1 &= 0xFFFFFFF7;
        _gnu_Unwind_Save_WMMXD();
      }
      v34 = 2 * v33;
      _gnu_Unwind_Save_WMMXD();
      v35 = &v45[8 * v32];
      v36 = *(_DWORD *)(v4 + 56);
      v37 = v34;
      for ( j = v35; ; j += 4 )
      {
        v27 = v37-- >= 1;
        if ( !v27 )
          break;
        *(_DWORD *)j = *(_DWORD *)(j - v35 + v36);
      }
      *(_DWORD *)(v4 + 56) = v36 + 4 * v34;
      _gnu_Unwind_Restore_WMMXD((_DWORD *)v45);
      return 0;
    case 4:
      v39 = a3 == 16;
      if ( a3 <= 0x10 )
        v39 = a4 == 0;
      if ( !v39 )
        return 2;
      if ( *(_DWORD *)a1 & 0x10 )
      {
        *(_DWORD *)a1 &= 0xFFFFFFEF;
        _gnu_Unwind_Save_WMMXC();
      }
      _gnu_Unwind_Save_WMMXC();
      v40 = *(int **)(v4 + 56);
      v41 = 0;
      do
      {
        if ( v5 & (1 << v41) )
        {
          v42 = *v40;
          ++v40;
          *(&v43 + v41) = v42;
        }
        ++v41;
      }
      while ( v41 != 4 );
      *(_DWORD *)(v4 + 56) = v40;
      _gnu_Unwind_Restore_WMMXC(&v43);
      return 0;
    default:
      return 2;
  }
}
// 6B98: using guessed type char var_A8[136];
// 6B98: using guessed type char var_128[128];

//----- (00006EEC) --------------------------------------------------------
void __fastcall restore_core_regs(int a1)
{
  int v1; // ST00_4@1
  int v2; // r0@1
  int v3; // [sp+8h] [bp-4h]@0

  v1 = *(_DWORD *)(a1 + 52);
  v2 = *(_DWORD *)a1;
  JUMPOUT(__CS__, v3);
}

//----- (00006F00) --------------------------------------------------------
int __fastcall _gnu_Unwind_Restore_VFP(int result)
{
  __asm { FLDMIAX         R0, {D0-D15} }
  return result;
}

//----- (00006F08) --------------------------------------------------------
int _gnu_Unwind_Save_VFP()
{
  int result; // r0@1

  __asm { FSTMIAX         R0, {D0-D15} }
  return result;
}

//----- (00006F10) --------------------------------------------------------
int __fastcall _gnu_Unwind_Restore_VFP_D(int _R0)
{
  int result; // r0@1

  __asm { VLDMIA          R0, {D0-D15} }
  return result;
}

//----- (00006F18) --------------------------------------------------------
int __fastcall _gnu_Unwind_Save_VFP_D(int _R0)
{
  int result; // r0@1

  __asm { VSTMIA          R0, {D0-D15} }
  return result;
}

//----- (00006F20) --------------------------------------------------------
int __fastcall _gnu_Unwind_Restore_VFP_D_16_to_31(int _R0)
{
  int result; // r0@1

  __asm { VLDMIA          R0, {D16-D31} }
  return result;
}

//----- (00006F28) --------------------------------------------------------
int __fastcall _gnu_Unwind_Save_VFP_D_16_to_31(int _R0)
{
  int result; // r0@1

  __asm { VSTMIA          R0, {D16-D31} }
  return result;
}

//----- (00006F30) --------------------------------------------------------
int __fastcall _gnu_Unwind_Restore_WMMXD(_DWORD *a1)
{
  int *v5; // r0@1
  int result; // r0@1

  _T1 = *a1;
  v5 = a1 + 2;
  __asm { LDCL            p1, c0, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c1, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c2, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c3, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c4, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c5, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c6, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c7, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c8, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c9, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c10, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c11, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c12, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c13, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c14, [R0],#8 }
  _T1 = *v5;
  result = (int)(v5 + 2);
  __asm { LDCL            p1, c15, [R0],#8 }
  return result;
}

//----- (00006F74) --------------------------------------------------------
void _gnu_Unwind_Save_WMMXD()
{
  __asm
  {
    STCL            p1, c0, [R0],#8
    STCL            p1, c1, [R0],#8
    STCL            p1, c2, [R0],#8
    STCL            p1, c3, [R0],#8
    STCL            p1, c4, [R0],#8
    STCL            p1, c5, [R0],#8
    STCL            p1, c6, [R0],#8
    STCL            p1, c7, [R0],#8
    STCL            p1, c8, [R0],#8
    STCL            p1, c9, [R0],#8
    STCL            p1, c10, [R0],#8
    STCL            p1, c11, [R0],#8
    STCL            p1, c12, [R0],#8
    STCL            p1, c13, [R0],#8
    STCL            p1, c14, [R0],#8
    STCL            p1, c15, [R0],#8
  }
}

//----- (00006FB8) --------------------------------------------------------
int __fastcall _gnu_Unwind_Restore_WMMXC(_DWORD *a1)
{
  int *v5; // r0@1
  int result; // r0@1

  _T1 = *a1;
  v5 = a1 + 1;
  __asm { LDC2            p1, c8, [R0],#4 }
  _T1 = *v5;
  ++v5;
  __asm { LDC2            p1, c9, [R0],#4 }
  _T1 = *v5;
  ++v5;
  __asm { LDC2            p1, c10, [R0],#4 }
  _T1 = *v5;
  result = (int)(v5 + 1);
  __asm { LDC2            p1, c11, [R0],#4 }
  return result;
}

//----- (00006FCC) --------------------------------------------------------
void _gnu_Unwind_Save_WMMXC()
{
  __asm
  {
    STC2            p1, c8, [R0],#4
    STC2            p1, c9, [R0],#4
    STC2            p1, c10, [R0],#4
    STC2            p1, c11, [R0],#4
  }
}

//----- (00006FE0) --------------------------------------------------------
signed int __fastcall __Unwind_RaiseException(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-44h]@1
  int v6; // [sp+4h] [bp-40h]@1
  int v7; // [sp+8h] [bp-3Ch]@1
  int v8; // [sp+Ch] [bp-38h]@1
  int v9; // [sp+10h] [bp-34h]@1

  v6 = a1;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v5 = 0;
  return _gnu_Unwind_RaiseException(a1, (int)&v5);
}

//----- (00007004) --------------------------------------------------------
void __fastcall __Unwind_Resume(int a1, int a2, int a3, int a4)
{
  int v4; // [sp+0h] [bp-44h]@1
  int v5; // [sp+4h] [bp-40h]@1
  int v6; // [sp+8h] [bp-3Ch]@1
  int v7; // [sp+Ch] [bp-38h]@1
  int v8; // [sp+10h] [bp-34h]@1

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  v4 = 0;
  _gnu_Unwind_Resume(a1, (int)&v4);
}

//----- (00007028) --------------------------------------------------------
signed int __fastcall __Unwind_Resume_or_Rethrow(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-44h]@1
  int v6; // [sp+4h] [bp-40h]@1
  int v7; // [sp+8h] [bp-3Ch]@1
  int v8; // [sp+Ch] [bp-38h]@1
  int v9; // [sp+10h] [bp-34h]@1

  v6 = a1;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v5 = 0;
  return _gnu_Unwind_Resume_or_Rethrow(a1, (int)&v5);
}

//----- (0000704C) --------------------------------------------------------
signed int __fastcall __Unwind_ForcedUnwind(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-44h]@1
  int v6; // [sp+4h] [bp-40h]@1
  int v7; // [sp+8h] [bp-3Ch]@1
  int v8; // [sp+Ch] [bp-38h]@1
  int v9; // [sp+10h] [bp-34h]@1

  v6 = a1;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v5 = 0;
  return _gnu_Unwind_ForcedUnwind(a1, a2, a3, (int)&v5);
}

//----- (00007070) --------------------------------------------------------
signed int __fastcall __Unwind_Backtrace(int (__fastcall *a1)(int *, int), int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-44h]@1
  int (__fastcall *v6)(int *, int); // [sp+4h] [bp-40h]@1
  int v7; // [sp+8h] [bp-3Ch]@1
  int v8; // [sp+Ch] [bp-38h]@1
  int v9; // [sp+10h] [bp-34h]@1

  v6 = a1;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v5 = 0;
  return _gnu_Unwind_Backtrace(a1, a2, (int)&v5);
}

//----- (00007094) --------------------------------------------------------
signed int __fastcall sub_7094(int a1)
{
  _DWORD *v1; // r3@1
  _DWORD *v2; // r2@3
  char v3; // r2@3
  signed int result; // r0@5
  int v5; // kr00_4@5

  v1 = (_DWORD *)a1;
  if ( *(_BYTE *)(a1 + 8) )
  {
    v3 = *(_BYTE *)(a1 + 8) - 1;
    goto LABEL_5;
  }
  if ( *(_BYTE *)(a1 + 9) )
  {
    --*(_BYTE *)(a1 + 9);
    v2 = *(_DWORD **)(a1 + 4);
    *(_DWORD *)a1 = *v2;
    *(_DWORD *)(a1 + 4) = v2 + 1;
    v3 = 3;
LABEL_5:
    *(_BYTE *)(a1 + 8) = v3;
    v5 = *(_DWORD *)a1 << 8;
    result = (unsigned __int64)*(_DWORD *)a1 >> 24;
    *v1 = v5;
    return result;
  }
  return 176;
}

//----- (000070F0) --------------------------------------------------------
int __fastcall sub_70F0(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+Ch] [bp-Ch]@1

  v5 = a4;
  Unwind_VRS_Get(a1, 0, 0xCu, 0, (unsigned int)&v5);
  return v5;
}

//----- (0000711C) --------------------------------------------------------
signed int __fastcall _gnu_unwind_execute(int a1, int a2, int a3, int a4)
{
  int v4; // r5@1
  int v5; // r6@1
  signed int v6; // r7@1
  signed int v7; // r0@2
  unsigned __int8 v8; // r9@6
  char v9; // r4@6
  int v10; // r9@6
  int v11; // r9@7
  int v12; // r3@10
  int v13; // r0@11
  __int16 v15; // r9@13
  char v16; // r4@23
  char v17; // r2@23
  int v18; // r0@23
  int v19; // r2@23
  signed int v20; // r1@25
  signed int v21; // r0@28
  signed int v22; // r3@31
  char v23; // r4@33
  char i; // r0@33
  bool v25; // zf@34
  _DWORD *v26; // r1@34
  int v27; // r0@34
  char v28; // r0@38
  int v29; // r2@38
  int v30; // r3@38
  int v31; // r4@40
  int v32; // r2@42
  char v33; // r0@48
  signed int v34; // r0@51
  int v35; // r2@55
  char v36; // r0@57
  int v37; // r2@57
  int v38; // r3@57
  char v39; // r0@59
  int v40; // r2@62
  int v41; // [sp+Ch] [bp-24h]@1

  v41 = a4;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  while ( 1 )
  {
    v7 = sub_7094(v5);
    if ( v7 == 176 )
      break;
    if ( !(v7 & 0x80) )
    {
      v8 = 4 * v7;
      v9 = v7 & 0x40;
      Unwind_VRS_Get(v4, v7 & 0x80, 0xDu, v7 & 0x80, (unsigned int)&v41);
      v10 = v8 + 4;
      if ( v9 )
        v11 = v41 - v10;
      else
        v11 = v41 + v10;
      v41 = v11;
      goto LABEL_20;
    }
    v12 = v7 & 0xF0;
    if ( v12 == 128 )
    {
      v13 = sub_7094(v5) | (v7 << 8);
      if ( v13 == 0x8000 )
        return 9;
      v15 = 16 * v13;
      if ( Unwind_VRS_Pop(v4, 0, 16 * v13 & 0xFFFF, 0) )
        return 9;
      if ( v15 & 0x8000 )
        v6 = 1;
    }
    else if ( v12 == 144 )
    {
      if ( (v7 & 0xD) == 13 )
        return 9;
      Unwind_VRS_Get(v4, 0, v7 & 0xF, 0, (unsigned int)&v41);
LABEL_20:
      Unwind_VRS_Set(v4, 0, 0xDu, 0, &v41);
    }
    else
    {
      if ( v12 == 160 )
      {
        v16 = v7 & 8;
        v17 = ~(_BYTE)v7 & 7;
        v18 = v4;
        v19 = (4080 >> v17) & 0xFF0;
        if ( v16 )
          v19 |= 0x4000u;
        v20 = 0;
        goto LABEL_31;
      }
      if ( v12 == 176 )
      {
        if ( v7 == 177 )
        {
          v21 = sub_7094(v5);
          v19 = v21;
          if ( !v21 )
            return 9;
          v20 = v21 & 0xF0;
          if ( v21 & 0xF0 )
            return 9;
          v18 = v4;
          goto LABEL_31;
        }
        if ( v7 != 178 )
        {
          if ( v7 == 179 )
          {
            v28 = sub_7094(v5);
            v20 = 1;
            v29 = v28 & 0xF0;
            v30 = (v28 & 0xF) + 1;
            v18 = v4;
            goto LABEL_49;
          }
          if ( (v7 & 0xFC) == 180 )
            v31 = v7 & 3;
          else
            v31 = v7 & 7;
          v32 = v31 + 1;
          if ( (v7 & 0xFC) == 180 )
          {
            v18 = v4;
            v20 = 2;
            v19 = v32 | 0x40000;
          }
          else
          {
            v18 = v4;
            v20 = 1;
            v19 = v32 | 0x80000;
          }
LABEL_31:
          v22 = v20;
          goto LABEL_64;
        }
        v23 = 2;
        Unwind_VRS_Get(v4, 0, 0xDu, 0, (unsigned int)&v41);
        for ( i = sub_7094(v5); ; i = sub_7094(v5) )
        {
          v26 = (_DWORD *)(i & 0x80);
          v25 = v26 == 0;
          v27 = i & 0x7F;
          if ( v25 )
            break;
          v41 += v27 << v23;
          v23 += 7;
        }
        v41 += 516 + (v27 << v23);
        Unwind_VRS_Set(v4, v26, 0xDu, (int)v26, &v41);
      }
      else
      {
        if ( v12 != 192 )
        {
          if ( (v7 & 0xF8) != 208 )
            return 9;
          v20 = 1;
          v40 = (v7 & 7) + 1;
          v18 = v4;
          v19 = v40 | 0x80000;
          goto LABEL_63;
        }
        if ( v7 == 198 )
        {
          v33 = sub_7094(v5);
          v20 = 3;
          v29 = v33 & 0xF0;
          v30 = (v33 & 0xF) + 1;
          v18 = v4;
LABEL_49:
          v19 = v30 | (v29 << 12);
          goto LABEL_31;
        }
        if ( v7 != 199 )
        {
          if ( (v7 & 0xF8) != 192 )
          {
            if ( v7 == 200 )
            {
              v36 = sub_7094(v5);
              v37 = (unsigned __int8)(v36 & 0xF0) + 16;
              v38 = (v36 & 0xF) + 1;
            }
            else
            {
              if ( v7 != 201 )
                return 9;
              v39 = sub_7094(v5);
              v37 = v39 & 0xF0;
              v38 = (v39 & 0xF) + 1;
            }
            v18 = v4;
            v20 = 1;
            v19 = v38 | (v37 << 12);
LABEL_63:
            v22 = 5;
            goto LABEL_64;
          }
          v20 = 3;
          v35 = (v7 & 0xF) + 1;
          v18 = v4;
          v19 = v35 | 0xA0000;
          goto LABEL_31;
        }
        v34 = sub_7094(v5);
        v19 = v34;
        if ( !v34 )
          return 9;
        v22 = v34 & 0xF0;
        if ( v34 & 0xF0 )
          return 9;
        v18 = v4;
        v20 = 4;
LABEL_64:
        if ( Unwind_VRS_Pop(v18, v20, v19, v22) )
          return 9;
      }
    }
  }
  if ( !v6 )
  {
    Unwind_VRS_Get(v4, 0, 0xEu, 0, (unsigned int)&v41);
    Unwind_VRS_Set(v4, 0, 0xFu, 0, &v41);
  }
  return 0;
}

//----- (000074C0) --------------------------------------------------------
signed int __fastcall _gnu_unwind_frame(int a1, int a2, int a3, int a4)
{
  int v4; // r3@1
  int v5; // r3@1
  int v7; // [sp+4h] [bp-14h]@1
  int v8; // [sp+8h] [bp-10h]@1
  int v9; // [sp+Ch] [bp-Ch]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v4 = *(_DWORD *)(a1 + 76);
  v7 = *(_DWORD *)(v4 + 4) << 8;
  v8 = v4 + 8;
  LOBYTE(v9) = 3;
  v5 = *(_BYTE *)(v4 + 7);
  BYTE1(v9) = v5;
  return _gnu_unwind_execute(a2, (int)&v7, 3, v5);
}

//----- (00007500) --------------------------------------------------------
int Unwind_GetRegionStart()
{
  return *(_DWORD *)(sub_7118() + 72);
}
// 7118: using guessed type int sub_7118(void);

//----- (00007510) --------------------------------------------------------
int Unwind_GetLanguageSpecificData()
{
  int v0; // r0@1

  v0 = sub_7118();
  return *(_DWORD *)(v0 + 76) + 4 * *(_BYTE *)(*(_DWORD *)(v0 + 76) + 7) + 8;
}
// 7118: using guessed type int sub_7118(void);

//----- (0000752C) --------------------------------------------------------
void Unwind_GetDataRelBase()
{
  abort();
}

//----- (00007534) --------------------------------------------------------
void Unwind_GetTextRelBase()
{
  abort();
}

// ALL OK, 131 function(s) have been successfully decompiled
