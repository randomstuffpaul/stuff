/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int _android_log_print(_DWORD, _DWORD, const char *, ...); weak
// void *memset(void *s, int c, size_t n);
// int __fastcall strlcpy(_DWORD, _DWORD, _DWORD); weak
// int fprintf(FILE *stream, const char *format, ...);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int __fastcall _stack_chk_fail(_DWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// int _errno(void); weak
// char *strerror(int errnum);
// int fclose(FILE *stream);
// int chmod(const char *file, __mode_t mode);
// int fscanf(FILE *stream, const char *format, ...);
// int strncmp(const char *s1, const char *s2, size_t n);
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall _cxa_finalize(_DWORD); weak
int sub_1118();
int getFormation();
__int16 *AKMD_Release();
signed int __fastcall AKMD_ChangeFormation(signed int a1);
char *AKMD_ResetDOE();
signed int __fastcall AKMD_GetData(int a1, int a2, int a3, int a4, signed int a5, int a6, int a7, int a8, int a9, int a10, int a11, _DWORD *a12);
signed int __fastcall AKMD_Stop(char *a1);
signed int __fastcall AKMD_Start(const char *a1);
signed int __fastcall AKMD_Init(int a1, int a2);
int __fastcall SaveInt32(FILE *a1, int a2, int a3);
signed int __fastcall SaveInt32vec(FILE *a1, int a2, int a3);
int __fastcall SaveInt16(FILE *a1, int a2, int a3);
signed int __fastcall SaveInt16vec(FILE *a1, int a2, int a3);
int __fastcall SaveParameters(char *filename, int a2);
int __fastcall LoadInt(FILE *a1, const char *a2, int a3);
int __fastcall LoadInt32(FILE *a1, const char *a2, const char **a3);
signed int __fastcall LoadInt32vec(FILE *a1, int a2, int a3);
int __fastcall LoadInt16(FILE *a1, const char *a2, _WORD *a3);
signed int __fastcall LoadInt16vec(FILE *a1, int a2, int a3);
int __fastcall LoadParameters(const char *a1, int a2);
int __fastcall RegisterFormClass(int result);
int __fastcall SetDefaultPRMS(int result);
int __fastcall InitAK8963_Measure(int a1, int a2);
int __fastcall GetMagneticVector(int a1, int a2, int a3, __int16 a4);
signed int __fastcall InitAK8963PRMS(_WORD *a1);
void *__fastcall AKSC_InitDecomp8963(int a1);
int __fastcall AKSC_Decomp8963S3(int a1, signed int a2, int a3, int a4, int a5, int a6, _WORD *a7, int a8, signed __int16 *a9, signed __int16 *a10, _WORD *a11, _WORD *a12, _WORD *a13);
int __fastcall AKSC_Decomp8963(int a1, signed int a2, int a3, int a4, int a5, _WORD *a6, int a7, signed __int16 *a8, signed __int16 *a9, _WORD *a10, _WORD *a11);
int __fastcall AKSC_div16(int a1, int a2);
int __fastcall AKSC_div32(unsigned int a1, unsigned int a2);
int __fastcall AKSC_norm16(int a1);
int __fastcall AKSC_norm32(signed int a1);
signed int __fastcall AKSC_abs16(signed int result);
int __fastcall AKSC_div16f(int a1, int a2, __int16 *a3);
int __fastcall sub_2BBC(int result);
int __fastcall AKSC_SetLayout(void *src, int a2);
int __fastcall AKSC_ThetaFilter(int a1, int a2, int a3);
int __fastcall sub_2CA0(int a1, _WORD *a2);
int __fastcall AKSC_DirectionS3(int a1, int a2, int a3, void *a4, const void *a5, int a6, int a7, int a8, _WORD *a9, _WORD *a10, _WORD *a11, _WORD *a12, _WORD *a13, _WORD *a14, _WORD *a15, _WORD *a16, __int16 *a17, int a18, int a19);
int __fastcall AKSC_VNorm(int a1, int a2, int a3, int a4, int a5);
int __fastcall AKSC_cholSl(int a1, int a2, int a3, int a4, int a5, int a6);
int __fastcall AKSC_cholDc(int a1, int a2, int a3, int a4);
int __fastcall AKSC_fitOnPlane(int a1, int a2, int a3, int a4, _WORD *a5);
signed int __fastcall AKSC_getCoeff(int a1, int a2, int a3, int a4);
int __fastcall sub_3F60(int result, signed int a2, int a3, int a4);
char *__fastcall AKSC_SetHDOELevel(char *result, char *a2, __int16 a3, int a4);
char *__fastcall zzAKSC_InitHDOEProcPrmsS3(int a1, int a2, int a3, __int16 a4, char *a5, __int16 a6);
signed int __fastcall sub_40A0(char *a1, _WORD *a2, _WORD *a3, int a4, int a5, _WORD *a6, _WORD *a7, __int16 a8);
int __fastcall zzAKSC_HDOEProcessS3(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9, _DWORD *a10);
int __fastcall AKSC_InitHFlucCheck(_WORD *a1, const void *a2, int a3);
int __fastcall AKSC_HFlucCheck(int a1, int a2);
int __fastcall AKSC_TransByHbase(int result, int a2, int a3, int a4, _WORD *a5);
int __fastcall AKSC_HOffsetCal(int a1, int a2);
int __fastcall AKSC_sqrt16(int a1);
int __fastcall AKSC_sqrt32(unsigned int a1);
int __fastcall AKSC_angRng(int result, int a2);
unsigned int __fastcall AKSC_sin(int a1);
int __fastcall AKSC_cos(signed int a1);
unsigned int __fastcall sub_4EEC(int a1);
int __fastcall AKSC_atan2(int a1, int a2);
int __fastcall AKSC_invSqrt(signed int a1, _WORD *a2, int a3, __int16 a4);
char *__fastcall AKSC_buffer(char *result, int a2, int a3, int a4);
int __fastcall AKSC_vectorCalc(int result, signed int a2, int a3, int a4, int a5, int a6);
signed int AKSC_GetVersion_Major();
int AKSC_GetVersion_Variation();
signed int AKSC_GetVersion_DateCode();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_5619; // weak
_UNKNOWN unk_5624; // weak
_UNKNOWN unk_5688; // weak
_UNKNOWN unk_5730; // weak
_WORD word_5784[50] =
{
  32767,
  31790,
  30894,
  30070,
  29309,
  28602,
  27945,
  27330,
  26755,
  26214,
  25705,
  25225,
  24770,
  24339,
  23930,
  23541,
  23170,
  22817,
  22479,
  22155,
  21845,
  21548,
  21263,
  20988,
  20724,
  20470,
  20225,
  19988,
  19760,
  19539,
  19326,
  19119,
  18919,
  18725,
  18536,
  18354,
  18176,
  18004,
  17837,
  17674,
  17515,
  17361,
  17211,
  17064,
  16921,
  16782,
  16646,
  16514,
  16384,
  0
}; // idb
_WORD word_57E8[90] =
{
  286,
  858,
  1429,
  2000,
  2571,
  3141,
  3709,
  4277,
  4843,
  5408,
  5971,
  6533,
  7092,
  7649,
  8204,
  8757,
  9306,
  9853,
  10397,
  10938,
  11475,
  12009,
  12539,
  13066,
  13588,
  14107,
  14621,
  15130,
  15635,
  16135,
  16631,
  17121,
  17606,
  18085,
  18559,
  19028,
  19491,
  19947,
  20398,
  20842,
  21280,
  21712,
  22137,
  22555,
  22967,
  23371,
  23768,
  24158,
  24541,
  24916,
  25284,
  25644,
  25996,
  26340,
  26676,
  27004,
  27324,
  27635,
  27938,
  28233,
  28519,
  28796,
  29065,
  29324,
  29575,
  29817,
  30049,
  30273,
  30487,
  30692,
  30888,
  31074,
  31250,
  31418,
  31575,
  31723,
  31862,
  31990,
  32109,
  32218,
  32318,
  32407,
  32487,
  32556,
  32616,
  32666,
  32706,
  32736,
  32756,
  32766
}; // idb
_UNKNOWN I16V_INIT_VALUE; // weak
_UNKNOWN g_opmode; // weak
_UNKNOWN _dso_handle; // weak
__int16 word_6160; // weak
__int16 word_6162; // weak
__int16 word_6164; // weak
__int16 word_6250; // weak
__int16 word_6252; // weak
__int16 word_6254; // weak
__int16 word_6256; // weak
__int16 word_6258; // weak
__int16 word_625A; // weak
_UNKNOWN unk_625C; // weak
int dword_6450; // weak
_UNKNOWN unk_645E; // weak
char byte_646E; // weak
_UNKNOWN unk_646F; // weak
char byte_647F; // weak
__int16 word_6480; // weak
__int16 word_6482; // weak
__int16 word_6484; // weak
__int16 word_6486; // weak
__int16 word_6488; // weak
int dword_64A0; // weak
int dword_64A4; // weak
int dword_64A8; // weak
__int16 word_64B8; // weak
__int16 word_64BC; // weak
__int16 word_64BE; // weak
int dword_64C0; // weak
// extern _UNKNOWN _stack_chk_guard; weak
// extern _UNKNOWN _sF; weak


//----- (00001118) --------------------------------------------------------
int sub_1118()
{
  return _cxa_finalize(&_dso_handle);
}
// 1108: using guessed type int __fastcall _cxa_finalize(_DWORD);

//----- (00001128) --------------------------------------------------------
int getFormation()
{
  return word_64BC;
}
// 64BC: using guessed type __int16 word_64BC;

//----- (00001138) --------------------------------------------------------
__int16 *AKMD_Release()
{
  __int16 *result; // r0@2

  if ( word_64BE )
  {
    word_64BE = 0;
    result = &word_6160;
    word_64B8 = 0;
  }
  return result;
}
// 6160: using guessed type __int16 word_6160;
// 64B8: using guessed type __int16 word_64B8;
// 64BE: using guessed type __int16 word_64BE;

//----- (0000115C) --------------------------------------------------------
signed int __fastcall AKMD_ChangeFormation(signed int a1)
{
  const char *v1; // r1@2
  const char *v2; // r2@2

  if ( !word_64BE )
  {
    v1 = "AKMD2";
    v2 = "AKMD_ChangeFormFactor: PRMS are not initialized.";
LABEL_6:
    _android_log_print(6, v1, v2);
    return -1;
  }
  if ( a1 < 0 || word_64B8 <= a1 )
  {
    v1 = "AKMD2";
    v2 = "AKMD_ChangeFormFactor: Invalid formFactorNumber.";
    goto LABEL_6;
  }
  word_64BC = a1;
  return 0;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 64B8: using guessed type __int16 word_64B8;
// 64BC: using guessed type __int16 word_64BC;
// 64BE: using guessed type __int16 word_64BE;

//----- (000011C0) --------------------------------------------------------
char *AKMD_ResetDOE()
{
  return AKSC_SetHDOELevel((char *)&unk_625C, (char *)&word_6160, 0, 1);
}
// 6160: using guessed type __int16 word_6160;

//----- (000011D8) --------------------------------------------------------
signed int __fastcall AKMD_GetData(int a1, int a2, int a3, int a4, signed int a5, int a6, int a7, int a8, int a9, int a10, int a11, _DWORD *a12)
{
  const char *v15; // r1@4
  const char *v16; // r2@4
  int v24; // r5@9
  signed int result; // r0@9
  __int16 v32; // [sp+0h] [bp-20h]@9
  __int16 v33; // [sp+2h] [bp-1Eh]@9
  __int16 v34; // [sp+4h] [bp-1Ch]@9
  __int16 v35; // [sp+6h] [bp-1Ah]@9
  __int16 v36; // [sp+8h] [bp-18h]@9
  __int16 v37; // [sp+Ah] [bp-16h]@9
  __int16 v38; // [sp+Ch] [bp-14h]@9
  __int16 v39; // [sp+Eh] [bp-12h]@9

  _R5 = a1;
  _R4 = a3;
  _R3 = a2;
  if ( !word_64BE )
  {
    _android_log_print(6, "AKMD2", "AKMD_SaveMag: PRMS are not initialized.", a2);
    return -1;
  }
  if ( (unsigned int)(a1 + 3219128) > 0x623D70 )
  {
    _R3 = a1;
    v15 = "AKMD2";
    v16 = "AKMD_SaveMag: Invalid ix value (%d).";
LABEL_18:
    _android_log_print(6, v15, v16, _R3, *(_DWORD *)&v32, *(_DWORD *)&v34, *(_DWORD *)&v36, *(_DWORD *)&v38);
    return -1;
  }
  if ( (unsigned int)(a2 + 3219128) > 0x623D70 )
  {
    v15 = "AKMD2";
    v16 = "AKMD_SaveMag: Invalid iy value (%d).";
    goto LABEL_18;
  }
  if ( (unsigned int)(a3 + 3219128) > 0x623D70 )
  {
    _R3 = a3;
    v15 = "AKMD2";
    v16 = "AKMD_SaveMag: Invalid iz value (%d).";
    goto LABEL_18;
  }
  __asm
  {
    VMOV            S4, R3
    VCVT.F64.S32    D17, S4
    VLDR            D16, =0.010172526
    VMOV            S6, R5
    VMOV            S0, R4
  }
  v32 = 1;
  __asm
  {
    VMUL.F64        D17, D17, D16
    VCVT.F64.S32    D1, S6
    VCVTR.S32.F64   S1, D17
    VCVT.F64.S32    D17, S0
    VMOV            R5, S1
  }
  v35 = _R5;
  __asm
  {
    VMUL.F64        D1, D1, D16
    VMUL.F64        D16, D17, D16
    VCVTR.S32.F64   S5, D1
    VCVTR.S32.F64   S15, D16
    VMOV            R0, S5
  }
  v36 = (unsigned __int16)_R5 >> 8;
  v33 = _R0;
  v34 = (unsigned __int16)_R0 >> 8;
  __asm { VMOV            R3, S15 }
  v39 = 16;
  v37 = (unsigned __int8)_R3;
  v38 = (unsigned __int16)_R3 >> 8;
  v24 = (signed __int16)getFormation();
  result = (unsigned __int16)GetMagneticVector((int)&v32, (int)&word_6160, v24, a5 / 10);
  if ( !(_WORD)result )
  {
    _R2 = word_6250;
    __asm
    {
      VMOV            S4, R2
      VCVT.F64.S32    D20, S4
      VLDR            D16, =0.06
      VMUL.F64        D20, D20, D16
      VCVT.F32.F64    S2, D20
      VSTR            S2, [R1]
    }
    _LR = word_6252;
    __asm
    {
      VMOV            S1, LR
      VCVT.F64.S32    D19, S1
      VMUL.F64        D19, D19, D16
      VCVT.F32.F64    S0, D19
      VSTR            S0, [R3]
    }
    _R12 = word_6254;
    __asm
    {
      VMOV            S15, R12
      VCVT.F64.S32    D18, S15
      VMUL.F64        D18, D18, D16
      VCVT.F32.F64    S13, D18
      VSTR            S13, [R2]
    }
    _LR = word_6160 + dword_64A0;
    __asm
    {
      VMOV            S14, LR
      VCVT.F64.S32    D6, S14
      VMUL.F64        D6, D6, D16
      VCVT.F32.F64    S9, D6
      VSTR            S9, [R2]
    }
    _R3 = word_6162 + dword_64A4;
    __asm
    {
      VMOV            S11, R3
      VCVT.F64.S32    D4, S11
      VMUL.F64        D4, D4, D16
      VCVT.F32.F64    S10, D4
      VSTR            S10, [R2]
    }
    _R12 = word_6164 + dword_64A8;
    __asm
    {
      VMOV            S7, R12
      VCVT.F64.S32    D17, S7
      VMUL.F64        D16, D17, D16
      VCVT.F32.F64    S3, D16
      VSTR            S3, [R3]
    }
    *a12 = dword_6450;
    return result;
  }
  if ( (signed __int16)result != 1
    && (signed __int16)result != 2
    && (signed __int16)result != 4
    && (signed __int16)result != 8
    && (signed __int16)result != 16 )
  {
    _R3 = (signed __int16)result;
    if ( (signed __int16)result != 32 && (signed __int16)result != 64 )
    {
      v15 = "AKMD2";
      v16 = "GetMagneticVector has failed (0x%04X).\n";
      goto LABEL_18;
    }
  }
  return -1;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 6160: using guessed type __int16 word_6160;
// 6162: using guessed type __int16 word_6162;
// 6164: using guessed type __int16 word_6164;
// 6250: using guessed type __int16 word_6250;
// 6252: using guessed type __int16 word_6252;
// 6254: using guessed type __int16 word_6254;
// 6450: using guessed type int dword_6450;
// 64A0: using guessed type int dword_64A0;
// 64A4: using guessed type int dword_64A4;
// 64A8: using guessed type int dword_64A8;
// 64BE: using guessed type __int16 word_64BE;

//----- (00001428) --------------------------------------------------------
signed int __fastcall AKMD_Stop(char *a1)
{
  const char *v1; // r1@2
  const char *v2; // r2@2

  if ( word_64BE )
  {
    if ( a1 )
    {
      if ( (unsigned __int16)SaveParameters(a1, (int)&word_6160) )
        return 0;
      v1 = "AKMD2";
      v2 = "AKMD_Stop: Setting file cannot be written.";
    }
    else
    {
      v1 = "AKMD2";
      v2 = "AKMD_Start: path can't be NULL.";
    }
  }
  else
  {
    v1 = "AKMD2";
    v2 = "AKMD_Start: PRMS are not initialized.";
  }
  _android_log_print(6, v1, v2);
  return -1;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 6160: using guessed type __int16 word_6160;
// 64BE: using guessed type __int16 word_64BE;

//----- (00001490) --------------------------------------------------------
signed int __fastcall AKMD_Start(const char *a1)
{
  const char *v1; // r1@2
  const char *v2; // r2@2
  int v3; // r1@5
  signed int result; // r0@7

  if ( !word_64BE )
  {
    v1 = "AKMD2";
    v2 = "AKMD_Start: PRMS are not initialized.";
LABEL_9:
    _android_log_print(6, v1, v2);
    return -1;
  }
  if ( !a1 )
  {
    v1 = "AKMD2";
    v2 = "AKMD_Start: path can't be NULL.";
    goto LABEL_9;
  }
  if ( !(unsigned __int16)LoadParameters(a1, (int)&word_6160) )
    SetDefaultPRMS((int)&word_6160);
  result = (unsigned __int16)InitAK8963_Measure((int)&word_6160, v3);
  if ( (_WORD)result )
  {
    v1 = "AKMD2";
    v2 = "AKMD_Start: Start error.";
    goto LABEL_9;
  }
  return result;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 6160: using guessed type __int16 word_6160;
// 64BE: using guessed type __int16 word_64BE;

//----- (0000150C) --------------------------------------------------------
signed int __fastcall AKMD_Init(int a1, int a2)
{
  __int16 v2; // r6@1
  int v3; // r5@1
  const char *v4; // r1@2
  const char *v5; // r2@2
  signed int result; // r0@5
  __int16 v7; // r1@6

  v2 = a1;
  v3 = a2;
  if ( a1 != 1 )
  {
    v4 = "AKMD2";
    v5 = "AKMD_Init: Invalid formFactorNumber.";
LABEL_5:
    _android_log_print(6, v4, v5);
    return -1;
  }
  if ( !a2 )
  {
    v4 = "AKMD2";
    v5 = "AKMD_Init: regs can't be NULL.";
    goto LABEL_5;
  }
  *(_WORD *)(a2 + 2) = 128;
  *(_WORD *)(a2 + 4) = 128;
  *(_WORD *)(a2 + 6) = 128;
  *(_WORD *)a2 = 72;
  AKMD_Release();
  memset(&word_6160, 0, 0x35Cu);
  word_64B8 = v2;
  InitAK8963PRMS(&word_6160);
  word_6256 = *(_WORD *)(v3 + 2);
  word_6258 = *(_WORD *)(v3 + 4);
  v7 = *(_WORD *)(v3 + 6);
  word_6480 = 8963;
  word_625A = v7;
  word_6482 = *(_WORD *)v3;
  word_6484 = *(_WORD *)(v3 + 2);
  word_6486 = *(_WORD *)(v3 + 4);
  word_6488 = *(_WORD *)(v3 + 6);
  strlcpy(&unk_645E, "ASAHIKASEI", 16);
  byte_646E = 0;
  strlcpy(&unk_646F, "OPPO_63_R601", 16);
  result = 0;
  byte_647F = 0;
  word_64BE = v2;
  return result;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 1078: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6160: using guessed type __int16 word_6160;
// 6256: using guessed type __int16 word_6256;
// 6258: using guessed type __int16 word_6258;
// 625A: using guessed type __int16 word_625A;
// 646E: using guessed type char byte_646E;
// 647F: using guessed type char byte_647F;
// 6480: using guessed type __int16 word_6480;
// 6482: using guessed type __int16 word_6482;
// 6484: using guessed type __int16 word_6484;
// 6486: using guessed type __int16 word_6486;
// 6488: using guessed type __int16 word_6488;
// 64B8: using guessed type __int16 word_64B8;
// 64BE: using guessed type __int16 word_64BE;

//----- (000015F0) --------------------------------------------------------
int __fastcall SaveInt32(FILE *a1, int a2, int a3)
{
  int result; // r0@2

  if ( fprintf(a1, "%s = %ld\n", a2, a3, a1, a2) < 0 )
  {
    _android_log_print(6, "AKMD2", "%s: printf (%s) error.");
    LOWORD(result) = 0;
  }
  else
  {
    LOWORD(result) = 1;
  }
  return (signed __int16)result;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00001634) --------------------------------------------------------
signed int __fastcall SaveInt32vec(FILE *a1, int a2, int a3)
{
  FILE *v3; // r5@1
  int v4; // r4@1
  int v5; // r7@1
  int v6; // r8@1
  signed int v7; // r6@3
  signed int result; // r0@5
  char s; // [sp+4h] [bp-5Ch]@1
  int v10; // [sp+44h] [bp-1Ch]@1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v10 = _stack_chk_guard;
  snprintf(&s, 0x40u, "%s.x", a2);
  v6 = SaveInt32(v3, (int)&s, *(_DWORD *)v4);
  snprintf(&s, 0x40u, "%s.y", v5);
  v7 = v6 && (unsigned __int16)SaveInt32(v3, (int)&s, *(_DWORD *)(v4 + 4));
  snprintf(&s, 0x40u, "%s.z", v5);
  result = v7;
  if ( v7 )
  {
    result = (signed __int16)SaveInt32(v3, (int)&s, *(_DWORD *)(v4 + 8));
    if ( (_WORD)result )
      result = 1;
  }
  if ( v10 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 109C: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (000016E4) --------------------------------------------------------
int __fastcall SaveInt16(FILE *a1, int a2, int a3)
{
  int v3; // r4@1
  int result; // r0@2

  v3 = a2;
  if ( fprintf(a1, "%s = %d\n", a2, a3, a1, a2) < 0 )
  {
    _android_log_print(6, "AKMD2", "%s: printf (%s) error.", "SaveInt16", v3);
    LOWORD(result) = 0;
  }
  else
  {
    LOWORD(result) = 1;
  }
  return (signed __int16)result;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00001728) --------------------------------------------------------
signed int __fastcall SaveInt16vec(FILE *a1, int a2, int a3)
{
  FILE *v3; // r4@1
  int v4; // r5@1
  int v5; // r7@1
  int v6; // r8@1
  signed int v7; // r6@3
  signed int result; // r0@5
  char s; // [sp+4h] [bp-5Ch]@1
  int v10; // [sp+44h] [bp-1Ch]@1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v10 = _stack_chk_guard;
  snprintf(&s, 0x40u, "%s.x", a2);
  v6 = SaveInt16(v3, (int)&s, *(_WORD *)v4);
  snprintf(&s, 0x40u, "%s.y", v5);
  v7 = v6 && (unsigned __int16)SaveInt16(v3, (int)&s, *(_WORD *)(v4 + 2));
  snprintf(&s, 0x40u, "%s.z", v5);
  result = v7;
  if ( v7 )
  {
    result = (signed __int16)SaveInt16(v3, (int)&s, *(_WORD *)(v4 + 4));
    if ( (_WORD)result )
      result = 1;
  }
  if ( v10 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 109C: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (000017E0) --------------------------------------------------------
int __fastcall SaveParameters(char *filename, int a2)
{
  int v2; // r6@1
  char *v3; // r9@1
  FILE *v4; // r5@1
  int *v5; // r0@3
  char *v6; // r0@3
  int *v7; // r0@4
  char *v8; // r0@4
  int v9; // r8@5
  int v10; // r7@7
  int v11; // r7@11
  unsigned __int16 v12; // r6@15
  FILE *v13; // r0@17
  int v14; // r5@17
  int *v15; // r0@19
  char *v16; // r0@19
  int *v17; // r0@20
  char *v18; // r0@20
  int *v19; // r0@23
  char *v20; // r0@23
  int *v21; // r0@24
  char *v22; // r0@24
  int result; // r0@28
  char s; // [sp+14h] [bp-64h]@5
  int v25; // [sp+54h] [bp-24h]@1

  v2 = a2;
  v3 = filename;
  v25 = _stack_chk_guard;
  v4 = fopen(filename, "w");
  if ( !v4 )
  {
    if ( g_opmode )
    {
      v7 = (int *)_errno();
      v8 = strerror(*v7);
      fprintf((FILE *)((char *)&_sF + 168), "%s:%d %s Error (%s).\n", "SaveParameters", 210, "fopen", v8);
    }
    else
    {
      v5 = (int *)_errno();
      v6 = strerror(*v5);
      LOWORD(v4) = 0;
      _android_log_print(6, "AKMD2", "%s:%d %s Error (%s).", "SaveParameters", 210, "fopen", v6);
    }
    goto LABEL_28;
  }
  snprintf(&s, 0x40u, "HSUC_HDST_FORM%d", 0);
  v9 = SaveInt16(v4, (int)&s, *(_WORD *)(v2 + 756));
  snprintf(&s, 0x40u, "HSUC_HO_FORM%d", 0);
  v10 = v9 && (unsigned __int16)SaveInt16vec(v4, (int)&s, v2 + 6);
  snprintf(&s, 0x40u, "HFLUCV_HREF_FORM%d", 0);
  v11 = v10 && (unsigned __int16)SaveInt16vec(v4, (int)&s, v2 + 30);
  snprintf(&s, 0x40u, "HSUC_HBASE_FORM%d", 0);
  v12 = v11 && (unsigned __int16)SaveInt32vec(v4, (int)&s, v2 + 844);
  v13 = v4;
  v14 = v12;
  if ( fclose(v13) )
  {
    v14 = g_opmode;
    if ( g_opmode )
    {
      v17 = (int *)_errno();
      v18 = strerror(*v17);
      v14 = 0;
      fprintf((FILE *)((char *)&_sF + 168), "%s:%d %s Error (%s).\n", "SaveParameters", 229, "fclose", v18);
    }
    else
    {
      v15 = (int *)_errno();
      v16 = strerror(*v15);
      _android_log_print(6, "AKMD2", "%s:%d %s Error (%s).", "SaveParameters", 229, "fclose", v16);
    }
  }
  if ( chmod(v3, 0x1B0u) )
  {
    if ( g_opmode )
    {
      v21 = (int *)_errno();
      v22 = strerror(*v21);
      fprintf((FILE *)((char *)&_sF + 168), "%s:%d %s Error (%s).\n", "SaveParameters", 234, "chmod", v22);
    }
    else
    {
      v19 = (int *)_errno();
      v20 = strerror(*v19);
      _android_log_print(6, "AKMD2", "%s:%d %s Error (%s).", "SaveParameters", 234, "chmod", v20);
    }
  }
  else if ( v14 )
  {
    LOWORD(v4) = 1;
    goto LABEL_28;
  }
  LOWORD(v4) = 0;
  _android_log_print(6, "AKMD2", "%s: failed.", "SaveParameters");
LABEL_28:
  result = (signed __int16)v4;
  if ( v25 != _stack_chk_guard )
    _stack_chk_fail((signed __int16)v4);
  return result;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 109C: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 10B4: using guessed type int _errno(void);

//----- (00001AA8) --------------------------------------------------------
int __fastcall LoadInt(FILE *a1, const char *a2, int a3)
{
  FILE *v3; // r7@1
  int v4; // r6@1
  const char *v5; // r5@1
  int result; // r0@4
  char s; // [sp+Ch] [bp-5Ch]@1
  int v8; // [sp+4Ch] [bp-1Ch]@1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v8 = _stack_chk_guard;
  memset(&s, 0, 0x40u);
  if ( fscanf(v3, "%63s = %11d", &s, v4) == 2 )
  {
    if ( !strncmp(&s, v5, 0x40u) )
    {
      LOWORD(result) = 1;
      goto LABEL_7;
    }
    _android_log_print(6, "AKMD2", "%s: strncmp (%s) error.", "LoadInt", v5);
  }
  else
  {
    _android_log_print(6, "AKMD2", "%s: scanf error.", "LoadInt");
  }
  LOWORD(result) = 0;
LABEL_7:
  result = (signed __int16)result;
  if ( v8 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 109C: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00001B50) --------------------------------------------------------
int __fastcall LoadInt32(FILE *a1, const char *a2, const char **a3)
{
  const char **v3; // r4@1
  int result; // r0@1
  const char *v5; // [sp+4h] [bp-Ch]@1

  v5 = a2;
  v3 = a3;
  LOWORD(result) = LoadInt(a1, a2, (int)&v5);
  if ( (signed __int16)result == 1 )
    *v3 = v5;
  else
    LOWORD(result) = 0;
  return (signed __int16)result;
}

//----- (00001B6C) --------------------------------------------------------
signed int __fastcall LoadInt32vec(FILE *a1, int a2, int a3)
{
  FILE *v3; // r4@1
  int v4; // r5@1
  int v5; // r7@1
  int v6; // r8@1
  signed int v7; // r6@3
  signed int result; // r0@5
  char s; // [sp+4h] [bp-5Ch]@1
  int v10; // [sp+44h] [bp-1Ch]@1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v10 = _stack_chk_guard;
  snprintf(&s, 0x40u, "%s.x", a2);
  v6 = LoadInt32(v3, &s, (const char **)v4);
  snprintf(&s, 0x40u, "%s.y", v5);
  v7 = v6 && (unsigned __int16)LoadInt32(v3, &s, (const char **)(v4 + 4));
  snprintf(&s, 0x40u, "%s.z", v5);
  result = v7;
  if ( v7 )
  {
    result = (signed __int16)LoadInt32(v3, &s, (const char **)(v4 + 8));
    if ( (_WORD)result )
      result = 1;
  }
  if ( v10 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 109C: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00001C20) --------------------------------------------------------
int __fastcall LoadInt16(FILE *a1, const char *a2, _WORD *a3)
{
  _WORD *v3; // r4@1
  int result; // r0@1
  const char *v5; // [sp+4h] [bp-Ch]@1

  v5 = a2;
  v3 = a3;
  LOWORD(result) = LoadInt(a1, a2, (int)&v5);
  if ( (signed __int16)result == 1 )
    *v3 = (_WORD)v5;
  else
    LOWORD(result) = 0;
  return (signed __int16)result;
}

//----- (00001C3C) --------------------------------------------------------
signed int __fastcall LoadInt16vec(FILE *a1, int a2, int a3)
{
  FILE *v3; // r4@1
  int v4; // r5@1
  int v5; // r7@1
  int v6; // r8@1
  signed int v7; // r6@3
  signed int result; // r0@5
  char s; // [sp+4h] [bp-5Ch]@1
  int v10; // [sp+44h] [bp-1Ch]@1

  v3 = a1;
  v4 = a3;
  v5 = a2;
  v10 = _stack_chk_guard;
  snprintf(&s, 0x40u, "%s.x", a2);
  v6 = LoadInt16(v3, &s, (_WORD *)v4);
  snprintf(&s, 0x40u, "%s.y", v5);
  v7 = v6 && (unsigned __int16)LoadInt16(v3, &s, (_WORD *)(v4 + 2));
  snprintf(&s, 0x40u, "%s.z", v5);
  result = v7;
  if ( v7 )
  {
    result = (signed __int16)LoadInt16(v3, &s, (_WORD *)(v4 + 4));
    if ( (_WORD)result )
      result = 1;
  }
  if ( v10 != _stack_chk_guard )
    _stack_chk_fail(result);
  return result;
}
// 109C: using guessed type int __fastcall _stack_chk_fail(_DWORD);

//----- (00001CEC) --------------------------------------------------------
int __fastcall LoadParameters(const char *a1, int a2)
{
  int v2; // r6@1
  FILE *v3; // r5@1
  int *v4; // r0@3
  char *v5; // r0@3
  int *v6; // r0@4
  char *v7; // r0@4
  int v8; // r0@5
  int v9; // r8@5
  int v10; // r7@7
  int v11; // r7@11
  int v12; // r6@15
  int *v13; // r0@19
  char *v14; // r0@19
  int *v15; // r0@20
  char *v16; // r0@20
  int result; // r0@24
  __int16 v18; // [sp+12h] [bp-5Eh]@5
  char s; // [sp+14h] [bp-5Ch]@5
  int v20; // [sp+54h] [bp-1Ch]@1

  v2 = a2;
  v20 = _stack_chk_guard;
  v3 = fopen(a1, "r");
  if ( !v3 )
  {
    if ( g_opmode )
    {
      v6 = (int *)_errno();
      v7 = strerror(*v6);
      fprintf((FILE *)((char *)&_sF + 168), "%s:%d %s Error (%s).\n", "LoadParameters", 45, "fopen", v7);
    }
    else
    {
      v4 = (int *)_errno();
      v5 = strerror(*v4);
      LOWORD(v3) = 0;
      _android_log_print(6, "AKMD2", "%s:%d %s Error (%s).", "LoadParameters", 45, "fopen", v5);
    }
    goto LABEL_24;
  }
  snprintf(&s, 0x40u, "HSUC_HDST_FORM%d", 0);
  v18 = 0;
  v8 = LoadInt16(v3, &s, &v18);
  *(_DWORD *)(v2 + 756) = v18;
  v9 = v8;
  snprintf(&s, 0x40u, "HSUC_HO_FORM%d", 0);
  v10 = v9 && (unsigned __int16)LoadInt16vec(v3, (int)&s, v2 + 6);
  snprintf(&s, 0x40u, "HFLUCV_HREF_FORM%d", 0);
  v11 = v10 && (unsigned __int16)LoadInt16vec(v3, (int)&s, v2 + 30);
  snprintf(&s, 0x40u, "HSUC_HBASE_FORM%d", 0);
  LOWORD(v12) = v11 && (unsigned __int16)LoadInt32vec(v3, (int)&s, v2 + 844);
  v12 = (unsigned __int16)v12;
  if ( fclose(v3) )
  {
    if ( g_opmode )
    {
      v15 = (int *)_errno();
      v16 = strerror(*v15);
      fprintf((FILE *)((char *)&_sF + 168), "%s:%d %s Error (%s).\n", "LoadParameters", 69, "fclose", v16);
    }
    else
    {
      v13 = (int *)_errno();
      v14 = strerror(*v13);
      _android_log_print(6, "AKMD2", "%s:%d %s Error (%s).", "LoadParameters", 69, "fclose", v14);
    }
  }
  else if ( v12 )
  {
    LOWORD(v3) = 1;
    goto LABEL_24;
  }
  LOWORD(v3) = 0;
  _android_log_print(6, "AKMD2", "%s: failed.", "LoadParameters");
LABEL_24:
  result = (signed __int16)v3;
  if ( v20 != _stack_chk_guard )
    _stack_chk_fail((signed __int16)v3);
  return result;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);
// 109C: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 10B4: using guessed type int _errno(void);

//----- (00001F2C) --------------------------------------------------------
int __fastcall RegisterFormClass(int result)
{
  dword_64C0 = result;
  return result;
}
// 64C0: using guessed type int dword_64C0;

//----- (00001F38) --------------------------------------------------------
int __fastcall SetDefaultPRMS(int result)
{
  *(_DWORD *)(result + 756) = 0;
  *(_WORD *)(result + 6) = 0;
  *(_WORD *)(result + 8) = 0;
  *(_WORD *)(result + 10) = 0;
  *(_WORD *)(result + 30) = 0;
  *(_WORD *)(result + 32) = 0;
  *(_WORD *)(result + 34) = 0;
  *(_DWORD *)(result + 844) = 0;
  *(_DWORD *)(result + 848) = 0;
  *(_DWORD *)(result + 852) = 0;
  return result;
}

//----- (00001F58) --------------------------------------------------------
int __fastcall InitAK8963_Measure(int a1, int a2)
{
  int v2; // r4@1
  int (__cdecl *v3)(int, int); // r3@2
  __int16 v4; // r7@3
  int v5; // r6@5
  int v6; // r12@5
  int v7; // r3@5
  int v8; // r7@5
  int v9; // r1@5
  int v10; // r2@5
  int result; // r0@5

  v2 = a1;
  if ( dword_64C0 && (v3 = *(int (__cdecl **)(int, int))(dword_64C0 + 8)) != 0 )
    v4 = v3(a1, a2);
  else
    v4 = 0;
  *(_WORD *)(v2 + 760) = v4;
  v5 = v2 + 6 * v4;
  memcpy((void *)v2, (const void *)(v5 + 6), 6u);
  v6 = v2 + 832;
  *(_DWORD *)(v2 + 12) = *(_WORD *)(v5 + 6);
  *(_DWORD *)(v2 + 16) = *(_WORD *)(v5 + 8);
  *(_DWORD *)(v2 + 20) = *(_WORD *)(v5 + 10);
  v7 = *(_DWORD *)(v2 + 4 * v4 + 756);
  v8 = v2 + 12 * v4 + 844;
  *(_DWORD *)(v2 + 752) = v7;
  v9 = *(_DWORD *)(v8 + 4);
  v10 = *(_DWORD *)(v8 + 8);
  *(_DWORD *)v6 = *(_DWORD *)v8;
  *(_DWORD *)(v6 + 4) = v9;
  *(_DWORD *)(v6 + 8) = v10;
  AKSC_InitDecomp8963(v2 + 44);
  zzAKSC_InitHDOEProcPrmsS3(v2 + 252, 0, 0, 1, (char *)v2, *(_DWORD *)(v2 + 752));
  AKSC_InitHFlucCheck((_WORD *)(v2 + 36), (const void *)(v2 + 6 * *(_WORD *)(v2 + 760) + 30), 2500);
  result = 0;
  *(_WORD *)(v2 + 762) = 0;
  *(_WORD *)(v2 + 764) = 0;
  return result;
}
// 64C0: using guessed type int dword_64C0;

//----- (00002004) --------------------------------------------------------
int __fastcall GetMagneticVector(int a1, int a2, int a3, __int16 a4)
{
  int v4; // r8@1
  int v5; // r4@1
  int v6; // r10@1
  int v7; // r7@1
  __int16 v8; // r11@1
  int v9; // r0@1
  int v10; // r1@1
  int v11; // r2@1
  int v12; // r9@2
  int v13; // r3@3
  int v14; // r2@3
  int v15; // r1@3
  int v16; // r2@3
  signed __int16 v17; // r5@6
  signed int v18; // r5@15
  __int16 v19; // r3@26
  int v20; // r0@27
  int v21; // r3@33
  int v22; // r0@33
  int v23; // r1@33
  int v24; // r2@33
  int v25; // r3@33
  int v26; // r1@33
  int v27; // r2@33
  int v29; // [sp+24h] [bp-4Ch]@1
  int v30; // [sp+28h] [bp-48h]@1
  int v31; // [sp+2Ch] [bp-44h]@1
  __int16 v32; // [sp+30h] [bp-40h]@1
  __int16 v33; // [sp+32h] [bp-3Eh]@1
  __int16 v34; // [sp+34h] [bp-3Ch]@1
  int v35; // [sp+38h] [bp-38h]@1
  __int16 v36; // [sp+3Ch] [bp-34h]@1
  __int16 v37; // [sp+3Eh] [bp-32h]@1
  __int16 v38; // [sp+40h] [bp-30h]@1
  __int16 v39; // [sp+42h] [bp-2Eh]@1
  __int16 v40; // [sp+44h] [bp-2Ch]@1
  __int16 v41; // [sp+46h] [bp-2Ah]@1

  v4 = a2 + 832;
  v5 = a2;
  v6 = a1;
  v7 = a3;
  v8 = a4;
  v35 = 0;
  v36 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v41 = 0;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  v9 = *(_DWORD *)(a2 + 832);
  v10 = *(_DWORD *)(a2 + 836);
  v11 = *(_DWORD *)(v4 + 8);
  v37 = 0;
  v29 = v9;
  v30 = v10;
  v31 = v11;
  if ( (signed int)*(_WORD *)(v5 + 762) > 0 )
  {
    v12 = *(_WORD *)(v5 + 762) - 1;
    *(_WORD *)(v5 + 762) = v12;
    if ( !v12 )
    {
      memcpy((void *)v5, (const void *)(v5 + 6 * *(_WORD *)(v5 + 760) + 6), 6u);
      v13 = *(_WORD *)(v5 + 760);
      v14 = v5 + 6 * v13;
      *(_DWORD *)(v5 + 12) = *(_WORD *)(v14 + 6);
      *(_DWORD *)(v5 + 16) = *(_WORD *)(v14 + 8);
      *(_DWORD *)(v5 + 20) = *(_WORD *)(v14 + 10);
      *(_DWORD *)(v5 + 752) = *(_DWORD *)(v5 + 4 * v13 + 756);
      v15 = *(_DWORD *)(v5 + 12 * v13 + 848);
      v16 = *(_DWORD *)(v5 + 12 * v13 + 852);
      *(_DWORD *)v4 = *(_DWORD *)(v5 + 12 * v13 + 844);
      *(_DWORD *)(v4 + 4) = v15;
      *(_DWORD *)(v4 + 8) = v16;
      AKSC_InitDecomp8963(v5 + 44);
      zzAKSC_InitHDOEProcPrmsS3(v5 + 252, 0, 0, 1, (char *)v5, *(_DWORD *)(v5 + 752));
      AKSC_InitHFlucCheck((_WORD *)(v5 + 36), (const void *)(v5 + 6 * *(_WORD *)(v5 + 760) + 30), 2500);
    }
  }
  if ( !(unsigned __int16)AKSC_Decomp8963(
                            v6,
                            *(_WORD *)(v5 + 236),
                            v5 + 246,
                            v5 + 44,
                            v5 + 832,
                            (_WORD *)(v5 + 238),
                            (int)&v32,
                            &v41,
                            &v40,
                            &v39,
                            &v38) )
    return 128;
  if ( *(_WORD *)(v5 + 760) != v7 )
  {
    *(_WORD *)(v5 + 764) = 0;
    v17 = 1;
    *(_WORD *)(v5 + 760) = v7;
    *(_WORD *)(v5 + 762) = 8;
    return v17;
  }
  if ( v40 == 1 )
    return 2;
  if ( v39 == 1 )
  {
    if ( (signed int)*(_WORD *)(v5 + 762) <= 0 )
    {
      AKSC_SetHDOELevel((char *)(v5 + 252), (char *)v5, 0, 1);
      *(_DWORD *)(v5 + 752) = 0;
    }
    return 4;
  }
  if ( v38 != 1 )
  {
    if ( (signed int)*(_WORD *)(v5 + 762) <= 0 )
    {
      if ( (signed __int16)AKSC_HFlucCheck(v5 + 36, v5 + 44) == 1 )
      {
        v17 = 32;
        AKSC_SetHDOELevel((char *)(v5 + 252), (char *)v5, 0, 1);
        *(_DWORD *)(v5 + 752) = 0;
        return v17;
      }
      v19 = *(_WORD *)(v5 + 764) - 1;
      *(_WORD *)(v5 + 764) = v19;
      if ( v19 <= 0 )
      {
        v20 = (signed __int16)zzAKSC_HDOEProcessS3(
                                v5 + 766,
                                v5 + 783,
                                v5 + 800,
                                v5 + 252,
                                v5 + 44,
                                *(_WORD *)(v5 + 238),
                                0,
                                1,
                                v5,
                                (_DWORD *)(v5 + 752));
        if ( (signed __int16)v20 == -32768 )
        {
          if ( g_opmode )
            fprintf((FILE *)((char *)&_sF + 168), "%s:%d Error.\n", "GetMagneticVector", 653);
          else
            _android_log_print(6, "AKMD2", "%s:%d Error.", "GetMagneticVector", 653);
          return 128;
        }
        if ( v20 > 0 )
        {
          memcpy((void *)(v5 + 6 * *(_WORD *)(v5 + 760) + 6), (const void *)v5, 6u);
          v21 = *(_WORD *)v5;
          v22 = *(_WORD *)(v5 + 760);
          v23 = *(_WORD *)(v5 + 4);
          *(_DWORD *)(v5 + 16) = *(_WORD *)(v5 + 2);
          v24 = *(_DWORD *)(v5 + 752);
          *(_DWORD *)(v5 + 12) = v21;
          *(_DWORD *)(v5 + 20) = v23;
          *(_DWORD *)(v5 + 4 * v22 + 756) = v24;
          memcpy((void *)(v5 + 6 * *(_WORD *)(v5 + 760) + 30), (const void *)(v5 + 36), 6u);
          v25 = v5 + 12 * *(_WORD *)(v5 + 760) + 844;
          v26 = *(_DWORD *)(v5 + 836);
          v27 = *(_DWORD *)(v5 + 840);
          *(_DWORD *)v25 = *(_DWORD *)(v5 + 832);
          *(_DWORD *)(v25 + 4) = v26;
          *(_DWORD *)(v25 + 8) = v27;
        }
        *(_WORD *)(v5 + 764) = v8;
      }
    }
    if ( (unsigned __int16)AKSC_VNorm((int)&v32, v5, v5 + 24, 833, v5 + 240) )
      v17 = 0;
    else
      v17 = 64;
    return v17;
  }
  AKSC_TransByHbase((int)&v29, v5 + 832, v5, v5 + 12, &v37);
  if ( v37 == 1 )
    v18 = 8;
  else
    v18 = 0;
  AKSC_InitHFlucCheck((_WORD *)(v5 + 36), &v35, 2500);
  if ( (signed int)*(_WORD *)(v5 + 762) <= 0 )
  {
    AKSC_SetHDOELevel((char *)(v5 + 252), (char *)v5, 0, 1);
    *(_DWORD *)(v5 + 752) = 0;
  }
  if ( v18 )
    v17 = 24;
  else
    v17 = 16;
  return v17;
}
// 1054: using guessed type int _android_log_print(_DWORD, _DWORD, const char *, ...);

//----- (00002358) --------------------------------------------------------
signed int __fastcall InitAK8963PRMS(_WORD *a1)
{
  _WORD *v1; // r4@1
  signed int result; // r0@1

  v1 = a1;
  memset(a1, 0, 0x35Cu);
  result = 833;
  v1[12] = 833;
  v1[13] = 833;
  v1[14] = 833;
  v1[118] = 8;
  return result;
}

//----- (0000237C) --------------------------------------------------------
void *__fastcall AKSC_InitDecomp8963(int a1)
{
  int v1; // r6@1
  int v2; // r4@1
  void *v3; // r0@2
  void *result; // r0@2

  v1 = a1;
  v2 = 0;
  do
  {
    v3 = (void *)(v1 + v2);
    v2 += 6;
    result = memcpy(v3, &I16V_INIT_VALUE, 6u);
  }
  while ( v2 != 192 );
  return result;
}

//----- (000023A4) --------------------------------------------------------
int __fastcall AKSC_Decomp8963S3(int a1, signed int a2, int a3, int a4, int a5, int a6, _WORD *a7, int a8, signed __int16 *a9, signed __int16 *a10, _WORD *a11, _WORD *a12, _WORD *a13)
{
  int v13; // r9@1
  int v14; // r5@2
  signed int v15; // r2@4
  signed int v16; // r5@7
  signed __int16 v17; // r5@11
  signed __int16 v18; // r2@14
  signed int v19; // r5@17
  int v20; // r1@21
  int v21; // r2@21
  __int16 v22; // r8@21
  int v24; // r0@21
  int v25; // r8@21
  signed int v32; // r9@22
  signed int v33; // r9@23
  int v34; // r12@27
  __int16 v35; // r1@27
  int v36; // r9@27
  int v37; // r8@27
  __int16 v38; // r0@27
  __int16 v39; // r6@27
  __int16 v40; // r2@27
  __int16 v41; // r5@27
  int v42; // r7@30
  int v43; // r3@33
  int v44; // r0@34
  int v45; // r3@34
  int v46; // r2@35
  signed int v47; // r5@35
  signed int v48; // r6@36
  int v49; // r6@37
  int v50; // r3@44
  __int16 *v51; // r7@44
  unsigned int v52; // r5@45
  int v53; // r6@45
  char *v54; // r12@45
  int v55; // r0@45
  int v56; // r8@46
  int v57; // t1@46
  int v58; // r11@46
  int v59; // r12@47
  int v60; // r2@49
  int v61; // r2@49
  signed int v62; // r2@50
  int v63; // r1@54
  int v64; // r2@54
  int v65; // r3@56
  signed int v66; // r2@58
  int v67; // r2@61
  int v68; // r3@65
  int v69; // r12@65
  int v70; // r7@65
  int v71; // r6@65
  signed int v72; // r1@65
  signed int v73; // r4@65
  signed int v74; // r5@65
  int v75; // r10@70
  int v76; // r9@71
  unsigned int v77; // r0@78
  int result; // r0@82
  signed int v79; // [sp+4h] [bp-94h]@65
  signed int v80; // [sp+8h] [bp-90h]@9
  int v81; // [sp+10h] [bp-88h]@1
  __int16 v82; // [sp+1Ch] [bp-7Ch]@27
  __int16 v83; // [sp+1Eh] [bp-7Ah]@27
  __int16 v84; // [sp+20h] [bp-78h]@27
  __int16 v85; // [sp+22h] [bp-76h]@27
  __int16 v86; // [sp+24h] [bp-74h]@27
  unsigned __int16 v87; // [sp+26h] [bp-72h]@27
  __int16 v88; // [sp+28h] [bp-70h]@27
  __int16 v89; // [sp+2Ah] [bp-6Eh]@27
  __int16 v90; // [sp+2Ch] [bp-6Ch]@27
  char v91[12]; // [sp+30h] [bp-68h]@45
  char v92[8]; // [sp+3Ch] [bp-5Ch]@45
  int v93; // [sp+40h] [bp-58h]@48
  char v94; // [sp+44h] [bp-54h]@45
  __int16 v95[2]; // [sp+48h] [bp-50h]@25
  int v96; // [sp+4Ch] [bp-4Ch]@48
  int v97; // [sp+50h] [bp-48h]@48
  char v98[12]; // [sp+54h] [bp-44h]@22
  int v99; // [sp+58h] [bp-40h]@54
  int v100; // [sp+5Ch] [bp-3Ch]@54
  char v101[8]; // [sp+60h] [bp-38h]@35
  __int16 v102; // [sp+68h] [bp-30h]@21
  __int16 v103; // [sp+6Ah] [bp-2Eh]@21
  __int16 v104; // [sp+6Ch] [bp-2Ch]@21

  v13 = a3;
  v81 = a2;
  if ( (unsigned __int16)a2 > 0x20u )
    goto LABEL_82;
  v14 = 0;
  do
  {
    if ( a2 == 1 << v14 )
    {
      v15 = 1;
      goto LABEL_7;
    }
    ++v14;
  }
  while ( v14 != 6 );
  v15 = 0;
LABEL_7:
  v16 = a2;
  if ( a2 )
    v16 = 1;
  v80 = v16;
  if ( (v15 ^ 1) & v16 )
  {
LABEL_82:
    LOWORD(result) = 0;
    return (signed __int16)result;
  }
  *a7 = 1;
  *a12 = 0;
  *a13 = 0;
  *a9 = 0;
  *a10 = 0;
  *a11 = 0;
  if ( *(_WORD *)a1 & 2 )
    v17 = 1;
  else
    v17 = *a9;
  *a9 = v17;
  if ( *(_WORD *)(a1 + 14) & 4 )
    v18 = 1;
  else
    v18 = *a10;
  *a10 = v18;
  if ( *(_WORD *)(a1 + 14) & 8 )
    v19 = 1;
  else
    v19 = *a11;
  *a11 = v19;
  if ( *a10 == 1 || v19 == 1 )
    goto LABEL_83;
  v102 = *(_WORD *)(a1 + 2) + (*(_WORD *)(a1 + 4) << 8);
  v103 = *(_WORD *)(a1 + 6) + (*(_WORD *)(a1 + 8) << 8);
  v20 = 0;
  v21 = v13;
  v104 = *(_WORD *)(a1 + 10) + (*(_WORD *)(a1 + 12) << 8);
  v22 = *(_WORD *)(a1 + 14);
  _R7 = 10;
  v24 = 0;
  v25 = v22 & 0x10;
  do
  {
    _R9 = *(unsigned __int16 *)((char *)&v102 + v24);
    __asm { SMULBB.W        R9, R9, R7 }
    v32 = (*(_WORD *)(v21 + v24) + 128) * _R9;
    *(_DWORD *)&v98[v20 * 2] = v32;
    if ( v25 )
      v33 = v32 >> 10;
    else
      v33 = v32 >> 8;
    *(_DWORD *)&v95[v20] = v33;
    v20 += 2;
    v24 += 2;
  }
  while ( v20 != 6 );
  LOWORD(v42) = a4
             && (v34 = ~*(_BYTE *)(a4 + 5) | (~*(_BYTE *)(a4 + 20) << 8),
                 v82 = ~*(_BYTE *)(a4 + 5) | (~*(_BYTE *)(a4 + 20) << 8),
                 v35 = ~*(_BYTE *)(a4 + 17) | ((*(_BYTE *)(a4 + 21) + 4) << 8),
                 v83 = v35,
                 v36 = (*(_BYTE *)(a4 + 19) + 102) | ((*(_BYTE *)(a4 + 9) - 55) << 8),
                 v84 = (*(_BYTE *)(a4 + 19) + 102) | ((*(_BYTE *)(a4 + 9) - 55) << 8),
                 v37 = (unsigned __int8)(*(_BYTE *)(a4 + 12) - 38) | ((*(_BYTE *)(a4 + 1) - 82) << 8),
                 v85 = (unsigned __int8)(*(_BYTE *)(a4 + 12) - 38) | (unsigned __int16)((*(_BYTE *)(a4 + 1) - 82) << 8),
                 v38 = (*(_BYTE *)a4 - 32) | ((*(_BYTE *)(a4 + 8) + 106) << 8),
                 v86 = v38,
                 v87 = ~*(_BYTE *)(a4 + 22) | (~*(_BYTE *)(a4 + 6) << 8),
                 v39 = (*(_BYTE *)(a4 + 4) - 49) | (~*(_BYTE *)(a4 + 14) << 8),
                 v88 = v39,
                 v40 = (*(_BYTE *)(a4 + 18) - 127) | (~*(_BYTE *)(a4 + 16) << 8),
                 v89 = v40,
                 v41 = (*(_BYTE *)(a4 + 11) - 85) | ((*(_BYTE *)(a4 + 24) + 55) << 8),
                 v90 = v41,
                 (unsigned __int8)~*(_BYTE *)(a4 + 23) == (unsigned __int8)v40
                                                        + (unsigned __int8)v39
                                                        + v34
                                                        + v36
                                                        + (unsigned __int8)v35
                                                        + v37
                                                        + (unsigned __int8)v38
                                                        + (unsigned __int8)v41
                                                        + v87)
             && *(_BYTE *)(a4 + 2) + 70 == (unsigned __int8)(v41 + v39 + v40)
             && ~*(_BYTE *)(a4 + 26) == (unsigned __int8)(v40 + v38 + v35);
  *a13 = v42;
  v42 = (signed __int16)v42;
  if ( !(_WORD)v42 )
    goto LABEL_33;
  v44 = 0;
  v45 = 0;
  do
  {
    v46 = *(_DWORD *)&v95[v44];
    v47 = 3;
    *(_WORD *)&v101[v45] = 0;
    do
    {
      v48 = 0x4000 << v47;
      if ( v46 > -(0x4000 << v47) )
      {
        if ( v46 < v48 )
          goto LABEL_41;
        v46 -= v48;
        v49 = *(_WORD *)&v101[v45] + (v42 << v47);
      }
      else
      {
        v46 += v48;
        v49 = *(_WORD *)&v101[v45] - (v42 << v47);
      }
      *(_WORD *)&v101[v45] = v49;
LABEL_41:
      _CF = __CFADD__(v47--, -1);
    }
    while ( _CF );
    *(_DWORD *)&v95[v44] = v46;
    if ( (unsigned __int16)(*(_WORD *)&v101[v45] + 7) > 0xEu )
      goto LABEL_82;
    v44 += 2;
    v45 += 2;
  }
  while ( v44 != 6 );
  v50 = 0;
  v51 = &v82;
  do
  {
    v52 = 0;
    v53 = 0;
    v54 = &v94;
    v55 = 0;
    *(_DWORD *)&v92[v50] = 0;
    *(_DWORD *)&v91[v50] = 0;
    do
    {
      v56 = v51[v55];
      v57 = *((_DWORD *)v54 + 1);
      v54 += 4;
      v52 += v57 * v56;
      v58 = *(_WORD *)&v101[v55 * 2];
      ++v55;
      v53 += v58 * (v56 << 10);
    }
    while ( v55 != 3 );
    v59 = v53 + ((signed int)v52 >> 4) + ((v52 >> 3) & 1);
    *(_DWORD *)&v91[v50] = v53;
    v51 += 3;
    *(_DWORD *)&v92[v50] = (((unsigned int)v59 >> 9) & 1) + (v59 >> 10);
    v50 += 4;
  }
  while ( v50 != 12 );
  *(_DWORD *)v95 = *(_DWORD *)v92;
  v96 = v93;
  v97 = *(_DWORD *)&v94;
LABEL_33:
  v43 = 0;
  do
  {
    v60 = *(_DWORD *)&v95[v43];
    *(_DWORD *)&v98[v43 * 2] = v60;
    v61 = v60 - *(_DWORD *)(a6 + v43 * 2);
    *(_DWORD *)&v95[v43] = v61;
    if ( (unsigned int)(v61 + 29999) > 0xEA5E )
      v62 = 1;
    else
      v62 = *a12;
    v43 += 2;
    *a12 = v62;
  }
  while ( v43 != 6 );
  if ( v62 == 1 )
  {
    AKSC_InitDecomp8963(a5);
    v63 = v99;
    v64 = v100;
    *(_DWORD *)a6 = *(_DWORD *)v98;
    *(_DWORD *)(a6 + 4) = v63;
    *(_DWORD *)(a6 + 8) = v64;
    v102 = 0;
    v103 = 0;
    v104 = 0;
  }
  else
  {
    v102 = v95[0];
    v103 = v96;
    v104 = v97;
  }
  AKSC_buffer((char *)&v102, 32, *a7, a5);
  v65 = 0;
  do
  {
    if ( v81 == 1 << v65 )
    {
      v66 = 1;
      goto LABEL_61;
    }
    ++v65;
  }
  while ( v65 != 6 );
  v66 = 0;
LABEL_61:
  v67 = v80 & (v66 ^ 1);
  if ( v67 || *(_WORD *)a5 == 0x7FFF || *(_WORD *)(a5 + 2) == 0x7FFF || *(_WORD *)(a5 + 4) == 0x7FFF )
    goto LABEL_82;
  v68 = a5;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v79 = 1;
  while ( v67 < v81 )
  {
    if ( v67 == v79 )
      v79 = (unsigned __int16)(2 * v67);
    if ( v67 )
    {
      v75 = *(_WORD *)v68;
      if ( v75 != 0x7FFF && (v76 = *(_WORD *)(v68 + 2), v76 != 0x7FFF) && *(_WORD *)(v68 + 4) != 0x7FFF )
      {
        v71 = *(_WORD *)v68;
        v74 += v75;
        v70 = *(_WORD *)(v68 + 2);
        v73 += v76;
        v69 = *(_WORD *)(v68 + 4);
      }
      else
      {
        v74 += v71;
        v73 += v70;
      }
      v72 += v69;
    }
    else
    {
      v74 = *(_WORD *)a5;
      v73 = *(_WORD *)(a5 + 2);
      v72 = *(_WORD *)(a5 + 4);
      v71 = *(_WORD *)a5;
      v70 = *(_WORD *)(a5 + 2);
      v69 = *(_WORD *)(a5 + 4);
    }
    ++v67;
    v68 += 6;
  }
  LOWORD(v77) = v79;
  while ( 1 )
  {
    v77 = (signed __int16)v77;
    if ( (signed __int16)v77 <= 1 )
      break;
    v74 >>= 1;
    v73 >>= 1;
    v72 >>= 1;
    v77 = (v77 >> 1) & 0xFFFF;
  }
  *(_WORD *)a8 = v74;
  *(_WORD *)(a8 + 2) = v73;
  *(_WORD *)(a8 + 4) = v72;
LABEL_83:
  LOWORD(result) = 1;
  return (signed __int16)result;
}
// 23A4: using guessed type __int16 var_50[2];
// 23A4: using guessed type char var_44[12];
// 23A4: using guessed type char var_38[8];
// 23A4: using guessed type char var_5C[8];
// 23A4: using guessed type char var_68[12];

//----- (0000285C) --------------------------------------------------------
int __fastcall AKSC_Decomp8963(int a1, signed int a2, int a3, int a4, int a5, _WORD *a6, int a7, signed __int16 *a8, signed __int16 *a9, _WORD *a10, _WORD *a11)
{
  signed int v11; // r5@1
  int v12; // r4@1
  int v13; // r7@2
  signed __int16 v14; // r7@7
  signed __int16 v15; // r7@10
  signed int v16; // r7@13
  int v17; // r1@17
  int v19; // r7@17
  __int16 v20; // r10@17
  __int16 v21; // r8@17
  signed int v28; // r12@18
  int v29; // r12@19
  int v30; // r12@21
  signed int v31; // lr@22
  int v32; // r1@26
  int v33; // r2@26
  int v34; // r3@28
  signed int v35; // r7@28
  signed int v36; // r1@28
  signed int v37; // r0@28
  signed int v38; // r6@28
  unsigned int v39; // r2@28
  unsigned int v40; // r8@30
  int v41; // r10@30
  int v42; // r9@34
  int v43; // r8@34
  int result; // r0@40
  int v45; // [sp+10h] [bp-50h]@17
  int v46; // [sp+14h] [bp-4Ch]@17
  int v47; // [sp+18h] [bp-48h]@17
  int v48; // [sp+1Ch] [bp-44h]@17
  int v49; // [sp+20h] [bp-40h]@17
  int v50; // [sp+24h] [bp-3Ch]@17
  __int16 v51; // [sp+28h] [bp-38h]@17
  __int16 v52; // [sp+2Ah] [bp-36h]@17
  __int16 v53; // [sp+2Ch] [bp-34h]@17
  __int16 v54; // [sp+30h] [bp-30h]@26
  __int16 v55; // [sp+32h] [bp-2Eh]@26
  __int16 v56; // [sp+34h] [bp-2Ch]@26

  v11 = a2;
  v12 = a4;
  if ( a2 > 32 )
  {
LABEL_40:
    LOWORD(result) = 0;
  }
  else
  {
    v13 = 0;
    while ( a2 != 1 << v13 )
    {
      if ( ++v13 == 6 )
        goto LABEL_40;
    }
    *a6 = 1;
    *a8 = 0;
    *a9 = 0;
    *a10 = 0;
    *a11 = 0;
    if ( *(_WORD *)a1 & 2 )
      v14 = 1;
    else
      v14 = *a8;
    *a8 = v14;
    if ( *(_WORD *)(a1 + 14) & 4 )
      v15 = 1;
    else
      v15 = *a9;
    *a9 = v15;
    if ( *(_WORD *)(a1 + 14) & 8 )
      v16 = 1;
    else
      v16 = *a10;
    *a10 = v16;
    if ( *a9 != 1 && v16 != 1 )
    {
      v17 = 0;
      _R9 = 10;
      v51 = *(_WORD *)(a1 + 2) + (*(_WORD *)(a1 + 4) << 8);
      v19 = 0;
      v52 = *(_WORD *)(a1 + 6) + (*(_WORD *)(a1 + 8) << 8);
      v20 = *(_WORD *)(a1 + 12);
      v21 = *(_WORD *)(a1 + 10);
      v50 = 0;
      v53 = v21 + (v20 << 8);
      v49 = 0;
      v48 = 0;
      v47 = 0;
      v46 = 0;
      v45 = 0;
      do
      {
        _LR = *(unsigned __int16 *)((char *)&v51 + v19);
        __asm { SMULBB.W        R11, LR, R9 }
        v28 = (*(_WORD *)(a3 + v19) + 128) * _R11;
        *(int *)((char *)&v48 + v17) = v28;
        if ( *(_WORD *)(a1 + 14) & 0x10 )
          v29 = v28 >> 10;
        else
          v29 = v28 >> 8;
        *(int *)((char *)&v48 + v17) = v29;
        v30 = *(int *)((char *)&v48 + v17) - *(_DWORD *)(a5 + v17);
        *(int *)((char *)&v45 + v17) = v30;
        if ( (unsigned int)(v30 + 29999) <= 0xEA5E )
          v31 = *a11;
        else
          v31 = 1;
        v17 += 4;
        v19 += 2;
        *a11 = v31;
      }
      while ( v17 != 12 );
      if ( v31 == 1 )
      {
        AKSC_InitDecomp8963(a4);
        v32 = v49;
        v33 = v50;
        *(_DWORD *)a5 = v48;
        *(_DWORD *)(a5 + 4) = v32;
        *(_DWORD *)(a5 + 8) = v33;
        v54 = 0;
        v55 = 0;
        v56 = 0;
      }
      else
      {
        v54 = v45;
        v55 = v46;
        v56 = v47;
      }
      AKSC_buffer((char *)&v54, 32, *a6, v12);
      v34 = 0;
      v35 = 0;
      v36 = 0;
      v37 = 0;
      v38 = 0;
      v39 = 1;
      while ( v35 < v11 )
      {
        if ( v35 == v39 )
        {
          v39 = (unsigned __int16)(2 * v35);
          v40 = (unsigned __int16)(2 * v35);
          v41 = v12 + 6 * (v40 - 1);
          if ( *(_WORD *)v41 == 0x7FFF && *(_WORD *)(v41 + 2) == 0x7FFF && *(_WORD *)(v41 + 4) == 0x7FFF )
          {
            v39 = (v40 >> 1) & 0xFFFF;
            break;
          }
        }
        v42 = *(_WORD *)(v12 + v34);
        v43 = v12 + v34;
        ++v35;
        v34 += 6;
        v38 += v42;
        v36 += *(_WORD *)(v43 + 4);
        v37 += *(_WORD *)(v43 + 2);
      }
      while ( 1 )
      {
        v39 = (signed __int16)v39;
        if ( (signed __int16)v39 <= 1 )
          break;
        v38 >>= 1;
        v37 >>= 1;
        v36 >>= 1;
        v39 = (v39 >> 1) & 0xFFFF;
      }
      *(_WORD *)a7 = v38;
      *(_WORD *)(a7 + 2) = v37;
      *(_WORD *)(a7 + 4) = v36;
    }
    LOWORD(result) = 1;
  }
  return (signed __int16)result;
}

//----- (00002A9C) --------------------------------------------------------
int __fastcall AKSC_div16(int a1, int a2)
{
  __int16 v2; // r3@1
  int v3; // r2@1

  v2 = 0;
  LOWORD(v3) = 0;
  do
  {
    a1 *= 2;
    v2 *= 2;
    if ( a1 >= a2 )
    {
      a1 -= a2;
      ++v2;
    }
    v3 = (unsigned __int16)(v3 + 1);
  }
  while ( v3 != 15 );
  return v2;
}

//----- (00002AC0) --------------------------------------------------------
int __fastcall AKSC_div32(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // r3@1
  int result; // r0@1
  int v4; // r2@1

  v2 = a1;
  result = 0;
  LOWORD(v4) = 0;
  do
  {
    v2 *= 2;
    result *= 2;
    if ( v2 >= a2 )
    {
      v2 -= a2;
      ++result;
    }
    v4 = (unsigned __int16)(v4 + 1);
  }
  while ( v4 != 31 );
  return result;
}

//----- (00002AE0) --------------------------------------------------------
int __fastcall AKSC_norm16(int a1)
{
  signed __int16 v1; // r3@2

  if ( a1 <= 0 )
  {
    if ( a1 )
    {
      v1 = 0;
      while ( !(((signed __int16)a1 + 0x4000 < 0) ^ __OFADD__((signed __int16)a1, 0x4000)) )
      {
        LOWORD(a1) = 2 * a1;
        ++v1;
      }
    }
    else
    {
      v1 = 15;
    }
  }
  else
  {
    v1 = 0;
    while ( (signed __int16)a1 <= 0x3FFF )
    {
      LOWORD(a1) = 2 * a1;
      ++v1;
    }
  }
  return v1;
}

//----- (00002B20) --------------------------------------------------------
int __fastcall AKSC_norm32(signed int a1)
{
  signed __int16 v1; // r3@2

  if ( a1 <= 0 )
  {
    if ( a1 )
    {
      v1 = 0;
      while ( a1 >= -1073741824 )
      {
        a1 *= 2;
        ++v1;
      }
    }
    else
    {
      v1 = 31;
    }
  }
  else
  {
    v1 = 0;
    while ( a1 <= 0x3FFFFFFF )
    {
      a1 *= 2;
      ++v1;
    }
  }
  return v1;
}

//----- (00002B54) --------------------------------------------------------
signed int __fastcall AKSC_abs16(signed int result)
{
  if ( result == -32768 )
    LOWORD(result) = 0x7FFF;
  else
    LOWORD(result) = (result ^ (result >> 31)) - (result >> 31);
  return (signed __int16)result;
}

//----- (00002B70) --------------------------------------------------------
int __fastcall AKSC_div16f(int a1, int a2, __int16 *a3)
{
  int v3; // r5@1
  __int16 *v4; // r6@1
  __int16 v5; // r0@1
  __int16 v6; // r3@1
  unsigned int v7; // r4@1
  __int16 v8; // r1@1

  v3 = a2;
  v4 = a3;
  v7 = a1;
  *a3 = AKSC_norm16(a1);
  v5 = AKSC_norm16(v3);
  v6 = *v4;
  LOWORD(v7) = v7 << *v4;
  v8 = v3 << v5;
  if ( (signed __int16)v7 > v8 )
  {
    v7 = ((unsigned int)(signed __int16)v7 >> 1) & 0xFFFF;
    *v4 = ~v5 + v6;
  }
  else
  {
    *v4 = v6 - v5;
  }
  return (signed __int16)AKSC_div16((signed __int16)v7, v8);
}

//----- (00002BBC) --------------------------------------------------------
int __fastcall sub_2BBC(int result)
{
  __int16 v1; // r2@1
  __int16 v2; // r1@1

  v1 = *(_WORD *)(result + 2);
  v2 = *(_WORD *)result;
  *(_WORD *)(result + 4) = v1;
  *(_WORD *)(result + 2) = v2;
  *(_WORD *)result = v1 + v2;
  return result;
}

//----- (00002BCC) --------------------------------------------------------
int __fastcall AKSC_SetLayout(void *src, int a2)
{
  char *v2; // r4@1
  int v3; // r5@1
  int v4; // r7@1
  int v5; // r6@1
  int v6; // r3@1
  int result; // r0@1
  int v8; // lr@2
  int v9; // r8@2
  int v10; // r12@2
  void *v11; // [sp+0h] [bp-20h]@1
  int v12; // [sp+4h] [bp-1Ch]@1

  v11 = src;
  v12 = a2;
  v2 = (char *)src;
  v3 = a2;
  memcpy(&v11, src, 6u);
  v4 = (signed __int16)v11;
  v5 = SHIWORD(v11);
  v6 = 0;
  result = (signed __int16)v12;
  do
  {
    v8 = *(_WORD *)v3 * v4 + *(_WORD *)(v3 + 2) * v5;
    v9 = *(_WORD *)(v3 + 4);
    v3 += 6;
    v10 = v8 + v9 * result;
    if ( v10 >= 0x7FFF )
      v10 = 0x7FFF;
    if ( v10 < -32768 )
      LOWORD(v10) = -32768;
    *(_WORD *)&v2[v6] = v10;
    v6 += 2;
  }
  while ( v6 != 6 );
  return result;
}

//----- (00002C2C) --------------------------------------------------------
int __fastcall AKSC_ThetaFilter(int a1, int a2, int a3)
{
  int v3; // r4@1
  __int16 v5; // r7@1
  int v6; // r4@1
  __int16 v7; // r6@1
  unsigned int v9; // r5@2
  unsigned int v18; // r0@4

  v3 = a2;
  _R5 = a3;
  v5 = AKSC_angRng(a1, 1);
  v6 = (signed __int16)AKSC_angRng(v3, 1);
  v7 = AKSC_angRng(v5 - v6, 1);
  _R7 = (unsigned __int16)AKSC_abs16(v7);
  if ( _R5 > 0 )
  {
    _R2 = (unsigned __int16)AKSC_cos((signed __int16)_R7);
    __asm { SMULBB.W        R1, R2, R5 }
    v9 = (unsigned int)-(_R1 >> 27) >> 16;
  }
  else
  {
    v9 = 0;
  }
  _LR = 0x7FFF * (v9 + 1) - (v9 << 12);
  __asm { SMULBB.W        R12, LR, R7 }
  v18 = (unsigned int)(_R12 + 0x8000) >> 16;
  if ( v7 & 0x8000 )
    v18 = (unsigned __int16)-(signed __int16)v18;
  return (signed __int16)AKSC_angRng(v6 + v18, 0);
}

//----- (00002CA0) --------------------------------------------------------
int __fastcall sub_2CA0(int a1, _WORD *a2)
{
  _WORD *v2; // r4@1
  int v3; // r3@1
  int v4; // r2@2
  signed int v5; // r5@3
  int v6; // r2@4
  __int16 v7; // r3@4
  int v8; // r0@4
  int v9; // r5@4
  char v10; // r6@4
  int v18; // lr@5
  signed __int16 v19; // r3@6
  int result; // r0@11
  _WORD *v21; // [sp+4h] [bp-14h]@1

  v21 = a2;
  v2 = (_WORD *)a1;
  v3 = *(_WORD *)a1 * *(_WORD *)a1;
  if ( v3 == 0x40000000
    || (v4 = v3 + *(_WORD *)(a1 + 2) * *(_WORD *)(a1 + 2), v4 > 0x3FFFFFFF)
    || (v5 = v4 + *(_WORD *)(a1 + 4) * *(_WORD *)(a1 + 4), v5 > 0x3FFFFFFF) )
  {
    LOWORD(result) = 0;
    return (signed __int16)result;
  }
  *a2 = AKSC_sqrt32(v4 + *(_WORD *)(a1 + 4) * *(_WORD *)(a1 + 4));
  v8 = AKSC_invSqrt(v5, (_WORD *)&v21 + 1, v6, v7);
  v9 = (int)(v2 + 3);
  v10 = 16 - BYTE2(v21);
  HIWORD(v21) += 3;
  _R0 = (unsigned __int16)(v8 >> v10);
  do
  {
    _R6 = *v2;
    __asm { SMULBB.W        R6, R0, R6 }
    v18 = (_R6 + (1 << (BYTE2(v21) - 1))) >> SBYTE2(v21);
    *v2 = v18;
    ++v2;
    if ( (v18 + 2048 < 0) ^ __OFADD__(v18, 2048) )
    {
      v19 = -2048;
    }
    else
    {
      if ( v18 <= 2048 )
        continue;
      v19 = 2048;
    }
    *(v2 - 1) = v19;
  }
  while ( v2 != (_WORD *)v9 );
  LOWORD(result) = 1;
  return (signed __int16)result;
}

//----- (00002D48) --------------------------------------------------------
int __fastcall AKSC_DirectionS3(int a1, int a2, int a3, void *a4, const void *a5, int a6, int a7, int a8, _WORD *a9, _WORD *a10, _WORD *a11, _WORD *a12, _WORD *a13, _WORD *a14, _WORD *a15, _WORD *a16, __int16 *a17, int a18, int a19)
{
  int v19; // r10@1
  int v20; // r4@1
  int v21; // r5@1
  signed int v22; // r11@1
  int v23; // r2@1
  int v24; // r6@1
  int v25; // r2@3
  int v26; // r3@3
  char *v27; // r5@3
  int v28; // r12@3
  signed int v29; // r11@3
  char v30; // r4@4
  int v31; // t1@4
  int v32; // ST00_4@5
  int v33; // ST08_4@5
  int v34; // ST04_4@5
  int v35; // ST08_4@7
  int v36; // r1@7
  int v37; // r5@8
  int v38; // r8@8
  int v39; // r2@10
  signed int v40; // r11@10
  char *v41; // r5@10
  int v42; // r12@10
  int v43; // r3@10
  char v44; // r4@11
  int v45; // t1@11
  int v46; // ST00_4@12
  int v47; // ST08_4@12
  int v48; // ST04_4@12
  int v49; // r4@15
  int v50; // r5@15
  int v51; // r6@15
  int v52; // r8@15
  int v53; // r11@17
  int v54; // r3@17
  int v55; // r3@23
  int v56; // r3@29
  int v57; // r3@35
  int v58; // r2@43
  int v59; // r2@45
  int v60; // r2@47
  int v70; // r2@50
  int v77; // r4@50
  unsigned int v78; // r11@50
  int v79; // r1@50
  int v80; // r10@50
  int v81; // lr@50
  int v82; // r12@50
  int v83; // r0@50
  signed int v84; // r3@52
  int v85; // r2@54
  signed int v86; // r3@54
  signed int v87; // r2@56
  signed int v88; // r2@58
  signed int v89; // r1@60
  signed int v90; // r0@62
  __int16 v91; // r11@64
  int v92; // r0@64
  signed int v93; // lr@64
  int v94; // r12@64
  int v95; // r3@64
  int v96; // r4@64
  int v97; // r0@64
  _WORD *v98; // r10@64
  int v99; // r4@64
  signed int v100; // r2@64
  int v101; // r1@64
  int v102; // r12@64
  signed int v103; // r0@65
  int v104; // ST08_4@69
  signed int v105; // ST00_4@69
  int v106; // ST04_4@69
  __int16 v107; // lr@70
  int v108; // r10@71
  int v109; // r3@71
  int v110; // r2@72
  int v111; // r0@78
  int v112; // r3@78
  int v113; // r1@78
  int v114; // r4@78
  int v115; // r2@78
  int v116; // lr@78
  int v117; // r3@80
  int v118; // r4@80
  int v119; // r3@82
  int v120; // r0@84
  int *v121; // r3@84
  int v122; // r2@86
  __int16 v123; // r2@92
  int v124; // r4@96
  unsigned int v125; // r9@98
  int v126; // r8@98
  int v129; // r9@99
  int v133; // r0@99
  int v134; // r1@101
  int v135; // r12@101
  int v137; // r0@101
  signed __int16 v138; // r5@102
  signed int v148; // r1@103
  signed int v149; // r4@103
  int v150; // r8@103
  __int16 v151; // r0@103
  int v152; // r0@103
  __int16 v156; // r0@111
  int v157; // r0@111
  __int16 v158; // r0@112
  int v159; // r0@112
  __int16 v160; // r0@112
  signed __int16 v161; // r2@112
  int v162; // r3@113
  _WORD *v164; // r0@113
  __int16 v165; // r3@122
  __int16 v166; // r3@124
  int result; // r0@129
  int v168; // r11@49
  __int16 v169; // r0@49
  int v170; // [sp+0h] [bp-E0h]@2
  __int16 v171; // [sp+28h] [bp-B8h]@17
  int v172; // [sp+2Ch] [bp-B4h]@17
  __int16 v173; // [sp+30h] [bp-B0h]@17
  int v174; // [sp+34h] [bp-ACh]@17
  int v175; // [sp+38h] [bp-A8h]@17
  __int16 v176; // [sp+3Ch] [bp-A4h]@17
  void *src; // [sp+40h] [bp-A0h]@1
  int v178; // [sp+5Ch] [bp-84h]@1
  int v179; // [sp+60h] [bp-80h]@64
  int v180; // [sp+64h] [bp-7Ch]@64
  int v181; // [sp+68h] [bp-78h]@64
  unsigned __int16 v182; // [sp+6Ch] [bp-74h]@49
  unsigned __int16 v183; // [sp+6Eh] [bp-72h]@50
  unsigned __int16 v184; // [sp+70h] [bp-70h]@50
  unsigned __int16 v185; // [sp+74h] [bp-6Ch]@49
  unsigned __int16 v186; // [sp+76h] [bp-6Ah]@50
  unsigned __int16 v187; // [sp+78h] [bp-68h]@50
  unsigned __int16 v188; // [sp+7Ah] [bp-66h]@50
  char v189[16]; // [sp+7Ch] [bp-64h]@1
  char v190[16]; // [sp+8Ch] [bp-54h]@1
  char v191[12]; // [sp+9Ch] [bp-44h]@1
  char dest[12]; // [sp+A8h] [bp-38h]@1
  int v193; // [sp+B4h] [bp-2Ch]@1

  v19 = a3;
  v20 = a2;
  src = a4;
  v21 = a1;
  v22 = 2;
  v193 = _stack_chk_guard;
  memcpy(dest, &unk_5619, 0xBu);
  memcpy(v190, &unk_5624, 0xDu);
  memcpy(v191, "ASAHIKASEI", 0xBu);
  memcpy(v189, "OPPO_63_R601", 0xDu);
  v23 = a19;
  v178 = 1;
  v24 = v20;
  do
  {
    ++v22;
    v170 = v23;
    sub_2BBC((int)&v178);
    v23 = v170;
  }
  while ( v22 != 10 );
  v25 = v21;
  v26 = a18;
  v27 = dest;
  v28 = v170;
  v29 = 0;
  do
  {
    v31 = (unsigned __int8)*v27++;
    v30 = v31;
    if ( !v31 )
      break;
    v32 = v25;
    v33 = v26;
    v34 = v28;
    sub_2BBC((int)&v178);
    ++v29;
    *(v27 - 1) = v30 - 65 - v178;
    v25 = v32;
    v26 = v33;
    v28 = v34;
  }
  while ( v29 != 16 );
  v37 = v25;
  v36 = v28;
  v38 = v26;
  while ( v29 <= 15 )
  {
    v35 = v36;
    sub_2BBC((int)&v178);
    v36 = v35;
    ++v29;
  }
  v39 = v37;
  v40 = 0;
  v41 = v190;
  v42 = v36;
  v43 = v38;
  do
  {
    v45 = (unsigned __int8)*v41++;
    v44 = v45;
    if ( !v45 )
      break;
    ++v40;
    v46 = v39;
    v47 = v43;
    v48 = v42;
    sub_2BBC((int)&v178);
    *(v41 - 1) = v44 - 60 - v178;
    v39 = v46;
    v43 = v47;
    v42 = v48;
  }
  while ( v40 != 16 );
  v49 = v24;
  v50 = v39;
  v51 = v43;
  v52 = v42;
  while ( v40 <= 15 )
  {
    sub_2BBC((int)&v178);
    ++v40;
  }
  sub_2BBC((int)&v178);
  v53 = (unsigned __int16)v178;
  sub_2BBC((int)&v178);
  v176 = v178;
  sub_2BBC((int)&v178);
  v175 = (unsigned __int16)v178;
  sub_2BBC((int)&v178);
  v174 = (unsigned __int16)v178;
  sub_2BBC((int)&v178);
  v173 = v178;
  sub_2BBC((int)&v178);
  v172 = (unsigned __int16)v178;
  sub_2BBC((int)&v178);
  v171 = v178;
  sub_2BBC((int)&v178);
  v54 = 0;
  do
  {
    if ( !dest[v54] && !*(_BYTE *)(v50 + v54) )
      goto LABEL_23;
    if ( *(_BYTE *)(v50 + v54) != (unsigned __int8)dest[v54] )
      goto LABEL_128;
    ++v54;
  }
  while ( v54 != 16 );
  if ( *(_BYTE *)(v50 + 16) )
  {
LABEL_128:
    v138 = -32768;
    goto LABEL_129;
  }
LABEL_23:
  v55 = 0;
  do
  {
    if ( !v190[v55] && !*(_BYTE *)(v49 + v55) )
      goto LABEL_29;
    if ( *(_BYTE *)(v49 + v55) != (unsigned __int8)v190[v55] )
      goto LABEL_128;
    ++v55;
  }
  while ( v55 != 16 );
  if ( *(_BYTE *)(v49 + 16) )
    goto LABEL_128;
LABEL_29:
  v56 = 0;
  do
  {
    if ( !v191[v56] && !*(_BYTE *)(v50 + v56) )
      goto LABEL_35;
    if ( *(_BYTE *)(v50 + v56) != (unsigned __int8)v191[v56] )
      goto LABEL_128;
    ++v56;
  }
  while ( v56 != 16 );
  if ( *(_BYTE *)(v50 + 16) )
    goto LABEL_128;
LABEL_35:
  v57 = 0;
  do
  {
    if ( !v189[v57] && !*(_BYTE *)(v49 + v57) )
      goto LABEL_41;
    if ( *(_BYTE *)(v49 + v57) != (unsigned __int8)v189[v57] )
      goto LABEL_128;
    ++v57;
  }
  while ( v57 != 16 );
  if ( *(_BYTE *)(v49 + 16) )
    goto LABEL_128;
LABEL_41:
  if ( *(_WORD *)v19 != 12091 - v53 )
    goto LABEL_128;
  if ( *(_WORD *)(v19 + 2) != (signed __int16)(-26131 - v176) )
    goto LABEL_128;
  v58 = *(_WORD *)(v19 + 4);
  if ( v58 < -23074 - v175 )
    goto LABEL_128;
  if ( 16512 - v174 < v58 )
    goto LABEL_128;
  v59 = *(_WORD *)(v19 + 6);
  if ( v59 < (signed __int16)(-6816 - v173) )
    goto LABEL_128;
  if ( 9695 - v172 < v59 )
    goto LABEL_128;
  v60 = *(_WORD *)(v19 + 8);
  if ( v60 < (signed __int16)(2625 - v171) || 12319 - (unsigned __int16)v178 < v60 )
    goto LABEL_128;
  memcpy(&v185, src, 6u);
  memcpy(&v182, a5, 6u);
  v168 = sub_2CA0((int)&v185, a11);
  v169 = sub_2CA0((int)&v182, a13);
  if ( v168 )
    v138 = 3;
  else
    v138 = 2;
  if ( !v169 )
    v138 &= 0xFFFCu;
  AKSC_SetLayout(&v185, a7);
  AKSC_SetLayout(&v182, a8);
  _R1 = v184;
  _R11 = v186;
  _LR = v183;
  _R10 = v187;
  __asm
  {
    SMULBB.W        R12, R1, R11
    SMULBB.W        R3, LR, R10
  }
  LOWORD(v70) = (((unsigned int)(_R12 - _R3) >> 7) & 1) + ((_R12 - _R3) >> 8);
  *(_WORD *)(v51 + 6) = v70;
  _R4 = v182;
  _R0 = v185;
  v70 = (signed __int16)v70;
  __asm
  {
    SMULBB.W        R3, R4, R10
    SMULBB.W        R12, R1, R0
  }
  LOWORD(_R3) = (((unsigned int)(_R3 - _R12) >> 7) & 1) + ((_R3 - _R12) >> 8);
  __asm
  {
    SMULBB.W        R12, R4, R11
    SMULBB.W        R10, LR, R0
  }
  *(_WORD *)(v51 + 8) = _R3;
  _R3 = (signed __int16)_R3;
  *(_WORD *)(v51 + 10) = (((unsigned int)(_R10 - _R12) >> 7) & 1) + ((_R10 - _R12) >> 8);
  v77 = (signed __int16)v183;
  v78 = (((unsigned int)(_R10 - _R12) >> 7) & 1) + ((_R10 - _R12) >> 8);
  v79 = (signed __int16)v184;
  v80 = (signed __int16)v183 * v78 - (signed __int16)v184 * (signed __int16)_R3;
  *(_WORD *)v51 = (((unsigned int)v80 >> 10) & 1) + (v80 >> 11);
  v81 = (signed __int16)v182;
  *(_WORD *)(v51 + 2) = (((v79 * (signed __int16)v70 - (signed __int16)v182 * v78) >> 10) & 1)
                      + ((signed int)(v79 * (signed __int16)v70 - (signed __int16)v182 * v78) >> 11);
  v82 = v81 * (signed __int16)_R3 - v77 * (signed __int16)v70;
  *(_WORD *)(v51 + 14) = -8 * v77;
  *(_WORD *)(v51 + 16) = -8 * v79;
  *(_WORD *)(v51 + 4) = (((unsigned int)v82 >> 10) & 1) + (v82 >> 11);
  *(_WORD *)(v51 + 12) = -8 * v81;
  v83 = AKSC_invSqrt(v70 * v70 + _R3 * _R3 + v78 * v78, &v188, v70 * v70, _R3);
  if ( 16 - v188 > 0 )
    v83 = ((v83 >> (15 - v188)) & 1) + (v83 >> (16 - v188));
  v84 = *(_WORD *)(v51 + 6) * v83;
  if ( (signed __int16)v188 > 0 )
    v84 = (v84 >> v188) + ((v84 >> (v188 - 1)) & 1);
  v85 = *(_WORD *)(v51 + 8);
  *(_WORD *)(v51 + 6) = v84;
  v86 = v85 * v83;
  if ( (signed __int16)v188 > 0 )
    v86 = (v86 >> v188) + ((v86 >> (v188 - 1)) & 1);
  v86 = (unsigned __int16)v86;
  *(_WORD *)(v51 + 8) = v86;
  v87 = *(_WORD *)(v51 + 10) * v83;
  if ( (signed __int16)v188 > 0 )
    v87 = (v87 >> v188) + ((v87 >> (v188 - 1)) & 1);
  *(_WORD *)(v51 + 10) = v87;
  v88 = *(_WORD *)v51 * v83;
  if ( (signed __int16)v188 > 0 )
    v88 = (v88 >> v188) + ((v88 >> (v188 - 1)) & 1);
  v88 = (unsigned __int16)v88;
  *(_WORD *)v51 = v88;
  v89 = *(_WORD *)(v51 + 2) * v83;
  if ( (signed __int16)v188 > 0 )
    v89 = (v89 >> v188) + ((v89 >> (v188 - 1)) & 1);
  *(_WORD *)(v51 + 2) = v89;
  v90 = *(_WORD *)(v51 + 4) * v83;
  if ( (signed __int16)v188 > 0 )
    v90 = (v90 >> v188) + ((v90 >> (v188 - 1)) & 1);
  v91 = v90;
  v92 = *(_WORD *)(v51 + 16);
  v93 = v86;
  *(_WORD *)(v51 + 4) = v91;
  v94 = v86 + v92 + 0x4000;
  v95 = v92 + 0x4000 - v86;
  v178 = v94 + v88;
  v96 = 0x4000 - v92 - v93 + v88;
  v97 = v93 + 0x4000 - v92 - v88;
  v179 = v96;
  v98 = (_WORD *)v52;
  v181 = v95 - v88;
  v99 = 0;
  v100 = 0xFFFF;
  v101 = 0x4000;
  v102 = v52;
  v180 = v97;
  do
  {
    v103 = *(int *)((char *)&v178 + v99);
    if ( v103 > 0 )
    {
      if ( v103 <= v100 )
      {
        v104 = v101;
        v105 = v100;
        v106 = v102;
        *(int *)((char *)&v178 + v99) = (signed __int16)AKSC_sqrt32(*(int *)((char *)&v178 + v99) << 12);
        v102 = v106;
        v100 = v105;
        v101 = v104;
      }
      else
      {
        *(int *)((char *)&v178 + v99) = v101;
      }
    }
    else
    {
      *(int *)((char *)&v178 + v99) = 0;
    }
    v107 = *(_WORD *)((char *)&v178 + v99);
    v99 += 4;
    *v98 = v107;
    ++v98;
  }
  while ( v99 != 16 );
  v108 = v102;
  v109 = *(_WORD *)v52 & ~((signed int)*(_WORD *)v52 >> 31);
  if ( v109 >= *(_WORD *)(v52 + 2) )
  {
    LOWORD(v110) = 0;
  }
  else
  {
    v109 = *(_WORD *)(v52 + 2);
    LOWORD(v110) = 1;
  }
  if ( v109 < *(_WORD *)(v52 + 4) )
  {
    v109 = *(_WORD *)(v52 + 4);
    LOWORD(v110) = 2;
  }
  if ( v109 < *(_WORD *)(v52 + 6) )
  {
    v178 = *(_WORD *)(v51 + 2) - *(_WORD *)(v51 + 6);
    v179 = *(_WORD *)(v51 + 4) + *(_WORD *)(v51 + 12);
    v119 = 1;
    v180 = *(_WORD *)(v51 + 14) + *(_WORD *)(v51 + 10);
    goto LABEL_83;
  }
  v110 = (signed __int16)v110;
  if ( (signed __int16)v110 == 1 )
  {
    v117 = *(_WORD *)(v51 + 10);
    v118 = *(_WORD *)(v51 + 14);
    v179 = 1;
    v178 = v117 - v118;
    v180 = *(_WORD *)(v51 + 6) + *(_WORD *)(v51 + 2);
    v115 = *(_WORD *)(v51 + 4);
    v112 = *(_WORD *)(v51 + 12);
LABEL_82:
    v119 = v115 + v112;
LABEL_83:
    v181 = v119;
    goto LABEL_84;
  }
  _ZF = v110 == 2;
  v111 = *(_WORD *)(v51 + 6);
  v112 = *(_WORD *)(v51 + 10);
  v113 = *(_WORD *)(v51 + 2);
  v114 = *(_WORD *)(v51 + 4);
  v115 = *(_WORD *)(v51 + 14);
  v116 = *(_WORD *)(v51 + 12);
  if ( _ZF )
  {
    v178 = v116 - v114;
    v179 = v111 + v113;
    v180 = 1;
    goto LABEL_82;
  }
  v179 = v112 - v115;
  v178 = 1;
  v180 = v116 - v114;
  v181 = v113 - v111;
LABEL_84:
  v121 = &v178;
  v120 = v178;
  do
  {
    v122 = v121[1];
    if ( v120 >= 0 )
    {
      if ( v122 >= 0 )
        goto LABEL_91;
LABEL_90:
      *(_WORD *)(v108 + 2) = -*(_WORD *)(v108 + 2);
      goto LABEL_91;
    }
    if ( v122 > 0 )
      goto LABEL_90;
LABEL_91:
    ++v121;
    v108 += 2;
  }
  while ( v121 != &v181 );
  v123 = *(_WORD *)a6;
  if ( *(_WORD *)a6 || *(_WORD *)(a6 + 2) || *(_WORD *)(a6 + 4) )
  {
    v134 = *(_WORD *)(a6 + 2);
    v135 = *(_WORD *)(a6 + 4);
    _R0 = v134 * *(_WORD *)(v51 + 2) + v123 * *(_WORD *)v51 + 64 + v135 * *(_WORD *)(v51 + 4);
    __asm { SBFX.W          R0, R0, #7, #0x10 }
    v137 = AKSC_atan2(
             _R0,
             (signed __int16)-((v134 * *(_WORD *)(v51 + 8)
                              + v123 * (signed int)*(_WORD *)(v51 + 6)
                              + 64
                              + v135 * *(_WORD *)(v51 + 10)) >> 7));
    *a9 = v137;
    if ( v137 == -1 )
      goto LABEL_102;
  }
  else
  {
    if ( *(_WORD *)(v51 + 4) || (LOWORD(v124) = *(_WORD *)(v51 + 10)) != 0 )
      LOWORD(v124) = AKSC_atan2(*(_WORD *)(v51 + 4), *(_WORD *)(v51 + 10));
    v124 = (signed __int16)v124;
    v125 = AKSC_sin((signed __int16)v124);
    v126 = AKSC_cos((signed __int16)v124);
    _R2 = *(_WORD *)(v51 + 10) * v125 + *(_WORD *)(v51 + 4) * v126 + 0x4000;
    __asm { SBFX.W          R1, R2, #0xF, #0x10 }
    if ( AKSC_atan2(*(_WORD *)(v51 + 16), _R1) == -1 )
      goto LABEL_102;
    v129 = -v125;
    _R0 = *(_WORD *)(v51 + 8) * v126 + 0x4000 + *(_WORD *)(v51 + 2) * v129;
    _LR = *(_WORD *)(v51 + 6) * v126 + 0x4000 + *(_WORD *)v51 * v129;
    __asm
    {
      SBFX.W          R0, R0, #0xF, #0x10
      SBFX.W          R1, LR, #0xF, #0x10
    }
    v133 = (signed __int16)AKSC_atan2(_R0, _R1);
    if ( (signed __int16)v133 != -1 )
      *a9 = AKSC_angRng(-v133 - v124, 0);
    else
LABEL_102:
      v138 &= 0xFFFEu;
  }
  _R2 = v183;
  _R0 = v185;
  _R8 = v182;
  _R3 = v186;
  _R4 = v187;
  _LR = v184;
  __asm
  {
    SMULBB.W        R12, R2, R3
    SMULBB.W        R1, R8, R0
    SMULBB.W        R8, LR, R4
  }
  v148 = _R1 + _R12 + 64 + _R8;
  v149 = v148 >> 7;
  v150 = v148 >> 7;
  v151 = AKSC_sqrt32(0x40000000 - v150 * v150);
  v152 = AKSC_atan2(v151, v150);
  *a10 = v152;
  if ( v152 > 5760 )
    *a10 = v152 - 23040;
  if ( v149 < 0x8000 )
  {
    if ( v149 )
    {
      if ( (unsigned __int8)((v149 + 0x8000 < 0) ^ __OFADD__(v149, 0x8000)) | (v149 == -32768) )
        *a10 = -5760;
    }
    else
    {
      *a10 = 0;
    }
  }
  else
  {
    *a10 = 5760;
  }
  _R0 = AKSC_cos(*a10);
  _R3 = *a11;
  __asm { SMULBB.W        R2, R3, R0 }
  *a12 = ((_R2 >> 14) & 1) + ((signed int)_R2 >> 15);
  v156 = AKSC_sqrt32(*(_WORD *)(v51 + 14) * *(_WORD *)(v51 + 14) + *(_WORD *)(v51 + 16) * *(_WORD *)(v51 + 16));
  v157 = AKSC_atan2(v156, (signed __int16)-*(_WORD *)(v51 + 12));
  *a15 = v157;
  if ( v157 == -1 )
  {
    v138 &= 0xFFFDu;
  }
  else
  {
    *a15 = AKSC_angRng(v157, 1);
    v158 = AKSC_sqrt32(*(_WORD *)(v51 + 12) * *(_WORD *)(v51 + 12) + *(_WORD *)(v51 + 16) * *(_WORD *)(v51 + 16));
    v159 = AKSC_atan2(v158, *(_WORD *)(v51 + 14));
    *a17 = v159;
    v160 = AKSC_angRng(v159, 1);
    v161 = (signed __int16)a17;
    *a17 = v160;
    if ( (signed int)*(_WORD *)(v51 + 16) >= 0 )
    {
      *a14 = *a15;
      v166 = *a17;
    }
    else
    {
      v162 = *a15;
      v164 = (_WORD *)(v162 << 16);
      _NF = v162 << 16 < 0;
      if ( v162 & 0x8000 )
        v161 = -11520;
      else
        v162 = 11520 - v162;
      if ( _NF )
      {
        v161 -= v162;
        v162 = (int)a14;
      }
      else
      {
        v164 = a14;
      }
      if ( _NF )
        *(_WORD *)v162 = v161;
      else
        *v164 = v162;
      v165 = *a17;
      if ( *a17 & 0x8000 )
      {
        *a16 = -11520 - v165;
        goto LABEL_129;
      }
      v166 = 11520 - v165;
    }
    *a16 = v166;
  }
LABEL_129:
  result = v138;
  if ( v193 != _stack_chk_guard )
    _stack_chk_fail(v138);
  return result;
}
// 109C: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 2D48: using guessed type char dest[12];
// 2D48: using guessed type char var_54[16];
// 2D48: using guessed type char var_44[12];
// 2D48: using guessed type char var_64[16];

//----- (00003734) --------------------------------------------------------
int __fastcall AKSC_VNorm(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r10@1
  int v6; // r4@1
  int v7; // r5@1
  int v8; // r7@1
  int v9; // r6@2
  int v10; // r1@3
  signed int v11; // r0@4
  int result; // r0@8
  int v13; // [sp+4h] [bp-2Ch]@1
  int v14; // [sp+8h] [bp-28h]@1

  v13 = a2;
  v14 = a3;
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  if ( a4 > 0 )
  {
    v9 = 0;
    while ( 1 )
    {
      v10 = *(_WORD *)(v7 + v9);
      if ( v10 <= 0 )
        break;
      v11 = (*(_WORD *)(v5 + v9) - *(_WORD *)(v6 + v9)) * (signed __int16)AKSC_div16f(v8, v10, (__int16 *)&v13 + 1);
      if ( !((SHIWORD(v13) + 14 < 0) ^ __OFADD__(SHIWORD(v13), 14)) )
        v11 = ((v11 >> (BYTE2(v13) + 14)) & 1) + (v11 >> (BYTE2(v13) + 15));
      if ( (unsigned int)(v11 + 0x8000) > 0xFFFF )
        break;
      *(_WORD *)(a5 + v9) = v11;
      v9 += 2;
      if ( v9 == 6 )
      {
        LOWORD(result) = 1;
        return (signed __int16)result;
      }
    }
  }
  LOWORD(result) = 0;
  return (signed __int16)result;
}

//----- (000037AC) --------------------------------------------------------
int __fastcall AKSC_cholSl(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // r11@1
  int v7; // r6@1
  int v8; // r7@1
  int v9; // r0@1
  int v10; // r5@1
  int v11; // r4@2
  int v12; // r12@2
  int v20; // r9@5
  int v21; // r12@5
  int v22; // r4@5
  int v23; // r5@7
  int result; // r0@7
  int v25; // r4@7
  int v26; // r6@7
  int v27; // r8@7
  int v28; // r7@7
  int v29; // t1@8
  int v30; // r12@8
  signed int v31; // r3@8
  __int16 v32; // r9@8
  _WORD *v33; // r10@8
  int v34; // r2@8
  int v36; // t1@9
  int v39; // [sp+4h] [bp-3Ch]@8
  int v40; // [sp+10h] [bp-30h]@7
  int v41; // [sp+14h] [bp-2Ch]@7

  v6 = a1;
  v7 = a1 - 2;
  v8 = a6 - 2;
  v9 = 0;
  v10 = 0;
  while ( v10 < a2 )
  {
    v11 = 0;
    v12 = 0;
    while ( v11 != -v9 )
    {
      _R10 = *(_WORD *)(v8 + v11);
      _R9 = *(_WORD *)(v7 + v11);
      v11 -= 2;
      __asm { SMULBB.W        R9, R10, R9 }
      v12 += _R9;
    }
    v20 = *(_WORD *)(a4 + v9);
    v7 += 8;
    v10 = (unsigned __int16)(v10 + 1);
    v21 = (*(_WORD *)(a5 + v9) << 15) - 4 * v12;
    v22 = *(_WORD *)(a3 + v9);
    v9 += 2;
    *(_WORD *)(v8 + 2) = 2
                       * (v22 * ((unsigned __int64)v21 >> 16)
                        + ((signed int)(v20 * ((unsigned __int64)v21 >> 16)) >> 15)
                        + ((signed int)(v22 * ((unsigned int)(v21 << 16) >> 17)) >> 15));
    v8 += 2;
  }
  v23 = (unsigned __int16)a2;
  result = 0;
  v25 = (unsigned __int16)(a2 - 1);
  v26 = 0;
  v27 = (unsigned __int16)(a2 - 1);
  v28 = a6 + 2 * v27;
  v40 = a3 + 2 * v27;
  v41 = a4 + 2 * v27;
  while ( !(v25 & 0x8000) )
  {
    v29 = *(_WORD *)v28;
    v28 -= 2;
    v30 = v25;
    v31 = v29 << 15;
    v39 = result;
    v32 = v25;
    v33 = (_WORD *)(a6 + 2 * v23);
    v34 = v6 + 6 * v23 + 2 * (v27 - v26);
    while ( 1 )
    {
      ++v30;
      v34 += 6;
      if ( a2 <= v30 )
        break;
      v36 = *v33;
      ++v33;
      _R4 = v36;
      _R0 = *(_WORD *)(v34 - 6);
      __asm { SMULBB.W        R0, R0, R4 }
      v31 -= 4 * _R0;
    }
    ++v26;
    v23 = (unsigned __int16)(v23 - 1);
    result = v39 - 2;
    *(_WORD *)(v28 + 2) = 2
                        * (*(_WORD *)(v40 + v39) * HIWORD(v31)
                         + (*(_WORD *)(v41 + v39) * (v31 >> 16) >> 15)
                         + (*(_WORD *)(v40 + v39) * ((unsigned __int16)v31 >> 1) >> 15));
    v25 = (unsigned __int16)(v32 - 1);
  }
  return result;
}

//----- (000038EC) --------------------------------------------------------
int __fastcall AKSC_cholDc(int a1, int a2, int a3, int a4)
{
  int v4; // r4@1
  int v5; // r5@1
  int v6; // r9@1
  int v7; // r6@1
  _WORD *v8; // r10@2
  int v9; // t1@2
  int v10; // r2@2
  int v11; // r3@2
  signed int i; // r0@2
  int v20; // r0@7
  int v21; // r8@9
  int v22; // r7@9
  int result; // r0@12
  int v24; // [sp+4h] [bp-54h]@2
  int v25; // [sp+10h] [bp-48h]@1
  int v26; // [sp+14h] [bp-44h]@1
  int v27; // [sp+18h] [bp-40h]@1
  char v28; // [sp+2Eh] [bp-2Ah]@7

  v4 = 0;
  v5 = a1 - 2;
  v25 = a2;
  v6 = a1;
  v26 = a3;
  v27 = a4;
  v7 = 0;
LABEL_11:
  if ( v7 < v25 )
  {
    v8 = (_WORD *)(v6 + 2 * v7);
    v21 = v7;
    v22 = 0;
    while ( 1 )
    {
      v9 = *v8;
      ++v8;
      LOWORD(v10) = v7;
      v11 = 0;
      v24 = v4;
      for ( i = v9 << 15; ; i -= 4 * _R4 )
      {
        v10 = (unsigned __int16)(v10 - 1);
        if ( v10 & 0x8000 )
          break;
        _R4 = *(_WORD *)(v22 + v5 + v11);
        _R1 = *(_WORD *)(v5 + v11);
        v11 -= 2;
        __asm { SMULBB.W        R4, R4, R1 }
      }
      v4 = v24;
      if ( v7 == v21 )
      {
        if ( i <= 0 )
        {
          LOWORD(result) = 0;
          return (signed __int16)result;
        }
        v20 = AKSC_invSqrt(i, &v28, v10, v21);
        *(_WORD *)(v26 + v24) = HIWORD(v20);
        *(_WORD *)(v27 + v24) = (unsigned __int16)v20 >> 1;
      }
      else
      {
        *(_WORD *)(v5 + 2 + v22) = 2
                                 * (*(_WORD *)(v26 + v24) * HIWORD(i)
                                  + (*(_WORD *)(v27 + v24) * (i >> 16) >> 15)
                                  + (*(_WORD *)(v26 + v24) * ((unsigned __int16)i >> 1) >> 15));
      }
      ++v21;
      v22 += 6;
      if ( v21 == v25 )
      {
        ++v7;
        v4 = v24 + 2;
        v5 += 8;
        v6 += 6;
        goto LABEL_11;
      }
    }
  }
  LOWORD(result) = 1;
  return (signed __int16)result;
}

//----- (000039DC) --------------------------------------------------------
int __fastcall AKSC_fitOnPlane(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // r4@1
  int v6; // r5@1
  int v7; // r10@1
  int v8; // r8@1
  int v9; // r1@1
  __int16 v10; // r11@1
  int v11; // r9@1
  int v12; // r12@1
  __int16 v16; // r0@10
  int v17; // r2@11
  signed int v18; // r3@11
  __int16 v19; // lr@12
  __int16 v20; // r12@12
  __int16 v21; // r1@12
  __int16 v22; // r3@14
  signed int v23; // r7@15
  signed int v24; // r3@16
  __int16 v25; // r0@13
  __int16 v26; // r0@13
  int v27; // r11@19
  int v28; // r8@19
  unsigned int v31; // r1@19
  unsigned int v32; // r8@19
  unsigned int v33; // r12@19
  int v34; // lr@19
  int v35; // r7@19
  signed __int16 v36; // r0@19
  int v37; // r3@19
  signed int v38; // r6@19
  int v39; // r2@19
  int v40; // r1@19
  int v41; // r10@20
  int v42; // r9@20
  int v43; // r7@20
  int result; // r0@26
  int v47; // [sp+Ch] [bp-64h]@1
  __int16 v48; // [sp+14h] [bp-5Ch]@10
  __int16 v49; // [sp+16h] [bp-5Ah]@10
  __int16 v50; // [sp+1Ah] [bp-56h]@10
  __int16 v51; // [sp+1Ch] [bp-54h]@10
  __int16 v52; // [sp+28h] [bp-48h]@11
  __int16 v53; // [sp+2Ah] [bp-46h]@11
  char v54; // [sp+30h] [bp-40h]@10
  char v55; // [sp+38h] [bp-38h]@10
  __int16 v56; // [sp+40h] [bp-30h]@10
  __int16 v57; // [sp+42h] [bp-2Eh]@10
  char v58; // [sp+46h] [bp-2Ah]@19

  v5 = a4;
  v6 = a1;
  v47 = a2;
  v7 = *(_WORD *)(a3 + 8);
  v8 = *(_WORD *)(a3 + 16);
  v9 = v7 * v8 - *(_WORD *)(a3 + 10) * *(_WORD *)(a3 + 10);
  v10 = *(_WORD *)a3;
  v11 = *(_WORD *)a3;
  v12 = v8 * v11 - *(_WORD *)(a3 + 12) * *(_WORD *)(a3 + 12);
  _VF = __OFSUB__(v12, v9);
  _ZF = v12 == v9;
  _NF = v12 - v9 < 0;
  if ( v12 <= v9 )
    v12 = 0;
  else
    v9 = v8 * v11 - *(_WORD *)(a3 + 12) * *(_WORD *)(a3 + 12);
  if ( !((unsigned __int8)(_NF ^ _VF) | _ZF) )
    v12 = 1;
  if ( v7 * v11 - *(_WORD *)(a3 + 2) * (signed int)*(_WORD *)(a3 + 2) > v9 )
  {
    v9 = v7 * v11 - *(_WORD *)(a3 + 2) * *(_WORD *)(a3 + 2);
    v12 = 2;
  }
  if ( v9 <= 0 )
    goto LABEL_27;
  if ( !v12 )
  {
    v48 = *(_WORD *)(a3 + 8);
    v50 = *(_WORD *)(a3 + 10);
    v16 = *(_WORD *)(a3 + 2);
    v49 = v50;
    v56 = -v16;
    v51 = *(_WORD *)(a3 + 16);
    v57 = -*(_WORD *)(a3 + 12);
    if ( (unsigned __int16)AKSC_cholDc((int)&v48, 2, (int)&v55, (int)&v54) )
    {
      AKSC_cholSl((int)&v48, 2, (int)&v55, (int)&v54, (int)&v56, (int)&v52);
      *(_WORD *)v5 = 2048;
      v17 = v52 >> 2;
      *(_WORD *)(v5 + 2) = v17;
      v18 = v53;
LABEL_16:
      v24 = v18 >> 2;
      goto LABEL_19;
    }
    goto LABEL_27;
  }
  _ZF = v12 == 1;
  v19 = *(_WORD *)(a3 + 10);
  v20 = *(_WORD *)(a3 + 2);
  v21 = *(_WORD *)(a3 + 12);
  if ( _ZF )
  {
    v48 = *(_WORD *)(a3 + 16);
    v49 = v21;
    v56 = -v19;
    v50 = v21;
    v22 = *(_WORD *)a3;
    v57 = -v20;
    v51 = v22;
    if ( (unsigned __int16)AKSC_cholDc((int)&v48, 2, (int)&v55, (int)&v54) )
    {
      AKSC_cholSl((int)&v48, 2, (int)&v55, (int)&v54, (int)&v56, (int)&v52);
      v23 = v53;
      *(_WORD *)(v5 + 2) = 2048;
      *(_WORD *)v5 = v23 >> 2;
      v18 = v52;
      goto LABEL_16;
    }
LABEL_27:
    LOWORD(result) = 0;
    return (signed __int16)result;
  }
  v49 = *(_WORD *)(a3 + 2);
  v48 = v10;
  v56 = -v21;
  v50 = *(_WORD *)(a3 + 6);
  v25 = *(_WORD *)(a3 + 8);
  v57 = -v19;
  v51 = v25;
  v26 = AKSC_cholDc((int)&v48, 2, (int)&v55, (int)&v54);
  if ( !v26 )
    goto LABEL_27;
  AKSC_cholSl((int)&v48, 2, (int)&v55, (int)&v54, (int)&v56, (int)&v52);
  v17 = v52 >> 2;
  *(_WORD *)v5 = v17;
  LOWORD(v24) = 2048;
  *(_WORD *)(v5 + 2) = v53 >> 2;
LABEL_19:
  v27 = *(_WORD *)v5;
  v28 = *(_WORD *)(v5 + 2);
  *(_WORD *)(v5 + 4) = v24;
  _R0 = AKSC_invSqrt(v27 * v27 + v28 * v28 + *(_WORD *)(v5 + 4) * *(_WORD *)(v5 + 4), &v58, v17, v24);
  __asm { SBFX.W          R0, R0, #8, #0x10 }
  v31 = *(_WORD *)(v5 + 4) * _R0;
  v32 = ((unsigned int)(*(_WORD *)v5 * _R0) >> 11) & 0xFFFF;
  v33 = ((unsigned int)(*(_WORD *)(v5 + 2) * _R0) >> 11) & 0xFFFF;
  *(_WORD *)v5 = (unsigned int)(*(_WORD *)v5 * _R0) >> 11;
  *(_WORD *)(v5 + 2) = v33;
  v34 = (v31 >> 11) & 0xFFFF;
  *(_WORD *)(v5 + 4) = v31 >> 11;
  v35 = *(_WORD *)(v6 + 4);
  v36 = 1;
  v37 = 0;
  v38 = *(_WORD *)v6 * v32 + *(_WORD *)(v6 + 2) * v33 + v35 * v34;
  v39 = *(_WORD *)v6 * v32 + *(_WORD *)(v6 + 2) * v33 + v35 * v34;
  v40 = *(_WORD *)v6 * v32 + *(_WORD *)(v6 + 2) * v33 + v35 * v34;
  while ( 1 )
  {
    v37 += 6;
    if ( v36 >= v47 )
      break;
    v41 = *(_WORD *)(v6 + v37 + 2);
    v42 = *(_WORD *)(v6 + v37 + 4);
    v43 = *(_WORD *)(v6 + v37) * v32 + v41 * v33 + v42 * v34;
    ++v36;
    if ( v40 < v43 )
      v40 = *(_WORD *)(v6 + v37) * v32 + v41 * v33 + v42 * v34;
    if ( v39 >= v43 )
      v39 = *(_WORD *)(v6 + v37) * v32 + v41 * v33 + v42 * v34;
    v38 += v43;
  }
  *a5 = (v40 - v39) >> 11;
  result = AKSC_div16(1, v47);
  _R2 = v38 >> 11;
  __asm { SMULBB.W        R6, R2, R0 }
  LOWORD(result) = 1;
  *(_WORD *)(v5 + 6) = -(_R6 >> 15);
  return (signed __int16)result;
}

//----- (00003C78) --------------------------------------------------------
signed int __fastcall AKSC_getCoeff(int a1, int a2, int a3, int a4)
{
  int v4; // r4@1
  int v5; // r5@1
  int v6; // r6@1
  __int16 v7; // r0@2
  int v8; // r3@2
  int v9; // lr@2
  unsigned int v10; // r2@2
  unsigned int v11; // r1@2
  unsigned int v12; // r7@2
  int v13; // r9@3
  int v14; // r10@3
  int v15; // r12@5
  int v16; // r7@5
  int v17; // r1@5
  int v18; // r3@5
  char *v19; // r0@5
  int v20; // r2@5
  int v21; // r3@8
  int v22; // r2@8
  int v23; // r10@9
  char *v24; // r11@9
  __int16 v25; // r8@9
  int v26; // r3@11
  int v27; // r9@11
  int v28; // r8@11
  int v29; // r0@11
  int v30; // r10@11
  int v31; // r12@11
  int v32; // r1@11
  int v33; // r2@11
  int v34; // r7@11
  int v35; // r10@12
  int v36; // lr@12
  int v37; // ST14_4@12
  char *v38; // r6@12
  int v39; // r11@12
  int v40; // r10@12
  int v41; // ST2C_4@12
  int v42; // r12@12
  int v43; // r6@12
  int v44; // r6@12
  int v45; // r5@14
  int *v46; // r11@14
  signed int v47; // r4@14
  signed int v48; // r3@14
  int v49; // r1@14
  int *v50; // r7@15
  signed int v51; // t1@15
  signed int v52; // ST10_4@15
  __int16 v53; // r0@15
  signed int v54; // r12@15
  int *v55; // r5@20
  signed int v56; // t1@21
  signed __int16 v57; // r0@21
  __int16 v58; // r1@21
  int v59; // r2@24
  __int16 v60; // r3@24
  int v61; // r3@24
  __int16 v62; // r5@24
  int v63; // r12@24
  signed int result; // r0@27
  int v65; // [sp+0h] [bp-190h]@11
  int v66; // [sp+Ch] [bp-184h]@15
  int v67; // [sp+14h] [bp-17Ch]@11
  int v68; // [sp+18h] [bp-178h]@11
  signed int v69; // [sp+1Ch] [bp-174h]@11
  signed int v70; // [sp+20h] [bp-170h]@11
  signed int v71; // [sp+24h] [bp-16Ch]@11
  int v72; // [sp+28h] [bp-168h]@1
  char v73[190]; // [sp+38h] [bp-158h]@9
  char v74; // [sp+F6h] [bp-9Ah]@5
  char v75[64]; // [sp+F8h] [bp-98h]@12
  int v76; // [sp+138h] [bp-58h]@11
  int v77; // [sp+13Ch] [bp-54h]@11
  int v78; // [sp+140h] [bp-50h]@11
  int v79; // [sp+144h] [bp-4Ch]@11
  int v80; // [sp+148h] [bp-48h]@11
  int v81; // [sp+14Ch] [bp-44h]@11
  int v82; // [sp+150h] [bp-40h]@11
  int v83; // [sp+154h] [bp-3Ch]@11
  int v84; // [sp+158h] [bp-38h]@11
  int v85; // [sp+15Ch] [bp-34h]@11
  int v86; // [sp+160h] [bp-30h]@11
  int v87; // [sp+164h] [bp-2Ch]@11

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v72 = a4;
  if ( a2 > 32 )
    goto LABEL_31;
  v7 = AKSC_div16(1, a2);
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  while ( v9 < v5 )
  {
    v13 = v4 + v8;
    v14 = *(_WORD *)(v4 + v8);
    ++v9;
    v8 += 6;
    v12 += v14 * v7;
    v11 += *(_WORD *)(v13 + 2) * v7;
    v10 += *(_WORD *)(v13 + 4) * v7;
  }
  v15 = (v10 >> 15) & 0xFFFF;
  v16 = (v12 >> 15) & 0xFFFF;
  v17 = (v11 >> 15) & 0xFFFF;
  v18 = v4;
  v19 = &v74;
  v20 = 0;
  while ( 1 )
  {
    v18 += 6;
    if ( v20 >= v5 )
      break;
    v20 = (unsigned __int16)(v20 + 1);
    *((_WORD *)v19 + 1) = (*(_WORD *)(v18 - 6) * (signed int)*(_WORD *)(v18 - 6)
                         + *(_WORD *)(v18 - 4) * (signed int)*(_WORD *)(v18 - 4)
                         + *(_WORD *)(v18 - 2) * (signed int)*(_WORD *)(v18 - 2)) >> 11;
    v19 += 2;
  }
  v21 = 0;
  v22 = 0;
  while ( v22 < v5 )
  {
    v23 = v4 + v21;
    *(_WORD *)&v73[v21] = *(_WORD *)(v4 + v21) - v16;
    v24 = &v73[v21];
    v25 = *(_WORD *)(v4 + v21 + 2);
    v22 = (unsigned __int16)(v22 + 1);
    v21 += 6;
    *((_WORD *)v24 + 1) = v25 - v17;
    *((_WORD *)v24 + 2) = *(_WORD *)(v23 + 4) - v15;
  }
  v26 = 0;
  v87 = 0;
  v86 = 0;
  v27 = 0;
  v85 = 0;
  v28 = 0;
  v84 = 0;
  v29 = 0;
  v80 = 0;
  v30 = 0;
  v76 = 0;
  v31 = 0;
  v79 = 0;
  v32 = 0;
  v77 = 0;
  v33 = 0;
  v82 = 0;
  v34 = 0;
  v78 = 0;
  v83 = 0;
  v81 = 0;
  v68 = 0;
  v70 = 0;
  v69 = 0;
  v71 = 0;
  v67 = 0;
  v65 = v6;
  while ( v34 < v5 )
  {
    v35 = *(_WORD *)(v4 + v33);
    v36 = *(_WORD *)&v73[v33];
    v37 = *(_WORD *)(v4 + v33 + 2);
    v38 = &v73[v33];
    v39 = *(_WORD *)(v4 + v33 + 4);
    v33 += 6;
    v26 += v35 * v36;
    v40 = *((_WORD *)v38 + 1);
    v32 += v40 * v39;
    v41 = *((_WORD *)v38 + 2);
    v28 += v39 * v41;
    v27 += v37 * v40;
    v68 = v31 + v36 * v39;
    v29 += v36 * v37;
    v42 = *(_WORD *)&v75[2 * v34++];
    v67 = v32;
    v71 += v36 * v42;
    v43 = v70 + v40 * v42;
    v30 = v29;
    v70 = v43;
    v44 = v69 + v41 * v42;
    v31 = v68;
    v69 = v44;
  }
  v45 = 0;
  v76 = v26;
  v83 = v32;
  v79 = v29;
  v80 = v27;
  v46 = &v78;
  v84 = v28;
  v77 = v30;
  v78 = v68;
  v82 = v31;
  v47 = 32;
  v81 = v67;
  v48 = 3;
  v85 = v71 >> 1;
  v49 = v65;
  v86 = v70 >> 1;
  v87 = v69 >> 1;
  do
  {
    v50 = &v76 + v48 * v45 - 1;
    do
    {
      v51 = v50[1];
      ++v50;
      v66 = v49;
      v52 = v48;
      v53 = AKSC_norm32(v51);
      v54 = v47;
      v49 = v66;
      v48 = v52;
      if ( v47 >= v53 )
        v54 = v53;
      v47 = v54;
    }
    while ( v50 != v46 );
    ++v45;
    v46 = v50 + 3;
  }
  while ( v45 != 3 );
  v55 = &v84;
  do
  {
    v56 = v55[1];
    ++v55;
    v57 = AKSC_norm32(v56);
    v58 = v47;
    if ( v57 < (signed __int16)v47 )
      v58 = v57;
    LOWORD(v47) = v58;
  }
  while ( v55 != &v87 );
  v59 = v66 + 6;
  v60 = v77 << v58 >> 18;
  *(_WORD *)(v66 + 6) = v60;
  *(_WORD *)(v66 + 2) = v60;
  v61 = v66 + 12;
  v62 = v78 << v58 >> 18;
  *(_WORD *)(v66 + 12) = v62;
  *(_WORD *)(v66 + 4) = v62;
  v63 = v67 << v58 >> 18;
  *(_WORD *)(v61 + 2) = v63;
  *(_WORD *)(v59 + 4) = v63;
  *(_WORD *)v66 = v76 << v58 >> 18;
  *(_WORD *)(v59 + 2) = v80 << v58 >> 18;
  *(_WORD *)(v61 + 4) = v84 << v58 >> 18;
  *(_WORD *)v72 = v71 >> 1 << v58 >> 18;
  *(_WORD *)(v72 + 2) = v70 >> 1 << v58 >> 18;
  *(_WORD *)(v72 + 4) = v69 >> 1 << v58 >> 18;
  if ( (signed int)*(_WORD *)v66 <= 5 || (signed int)*(_WORD *)(v66 + 8) <= 5 || (signed int)*(_WORD *)(v66 + 16) <= 5 )
LABEL_31:
    result = 0;
  else
    result = 4;
  return result;
}
// 3C78: using guessed type char var_158[190];
// 3C78: using guessed type char var_98[64];

//----- (00003F60) --------------------------------------------------------
int __fastcall sub_3F60(int result, signed int a2, int a3, int a4)
{
  __int16 i; // r6@1
  int v5; // r5@2
  int v6; // r4@6

  for ( i = 0; i < a2; ++i )
  {
    v6 = 0;
    do
    {
      v5 = *(_WORD *)(result + v6) + *(_WORD *)(a3 + v6) * a4;
      if ( (v5 + 0x8000 < 0) ^ __OFADD__(v5, 0x8000) )
      {
        LOWORD(v5) = -32768;
      }
      else if ( v5 >= 0x7FFF )
      {
        LOWORD(v5) = 0x7FFF;
      }
      *(_WORD *)(result + v6) = v5;
      v6 += 2;
    }
    while ( v6 != 6 );
    result += 6;
  }
  return result;
}

//----- (00003FA4) --------------------------------------------------------
char *__fastcall AKSC_SetHDOELevel(char *result, char *a2, __int16 a3, int a4)
{
  char *v4; // r4@1
  char *v5; // r6@1
  signed int v6; // r7@1
  int v7; // r8@2
  char *v8; // r0@3
  int v9; // r8@4
  char *v10; // r0@5
  char *v11; // r8@6
  int v12; // r9@6
  void *v13; // r0@7
  signed __int16 v14; // r3@9

  v4 = result;
  v5 = a2;
  LOWORD(v6) = a3;
  if ( a4 )
  {
    v7 = 0;
    do
    {
      v8 = &v4[v7 + 4];
      v7 += 6;
      memcpy(v8, &I16V_INIT_VALUE, 6u);
    }
    while ( v7 != 192 );
    v9 = 0;
    do
    {
      v10 = &v4[v9 + 196];
      v9 += 6;
      memcpy(v10, &I16V_INIT_VALUE, 6u);
    }
    while ( v9 != 96 );
    v11 = v4;
    v12 = 0;
    do
    {
      ++v12;
      memcpy(v11 + 292, &I16V_INIT_VALUE, 6u);
      v13 = v11 + 400;
      v11 += 6;
      result = (char *)memcpy(v13, &I16V_INIT_VALUE, 6u);
    }
    while ( v12 != 16 );
  }
  v6 = (signed __int16)v6;
  if ( (signed __int16)v6 > 0 )
  {
    *((_WORD *)v4 + 194) = 1;
    result = AKSC_buffer(v5, 16, 1, (int)(v4 + 292));
    if ( v6 <= 3 )
    {
      *((_WORD *)v4 + 195) = v6 - 1;
      return result;
    }
    v14 = 2;
  }
  else
  {
    v14 = 0;
    *((_WORD *)v4 + 194) = 0;
  }
  *((_WORD *)v4 + 195) = v14;
  return result;
}

//----- (00004074) --------------------------------------------------------
char *__fastcall zzAKSC_InitHDOEProcPrmsS3(int a1, int a2, int a3, __int16 a4, char *a5, __int16 a6)
{
  int v6; // r4@1
  __int16 v7; // r5@1
  char *result; // r0@1

  v6 = a1;
  v7 = a4;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 396) = a3;
  result = AKSC_SetHDOELevel((char *)a1, a5, a6, 1);
  *(_WORD *)(v6 + 394) = v7;
  *(_WORD *)(v6 + 392) = 0;
  *(_WORD *)(v6 + 496) = 0;
  *(_WORD *)(v6 + 498) = 0;
  return result;
}

//----- (000040A0) --------------------------------------------------------
signed int __fastcall sub_40A0(char *a1, _WORD *a2, _WORD *a3, int a4, int a5, _WORD *a6, _WORD *a7, __int16 a8)
{
  char *v8; // r7@1
  _WORD *v9; // r4@1
  int v10; // r5@1
  signed int v11; // r3@5
  int v12; // r2@10
  char *v13; // r8@13
  int v14; // r11@13
  signed int v15; // r0@13
  char *v16; // r3@13
  __int16 v17; // lr@14
  signed int v18; // r0@16
  signed int v19; // r7@17
  unsigned int v20; // r1@18
  unsigned int v21; // r10@18
  unsigned int v22; // r3@18
  int v23; // r8@18
  int v24; // r10@18
  int v25; // r8@18
  int v26; // r7@18
  int v27; // r4@18
  int v28; // r9@18
  signed __int16 v29; // r5@18
  int v30; // r10@18
  int v31; // r3@19
  int v32; // r2@19
  unsigned int v33; // r0@19
  int v34; // r0@19
  __int16 v35; // r0@24
  int v36; // r0@24
  signed int v44; // r3@31
  signed int v45; // r6@34
  signed int v46; // r6@40
  int v48; // [sp+Ch] [bp-ACh]@0
  int v49; // [sp+10h] [bp-A8h]@1
  _WORD *v50; // [sp+14h] [bp-A4h]@18
  char v51; // [sp+18h] [bp-A0h]@13
  char v52; // [sp+2Ch] [bp-8Ch]@13
  __int16 v53; // [sp+3Eh] [bp-7Ah]@14
  char v54; // [sp+40h] [bp-78h]@31
  char v55; // [sp+48h] [bp-70h]@13
  __int16 v56; // [sp+50h] [bp-68h]@18
  __int16 v57; // [sp+52h] [bp-66h]@18
  __int16 v58; // [sp+54h] [bp-64h]@18
  __int16 v59; // [sp+58h] [bp-60h]@16
  __int16 v60; // [sp+5Ah] [bp-5Eh]@32
  __int16 v61; // [sp+5Ch] [bp-5Ch]@33
  unsigned __int16 v62; // [sp+60h] [bp-58h]@16
  unsigned __int16 v63; // [sp+62h] [bp-56h]@35
  __int16 v64; // [sp+64h] [bp-54h]@36
  char v65; // [sp+68h] [bp-50h]@13
  char v66; // [sp+70h] [bp-48h]@13
  char v67; // [sp+78h] [bp-40h]@13
  char v68; // [sp+80h] [bp-38h]@13
  int v69; // [sp+88h] [bp-30h]@2
  __int16 v70; // [sp+8Ch] [bp-2Ch]@2
  __int16 v71; // [sp+8Eh] [bp-2Ah]@38

  v8 = a1;
  v9 = a2;
  v49 = a4;
  v10 = (int)a3;
  if ( (signed int)*a2 <= 0 )
    return 0;
  v69 = 0;
  v70 = 0;
  *a7 = 0;
  if ( a8 )
  {
    if ( a8 == 1 )
      goto LABEL_10;
  }
  else
  {
    LOWORD(v69) = AKSC_abs16(*a3 - *(_WORD *)a1);
    HIWORD(v69) = AKSC_abs16((signed __int16)(*(_WORD *)(v10 + 2) - *((_WORD *)v8 + 1)));
    v70 = AKSC_abs16((signed __int16)(*(_WORD *)(v10 + 4) - *((_WORD *)v8 + 2)));
  }
  v11 = v9[2];
  if ( (signed __int16)v69 < v11 || SHIWORD(v69) < v11 || v70 < v11 )
    return 0;
  if ( !a8 )
  {
    AKSC_buffer(v8, *v9, 1, v10);
    *a7 = 1;
  }
LABEL_10:
  v12 = v10 + 6 * (*v9 - 1);
  if ( *(_WORD *)v12 == 0x7FFF && *(_WORD *)(v12 + 2) == 0x7FFF && *(_WORD *)(v12 + 4) == 0x7FFF )
    return 0;
  AKSC_vectorCalc(v10, *v9, (int)&v68, (int)&v67, (int)&v66, (int)&v65);
  v13 = &v52;
  sub_3F60(v10, *v9, (int)&v66, -1);
  v14 = *v9;
  v15 = AKSC_getCoeff(v10, v14, (int)&v52, (int)&v55);
  v16 = &v51;
  do
  {
    *(_WORD *)v16 = *(_WORD *)v13;
    *((_WORD *)v16 + 1) = *((_WORD *)v13 + 1);
    v17 = *((_WORD *)v13 + 2);
    v13 += 6;
    *((_WORD *)v16 + 2) = v17;
    v16 += 6;
  }
  while ( (__int16 *)v13 != &v53 );
  if ( v15 == 4 )
  {
    v18 = (unsigned __int16)AKSC_cholDc((int)&v51, 3, (int)&v59, (int)&v62);
    if ( (_WORD)v18 )
    {
      AKSC_cholSl((int)&v51, 3, (int)&v59, (int)&v62, (int)&v55, (int)&v56);
      v20 = ((unsigned int)v56 >> 2) & 0xFFFF;
      *(_WORD *)a5 = (unsigned int)v56 >> 2;
      v21 = ((unsigned int)v57 >> 2) & 0xFFFF;
      *(_WORD *)(a5 + 2) = (unsigned int)v57 >> 2;
      v22 = ((unsigned int)v58 >> 2) & 0xFFFF;
      *(_WORD *)(a5 + 4) = (unsigned int)v58 >> 2;
      v23 = *(_WORD *)(v10 + 2) - v21;
      v24 = *(_WORD *)(v10 + 4) - (signed __int16)v22;
      v25 = (*(_WORD *)v10 - v20) * (*(_WORD *)v10 - v20) + v23 * v23 + v24 * v24;
      v26 = v10;
      v50 = v9;
      v27 = 0;
      v28 = AKSC_sqrt32(v25);
      v29 = 1;
      v30 = v28;
      while ( 1 )
      {
        v27 += 6;
        if ( v29 >= v14 )
          break;
        v31 = *(_WORD *)(v26 + v27) - *(_WORD *)a5;
        v32 = *(_WORD *)(v26 + v27 + 2) - *(_WORD *)(a5 + 2);
        ++v29;
        v33 = v31 * v31
            + v32 * v32
            + (*(_WORD *)(v26 + v27 + 4) - *(_WORD *)(a5 + 4)) * (*(_WORD *)(v26 + v27 + 4) - *(_WORD *)(a5 + 4));
        v25 += v33;
        v34 = AKSC_sqrt32(v33);
        if ( v34 >= v28 )
          v28 = v34;
        if ( v34 < v30 )
          v30 = v34;
      }
      v9 = v50;
      v10 = v26;
      v19 = 4;
      v35 = AKSC_div16(1, v14);
      v36 = AKSC_sqrt32(((((unsigned int)v25 >> 6) & 1) + (v25 >> 7)) * ((((unsigned int)v35 >> 3) & 1) + (v35 >> 4)));
      *a6 = (((unsigned int)v36 >> 1) & 1) + (v36 >> 2);
      v48 = v28 - v30;
    }
    else
    {
      *(_WORD *)(a5 + 4) = 0;
      v19 = v18;
      *(_WORD *)(a5 + 2) = 0;
      *(_WORD *)a5 = 0;
      *a6 = 0;
    }
  }
  else
  {
    *(_WORD *)(a5 + 4) = 0;
    *(_WORD *)(a5 + 2) = 0;
    *(_WORD *)a5 = 0;
    *a6 = 0;
    v19 = 0;
  }
  sub_3F60(a5, 1, (int)&v66, 1);
  AKSC_buffer((char *)a5, v9[1], 1, v49);
  if ( !v19 )
    goto LABEL_47;
  _R3 = *a6;
  if ( v19 != 4 )
    goto LABEL_47;
  if ( v9[8] >= (signed __int16)_R3 )
    goto LABEL_47;
  if ( v9[7] <= (signed __int16)_R3 )
    goto LABEL_47;
  _R12 = v9[9];
  __asm { SMULBB.W        R3, R12, R3 }
  if ( _R3 <= v48 << 11 )
    goto LABEL_47;
  AKSC_vectorCalc(v49, v9[1], (int)&v56, (int)&v55, (int)&v54, (int)&v59);
  v44 = v9[5];
  if ( v59 < v44
    && v60 < v44
    && v61 < v44
    && (AKSC_vectorCalc(v10, *v9, (int)&v56, (int)&v55, (int)&v54, (int)&v62), v45 = v9[3], (signed __int16)v62 > v45)
    && (signed __int16)v63 > v45
    && v64 > v45
    && v62 + v63 + v64 >= v9[4]
    && (unsigned __int16)AKSC_fitOnPlane(v10, *v9, (int)&v52, (int)&v51, &v71)
    && v71 > (signed int)v9[6] )
  {
    v46 = 1;
  }
  else
  {
LABEL_47:
    v46 = 0;
  }
  sub_3F60(v10, *v9, (int)&v66, 1);
  return v46;
}

//----- (00004460) --------------------------------------------------------
int __fastcall zzAKSC_HDOEProcessS3(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9, _DWORD *a10)
{
  int v10; // r7@1
  int v11; // r5@1
  int v12; // r4@1
  int v13; // r6@1
  signed int v14; // r8@1
  int v15; // r1@3
  char *v16; // r9@3
  signed int v17; // r8@3
  char v18; // r10@4
  int v19; // t1@4
  int v20; // ST1C_4@5
  int v21; // r11@8
  int v22; // r1@10
  char *v23; // r9@10
  signed int v24; // r8@10
  char v25; // r10@11
  int v26; // t1@11
  int v27; // ST1C_4@12
  int v28; // r11@15
  int v29; // r9@17
  int v30; // r8@17
  int v31; // r10@17
  int v32; // r3@17
  int v33; // r3@23
  int v34; // r3@29
  int v35; // r3@35
  int v36; // r2@43
  int v37; // r2@45
  int v38; // r3@47
  int v45; // r6@53
  int v46; // r3@53
  signed __int16 v48; // r10@53
  char *v54; // r7@55
  int v56; // r2@61
  __int16 v57; // r9@61
  __int16 v58; // r12@61
  int v59; // r1@62
  char *v60; // lr@62
  int v61; // r0@62
  int v62; // r1@62
  int v63; // r2@62
  int v64; // r3@62
  int v65; // r1@62
  int v66; // r2@62
  __int16 v67; // ST1C_2@63
  signed int v68; // r2@66
  __int16 v69; // r3@69
  signed int v70; // r2@70
  char *v76; // r7@74
  int v78; // r1@81
  signed int v79; // r3@82
  int v80; // r3@85
  int v81; // r0@85
  int v82; // r2@85
  int v83; // r1@85
  signed int v84; // r12@85
  char *v85; // r9@85
  unsigned __int16 v86; // r0@89
  signed int v87; // r12@89
  int v88; // r0@89
  __int16 v89; // r1@95
  signed __int16 v90; // r5@97
  int v91; // r3@97
  int result; // r0@102
  int v94; // [sp+14h] [bp-1DCh]@85
  int v95; // [sp+28h] [bp-1C8h]@17
  int v96; // [sp+28h] [bp-1C8h]@85
  int v97; // [sp+2Ch] [bp-1C4h]@17
  _WORD *v98; // [sp+2Ch] [bp-1C4h]@53
  int v99; // [sp+30h] [bp-1C0h]@17
  int v100; // [sp+34h] [bp-1BCh]@17
  int v101; // [sp+38h] [bp-1B8h]@53
  int v102; // [sp+40h] [bp-1B0h]@53
  _WORD *v103; // [sp+44h] [bp-1ACh]@53
  int v104; // [sp+48h] [bp-1A8h]@53
  _WORD *v105; // [sp+4Ch] [bp-1A4h]@53
  int v106; // [sp+50h] [bp-1A0h]@53
  int v107; // [sp+5Ch] [bp-194h]@53
  char dest[168]; // [sp+64h] [bp-18Ch]@1
  char v109; // [sp+10Ch] [bp-E4h]@1
  int v110; // [sp+160h] [bp-90h]@62
  int v111; // [sp+164h] [bp-8Ch]@62
  int v112; // [sp+168h] [bp-88h]@62
  int v113; // [sp+16Ch] [bp-84h]@62
  int v114; // [sp+170h] [bp-80h]@62
  int v115; // [sp+174h] [bp-7Ch]@62
  int v116; // [sp+178h] [bp-78h]@62
  unsigned __int16 v117; // [sp+17Ch] [bp-74h]@1
  __int16 v118; // [sp+17Eh] [bp-72h]@1
  __int16 v119; // [sp+184h] [bp-6Ch]@53
  __int16 v120; // [sp+186h] [bp-6Ah]@53
  __int16 v121; // [sp+188h] [bp-68h]@53
  __int16 v122; // [sp+18Ah] [bp-66h]@64
  char v123[16]; // [sp+18Ch] [bp-64h]@1
  char v124[16]; // [sp+19Ch] [bp-54h]@1
  char v125[12]; // [sp+1ACh] [bp-44h]@1
  char v126[12]; // [sp+1B8h] [bp-38h]@1
  int v127; // [sp+1C4h] [bp-2Ch]@1
  char v128[40]; // [sp+1C8h] [bp-28h]@62

  v10 = a3;
  v11 = a2;
  v12 = a4;
  v13 = a1;
  v14 = 2;
  v127 = _stack_chk_guard;
  memcpy(dest, &unk_5688, 0xA8u);
  memcpy(&v109, &unk_5730, 0x54u);
  memcpy(v126, &unk_5619, 0xBu);
  memcpy(v124, &unk_5624, 0xDu);
  memcpy(v125, "ASAHIKASEI", 0xBu);
  memcpy(v123, "OPPO_63_R601", 0xDu);
  v118 = 0;
  v117 = 1;
  do
  {
    ++v14;
    sub_2BBC((int)&v117);
  }
  while ( v14 != 10 );
  v15 = a9;
  v16 = v126;
  v17 = 0;
  do
  {
    v19 = (unsigned __int8)*v16++;
    v18 = v19;
    if ( !v19 )
      break;
    v20 = v15;
    sub_2BBC((int)&v117);
    ++v17;
    *(v16 - 1) = v18 - 65 - v117;
    v15 = v20;
  }
  while ( v17 != 16 );
  v21 = v15;
  while ( v17 <= 15 )
  {
    sub_2BBC((int)&v117);
    ++v17;
  }
  v22 = v21;
  v23 = v124;
  v24 = 0;
  do
  {
    v26 = (unsigned __int8)*v23++;
    v25 = v26;
    if ( !v26 )
      break;
    ++v24;
    v27 = v22;
    sub_2BBC((int)&v117);
    *(v23 - 1) = v25 - 60 - v117;
    v22 = v27;
  }
  while ( v24 != 16 );
  v28 = v22;
  while ( v24 <= 15 )
  {
    sub_2BBC((int)&v117);
    ++v24;
  }
  sub_2BBC((int)&v117);
  v29 = v117;
  sub_2BBC((int)&v117);
  v30 = v117;
  sub_2BBC((int)&v117);
  v31 = v117;
  sub_2BBC((int)&v117);
  v100 = v117;
  sub_2BBC((int)&v117);
  v99 = v117;
  sub_2BBC((int)&v117);
  v97 = v117;
  sub_2BBC((int)&v117);
  v95 = v117;
  sub_2BBC((int)&v117);
  v32 = 0;
  do
  {
    if ( !v126[v32] && !*(_BYTE *)(v13 + v32) )
      goto LABEL_23;
    if ( *(_BYTE *)(v13 + v32) != (unsigned __int8)v126[v32] )
      goto LABEL_100;
    ++v32;
  }
  while ( v32 != 16 );
  if ( *(_BYTE *)(v13 + 16) )
  {
LABEL_100:
    v90 = -32768;
    goto LABEL_102;
  }
LABEL_23:
  v33 = 0;
  while ( v124[v33] || *(_BYTE *)(v11 + v33) )
  {
    if ( *(_BYTE *)(v11 + v33) != (unsigned __int8)v124[v33] )
      goto LABEL_100;
    if ( ++v33 == 16 )
    {
      if ( *(_BYTE *)(v11 + 16) )
        goto LABEL_100;
      break;
    }
  }
  v34 = 0;
  while ( v125[v34] || *(_BYTE *)(v13 + v34) )
  {
    if ( *(_BYTE *)(v13 + v34) != (unsigned __int8)v125[v34] )
      goto LABEL_100;
    if ( ++v34 == 16 )
    {
      if ( *(_BYTE *)(v13 + 16) )
        goto LABEL_100;
      break;
    }
  }
  v35 = 0;
  while ( v123[v35] || *(_BYTE *)(v11 + v35) )
  {
    if ( *(_BYTE *)(v11 + v35) != (unsigned __int8)v123[v35] )
      goto LABEL_100;
    if ( ++v35 == 16 )
    {
      if ( *(_BYTE *)(v11 + 16) )
        goto LABEL_100;
      break;
    }
  }
  if ( *(_WORD *)v10 != 12091 - v29 )
    goto LABEL_100;
  if ( *(_WORD *)(v10 + 2) != -26131 - v30 )
    goto LABEL_100;
  v36 = *(_WORD *)(v10 + 4);
  if ( v36 < -23074 - v31 )
    goto LABEL_100;
  if ( 16512 - v100 < v36 )
    goto LABEL_100;
  v37 = *(_WORD *)(v10 + 6);
  if ( v37 < -6816 - v99 )
    goto LABEL_100;
  if ( 9695 - v97 < v37 )
    goto LABEL_100;
  v38 = *(_WORD *)(v10 + 8);
  if ( v38 < 2625 - v95 || (signed __int16)(12319 - v117) < v38 )
    goto LABEL_100;
  _R3 = (unsigned __int16)(a6 - 1);
  if ( _R3 > 0x1F
    || (unsigned int)*(_WORD *)(v12 + 394) > 1
    || (unsigned int)*(_WORD *)(v12 + 388) > 0x10
    || (unsigned int)*(_WORD *)(v12 + 390) > 2 )
  {
    v90 = 0;
  }
  else
  {
    v104 = v12 + 196;
    _R0 = 6;
    __asm { SMULBB.W        R10, R3, R0 }
    v103 = (_WORD *)(v12 + 392);
    v101 = -6 * _R3 - 6;
    v106 = v12 + 400;
    v45 = 0;
    v46 = a5 + _R10;
    _R8 = 28;
    v48 = 0;
    v105 = (_WORD *)(v12 + 496);
    v121 = 0;
    v120 = 0;
    v119 = 0;
    v98 = (_WORD *)(v12 + 4);
    v102 = v12 + 292;
    v107 = v46;
    do
    {
      _R3 = *(_WORD *)(v12 + 394);
      _R1 = *(_WORD *)(v12 + 390);
      if ( *(_DWORD *)v12 )
      {
        __asm { SMULBB.W        R9, R1, R8 }
        v54 = (char *)(*(_DWORD *)(*(_DWORD *)v12 + 4 * _R3) + _R9);
      }
      else
      {
        _R12 = 84;
        __asm
        {
          SMULBB.W        R7, R1, R8
          SMULBB.W        R2, R3, R12
        }
        v54 = &dest[_R7] + _R2;
      }
      if ( !a7 )
        LOWORD(_R3) = 0;
      if ( !a8 )
        LOWORD(_R1) = 0;
      v56 = *(_DWORD *)(v12 + 396);
      _R3 = (signed __int16)_R3;
      v57 = *(_WORD *)v54;
      _R1 = (signed __int16)_R1;
      v58 = *((_WORD *)v54 + 2);
      if ( v56 )
      {
        v67 = *((_WORD *)v54 + 2);
        memcpy(&v110, (const void *)(*(_DWORD *)(v56 + 4 * _R3) + 28 * _R1), 0x1Cu);
        v58 = v67;
      }
      else
      {
        v59 = 84 * _R3 + 28 * _R1;
        v60 = &v128[v59 - 188];
        v61 = *(_DWORD *)v60;
        v62 = *(_DWORD *)&v128[v59 - 184];
        v63 = *((_DWORD *)v60 + 2);
        v64 = *((_DWORD *)v60 + 3);
        v60 += 16;
        v110 = v61;
        v111 = v62;
        v112 = v63;
        v113 = v64;
        v65 = *((_DWORD *)v60 + 1);
        v66 = *((_DWORD *)v60 + 2);
        v114 = *(_DWORD *)v60;
        v115 = v65;
        v116 = v66;
      }
      LOWORD(v110) = v57;
      LOWORD(v111) = v58;
      if ( sub_40A0((char *)(v107 + v45), &v110, v98, v106, (int)&v119, v105, &v122, 0) == 1 )
      {
        if ( (signed int)*(_WORD *)(v12 + 394) <= 0 )
        {
          v68 = *((_WORD *)v54 + 12);
          if ( v68 >= 0 && *(_WORD *)(v12 + 496) >= v68 )
            ++*(_WORD *)(v12 + 394);
        }
        v69 = *(_WORD *)(v12 + 394);
        if ( v69 > 0 )
        {
          v70 = *((_WORD *)v54 + 13);
          if ( v70 >= 0 && *(_WORD *)(v12 + 496) <= v70 )
            *(_WORD *)(v12 + 394) = v69 - 1;
        }
      }
      _R2 = *(_WORD *)(v12 + 394);
      _R7 = *(_WORD *)(v12 + 390);
      if ( *(_DWORD *)v12 )
      {
        __asm { SMULBB.W        R7, R7, R8 }
        v76 = (char *)(*(_DWORD *)(*(_DWORD *)v12 + 4 * _R2) + _R7);
      }
      else
      {
        _R1 = 84;
        __asm
        {
          SMULBB.W        R0, R7, R8
          SMULBB.W        R12, R2, R1
        }
        v76 = &dest[_R0] + _R12;
      }
      if ( v122 == 1 && sub_40A0((char *)(v107 + v45), v76, v98, v104, (int)&v119, v103, &v122, 1) == 1 )
      {
        ++v48;
        if ( (signed int)*(_WORD *)(v12 + 388) <= 15 )
          ++*(_WORD *)(v12 + 388);
        else
          *(_WORD *)(v12 + 388) = 16;
        AKSC_buffer((char *)&v119, 16, 1, v102);
        v78 = *(_WORD *)(v12 + 388);
        if ( v78 > 1 && (v79 = *((_WORD *)v76 + 11), v79 > 1) )
        {
          if ( v78 >= v79 )
          {
            v86 = AKSC_div16(1, *((_WORD *)v76 + 11));
            v80 = 0;
            v83 = 0;
            v87 = 0;
            v96 = v86;
            v88 = v12;
            v82 = 0;
            v94 = v12;
            v85 = v76;
            while ( 1 )
            {
              v88 += 6;
              if ( v87 >= *((_WORD *)v76 + 11) )
                break;
              ++v87;
              v83 += *(_WORD *)(v88 + 286);
              v82 += *(_WORD *)(v88 + 288);
              v80 += *(_WORD *)(v88 + 290);
            }
          }
          else
          {
            v96 = (unsigned __int16)AKSC_div16(1, v78);
            v80 = 0;
            v81 = v12;
            v82 = 0;
            v83 = 0;
            v84 = 0;
            v85 = v76;
            v94 = v12;
            while ( 1 )
            {
              v81 += 6;
              if ( v84 >= *(_WORD *)(v12 + 388) )
                break;
              v83 += *(_WORD *)(v81 + 286);
              v82 += *(_WORD *)(v81 + 288);
              v80 += *(_WORD *)(v81 + 290);
              ++v84;
            }
          }
          v76 = v85;
          v12 = v94;
          *(_WORD *)v28 = v83 * v96 >> 15;
          *(_WORD *)(v28 + 2) = v82 * v96 >> 15;
          *(_WORD *)(v28 + 4) = v80 * v96 >> 15;
        }
        else
        {
          memcpy((void *)v28, &v119, 6u);
        }
        if ( *(_WORD *)(v12 + 388) >= (signed int)*((_WORD *)v76 + 10) && (signed int)*(_WORD *)(v12 + 390) <= 1 )
        {
          v89 = *(_WORD *)(v12 + 390);
          *(_WORD *)(v12 + 388) = 0;
          *(_WORD *)(v12 + 390) = v89 + 1;
        }
      }
      v45 -= 6;
    }
    while ( v45 != v101 );
    v90 = v48;
    v91 = *(_WORD *)(v12 + 390);
    if ( *(_WORD *)(v12 + 388) )
      *a10 = v91 + 1;
    else
      *a10 = v91;
  }
LABEL_102:
  result = v90;
  if ( v127 != _stack_chk_guard )
    _stack_chk_fail(v90);
  return result;
}
// 109C: using guessed type int __fastcall _stack_chk_fail(_DWORD);
// 4460: using guessed type char dest[168];
// 4460: using guessed type char var_28[40];
// 4460: using guessed type char var_38[12];
// 4460: using guessed type char var_54[16];
// 4460: using guessed type char var_44[12];
// 4460: using guessed type char var_64[16];

//----- (00004B2C) --------------------------------------------------------
int __fastcall AKSC_InitHFlucCheck(_WORD *a1, const void *a2, int a3)
{
  int v3; // r5@1
  _WORD *v4; // r4@1
  int result; // r0@2

  v3 = a3;
  v4 = a1;
  memcpy(a1, a2, 6u);
  if ( v3 >= 0 )
  {
    LOWORD(result) = 1;
    v4[3] = v3;
  }
  else
  {
    LOWORD(result) = 0;
    v4[3] = 0;
  }
  return (signed __int16)result;
}

//----- (00004B50) --------------------------------------------------------
int __fastcall AKSC_HFlucCheck(int a1, int a2)
{
  int v2; // r3@1
  signed int v3; // r4@1
  signed int v4; // r4@2
  signed int v5; // r4@3
  int result; // r0@4

  v2 = *(_WORD *)(a1 + 6);
  v3 = *(_WORD *)a2 - *(_WORD *)a1;
  if ( (v3 ^ (v3 >> 31)) - (v3 >> 31) >= v2
    || (v4 = *(_WORD *)(a2 + 2) - *(_WORD *)(a1 + 2), (v4 ^ (v4 >> 31)) - (v4 >> 31) >= v2)
    || (v5 = *(_WORD *)(a2 + 4) - *(_WORD *)(a1 + 4), (v5 ^ (v5 >> 31)) - (v5 >> 31) >= v2) )
  {
    memcpy((void *)a1, (const void *)a2, 6u);
    LOWORD(result) = 1;
  }
  else
  {
    LOWORD(result) = 0;
  }
  return (signed __int16)result;
}

//----- (00004BB0) --------------------------------------------------------
int __fastcall AKSC_TransByHbase(int result, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // r4@1
  int v6; // r5@1
  int v7; // r6@2
  signed __int16 v8; // r6@3

  *a5 = 0;
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = *(_DWORD *)(result + v6) + *(_DWORD *)(a4 + v6) - *(_DWORD *)(a2 + v6);
    *(_DWORD *)(a4 + v6) = v7;
    if ( (v7 + 0x8000 < 0) ^ __OFADD__(v7, 0x8000) )
    {
      v8 = -32768;
    }
    else
    {
      if ( v7 <= 0x7FFF )
      {
        *(_WORD *)(a3 + v5) = v7;
        goto LABEL_8;
      }
      v8 = 0x7FFF;
    }
    *(_WORD *)(a3 + v5) = v8;
    *a5 = 1;
LABEL_8:
    v5 += 2;
    v6 += 4;
  }
  while ( v5 != 6 );
  return result;
}

//----- (00004C00) --------------------------------------------------------
int __fastcall AKSC_HOffsetCal(int a1, int a2)
{
  int v2; // r3@1
  int v3; // r2@1
  int v4; // r4@2
  int v5; // r8@2
  int v6; // r6@2
  int v7; // r12@2
  int v8; // r4@2
  char *v9; // r6@2
  __int16 *v10; // r12@2
  char *v11; // r4@2
  int v12; // r8@3
  int v13; // t1@3
  signed int v14; // r8@5
  int result; // r0@6
  int v16; // r6@8
  int v17; // r10@8
  int v18; // r12@8
  int v19; // r8@8
  int v20; // r6@8
  __int16 *v21; // r12@8
  char *v22; // r6@8
  int v23; // r8@9
  char *v24; // r6@10
  int v25; // r12@11
  int v26; // t1@11
  signed int v27; // r6@15
  unsigned __int16 v28; // r4@21
  int v29; // [sp+Ch] [bp-4Ch]@2
  int v30; // [sp+10h] [bp-48h]@2
  int v31; // [sp+14h] [bp-44h]@2
  char v32; // [sp+18h] [bp-40h]@7
  __int16 v33; // [sp+20h] [bp-38h]@8
  __int16 v34; // [sp+22h] [bp-36h]@10
  __int16 v35; // [sp+24h] [bp-34h]@10
  unsigned __int16 v36; // [sp+28h] [bp-30h]@2
  unsigned __int16 v37; // [sp+2Ah] [bp-2Eh]@21
  __int16 v38; // [sp+2Ch] [bp-2Ch]@16
  char v39; // [sp+30h] [bp-28h]@18

  v2 = a1;
  v3 = 0;
  do
  {
    v4 = *(_WORD *)(v2 + 6);
    v5 = *(_WORD *)(a1 + v3);
    v29 = v5 - v4;
    v6 = *(_WORD *)(v2 + 12);
    v7 = v4 - v6;
    v8 = v6 - v5;
    v30 = v7;
    v9 = (char *)&v29;
    v31 = v8;
    v10 = (__int16 *)&v36;
    v11 = (char *)&v29;
    do
    {
      v13 = *(_DWORD *)v9;
      v9 += 4;
      v12 = v13;
      if ( v13 < 0 )
        *((_DWORD *)v9 - 1) = -v12;
      v14 = *((_DWORD *)v9 - 1);
      if ( v14 > 0x7FFF )
      {
        LOWORD(result) = 0;
        return (signed __int16)result;
      }
      *v10 = v14;
      ++v10;
    }
    while ( v9 != &v32 );
    v16 = *(_WORD *)(v2 + 6);
    v17 = *(_WORD *)(a1 + v3);
    v29 = v16 + v17;
    v18 = *(_WORD *)(v2 + 12);
    v19 = v18 + v16;
    v20 = v18 + v17;
    v21 = &v33;
    v31 = v20;
    v22 = (char *)&v29;
    v30 = v19;
    do
    {
      v23 = (*(_DWORD *)v22 & 1) + (*(_DWORD *)v22 >> 1);
      *(_DWORD *)v22 = v23;
      v22 += 4;
      *v21 = v23;
      ++v21;
    }
    while ( v22 != &v32 );
    v29 = *(_WORD *)(v2 + 12) - v33;
    v30 = *(_WORD *)(a1 + v3) - v34;
    v31 = *(_WORD *)(v2 + 6) - v35;
    v24 = &v32;
    do
    {
      v26 = *(_DWORD *)v11;
      v11 += 4;
      v25 = v26;
      if ( v26 < 0 )
        *((_DWORD *)v11 - 1) = -v25;
      *(_WORD *)v24 = *((_WORD *)v11 - 2);
      v24 += 2;
    }
    while ( v11 != &v32 );
    v28 = v36;
    if ( v37 <= (signed int)v36 )
    {
      v27 = 0;
    }
    else
    {
      v28 = v37;
      v27 = 1;
    }
    v2 += 2;
    if ( v38 > (signed __int16)v28 )
      v27 = 2;
    *(_WORD *)(a2 + v3) = *((_WORD *)&v39 + v27 - 8);
    v3 += 2;
  }
  while ( v3 != 6 );
  LOWORD(result) = 1;
  return (signed __int16)result;
}

//----- (00004D48) --------------------------------------------------------
int __fastcall AKSC_sqrt16(int a1)
{
  int result; // r0@2
  int v2; // r2@3
  __int16 v3; // r0@3
  unsigned __int16 v4; // r3@3
  unsigned int v5; // r1@3
  unsigned int v6; // r4@4

  if ( a1 >= 0 )
  {
    LOWORD(v5) = 2 * a1;
    LOWORD(v2) = 0;
    v3 = 0;
    v4 = 0;
    v5 = (unsigned __int16)v5;
    do
    {
      v3 *= 2;
      v4 = 4 * v4 + (v5 >> 14);
      v6 = (unsigned __int16)(v3 + 1);
      v5 = (unsigned __int16)(4 * v5);
      if ( v6 <= v4 )
      {
        v4 -= v6;
        v3 += 2;
      }
      v2 = (unsigned __int16)(v2 + 1);
    }
    while ( v2 != 8 );
    LOWORD(result) = (unsigned __int16)(result + 2) >> 2;
  }
  else
  {
    LOWORD(result) = 0;
  }
  return (signed __int16)result;
}

//----- (00004D94) --------------------------------------------------------
int __fastcall AKSC_sqrt32(unsigned int a1)
{
  int v1; // r3@2
  int v2; // r1@3
  unsigned int v3; // r3@3
  unsigned int v4; // r2@3

  if ( (a1 & 0x80000000) == 0 )
  {
    LOWORD(v2) = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      v3 *= 2;
      v4 = (a1 >> 30) + 4 * v4;
      a1 *= 4;
      if ( v3 + 1 <= v4 )
      {
        v4 -= v3 + 1;
        v3 += 2;
      }
      v2 = (unsigned __int16)(v2 + 1);
    }
    while ( v2 != 16 );
    v1 = (v3 >> 1) & 0xFFFF;
  }
  else
  {
    LOWORD(v1) = 0;
  }
  return (signed __int16)v1;
}

//----- (00004DCC) --------------------------------------------------------
int __fastcall AKSC_angRng(int result, int a2)
{
  signed int v2; // r3@2
  signed int v3; // r3@7

  if ( result < 0 )
  {
    v3 = 16;
    do
    {
      if ( result < -(23040 << v3) )
        result += 23040 << v3;
      --v3;
    }
    while ( v3 != -1 );
    result += 23040;
  }
  else
  {
    v2 = 16;
    do
    {
      if ( result >= 23040 << v2 )
        result -= 23040 << v2;
      --v2;
    }
    while ( v2 != -1 );
  }
  if ( a2 == 1 && result >= 11520 )
    LOWORD(result) = result - 23040;
  return (signed __int16)result;
}

//----- (00004E1C) --------------------------------------------------------
unsigned int __fastcall AKSC_sin(int a1)
{
  signed int v1; // r0@1
  signed __int16 v2; // r1@2
  unsigned int v3; // r3@6
  unsigned int v4; // r0@7
  int v5; // r3@8
  unsigned int result; // r0@9

  v1 = (unsigned __int16)AKSC_angRng(a1, 0);
  if ( (signed __int16)v1 > 11520 )
  {
    v2 = -1;
    v1 = (unsigned __int16)(v1 - 11520);
  }
  else
  {
    v2 = 1;
  }
  if ( v1 > 5760 )
    LOWORD(v1) = 11520 - v1;
  v1 = (signed __int16)v1;
  v3 = ((unsigned int)((signed __int16)v1 + 31) >> 6) & 0xFFFF;
  if ( v3 )
  {
    v5 = (signed __int16)((unsigned int)((signed __int16)v1 + 31) >> 6);
    if ( (signed __int16)v5 <= 89 )
    {
      result = ((unsigned int)(word_57E8[v5 - 1] * ((v5 << 6) - v1 + 32) + word_57E8[v5] * (v1 + 32 * (-2 * v5 + 1))) >> 6) & 0xFFFF;
      goto LABEL_12;
    }
    v4 = 0x7FFF * (v1 + 32 * (-2 * v5 + 1)) + 32766 * ((v5 << 6) - v1);
  }
  else
  {
    v4 = 286 * v1;
  }
  result = (v4 >> 5) & 0xFFFF;
LABEL_12:
  if ( v2 == -1 )
    LOWORD(result) = -(signed __int16)result;
  return (signed __int16)result;
}

//----- (00004ED0) --------------------------------------------------------
int __fastcall AKSC_cos(signed int a1)
{
  __int16 v1; // r0@2

  if ( a1 < 17280 )
    v1 = a1 + 5760;
  else
    v1 = a1 - 17280;
  return (signed __int16)AKSC_sin(v1);
}

//----- (00004EEC) --------------------------------------------------------
unsigned int __fastcall sub_4EEC(int a1)
{
  unsigned int result; // r0@2
  _WORD *v2; // r3@5
  signed int v3; // r4@5
  int v4; // r1@6
  int v5; // t1@6
  int v6; // r2@7

  if ( a1 > 284 )
  {
    if ( a1 <= 32199 )
    {
      v2 = &word_57E8[89];
      v3 = 1;
      do
      {
        v5 = v2[1];
        ++v2;
        v4 = v5;
        if ( (signed __int16)v5 <= a1 )
        {
          v6 = v2[1];
          if ( a1 < (signed __int16)v6 )
            return (signed __int16)((v3 << 6)
                                  - 32
                                  + (((signed __int16)AKSC_div16((signed __int16)(a1 - v4), v6 - v4) + 256) >> 9));
        }
        v3 = (unsigned __int16)(v3 + 1);
      }
      while ( v3 != 45 );
      LOWORD(result) = 0;
    }
    else
    {
      result = ((AKSC_div16((signed __int16)(a1 - 32200), 567) + 512) >> 10) + 2848;
    }
  }
  else
  {
    result = ((unsigned int)((signed __int16)AKSC_div16(a1, 285) + 512) >> 10) & 0xFFFF;
  }
  return (signed __int16)result;
}

//----- (00004F84) --------------------------------------------------------
int __fastcall AKSC_atan2(int a1, int a2)
{
  signed int v2; // r5@2
  signed int v3; // r4@5
  int v4; // r3@8
  signed __int16 v5; // r3@11
  __int16 v6; // r0@12
  unsigned int v7; // r6@14
  __int16 v8; // r0@17
  __int16 v9; // r0@20
  __int16 v10; // r0@23
  int v11; // r2@25
  __int16 v12; // r0@28
  int v13; // r1@30
  __int16 v14; // r0@33
  __int16 v15; // r0@36
  __int16 v16; // r0@39
  int v18; // [sp+4h] [bp-14h]@1

  v18 = a2;
  if ( a1 == -32768 )
    v2 = 32769;
  else
    v2 = (unsigned __int16)a1;
  if ( a2 == -32768 )
    v3 = 32769;
  else
    v3 = (unsigned __int16)a2;
  if ( (signed __int16)v2 >= (signed __int16)v3 )
    v4 = (signed __int16)v3 > 0;
  else
    v4 = 0;
  if ( v4 )
  {
    v6 = AKSC_div16f((signed __int16)v3, (signed __int16)v2, (__int16 *)&v18 + 1);
    v5 = sub_4EEC(v6 >> SBYTE2(v18));
  }
  else
  {
    v5 = -1;
  }
  if ( (signed __int16)v2 < (signed __int16)v3 )
    v7 = ((unsigned int)~v2 >> 15) & 1;
  else
    v7 = 0;
  if ( v7 )
  {
    v8 = AKSC_div16f((signed __int16)v2, (signed __int16)v3, (__int16 *)&v18 + 1);
    v5 = 5760 - sub_4EEC(v8 >> SBYTE2(v18));
LABEL_22:
    if ( -(signed __int16)v2 > (signed __int16)v3 )
    {
      v10 = AKSC_div16f((signed __int16)v3, (signed __int16)-(signed __int16)v2, (__int16 *)&v18 + 1);
      v5 = 11520 - sub_4EEC(v10 >> SBYTE2(v18));
    }
    goto LABEL_24;
  }
  if ( (signed __int16)v2 < 0 && -(signed __int16)v2 <= (signed __int16)v3 )
  {
    v9 = AKSC_div16f((signed __int16)-(signed __int16)v2, (signed __int16)v3, (__int16 *)&v18 + 1);
    v5 = sub_4EEC(v9 >> SBYTE2(v18)) + 5760;
  }
  if ( !(v3 & 0x8000) )
    goto LABEL_22;
LABEL_24:
  if ( (signed __int16)v2 <= v3 )
    v11 = ((unsigned int)v3 >> 15) & 1;
  else
    v11 = 0;
  if ( v11 )
  {
    v12 = AKSC_div16f((signed __int16)-(signed __int16)v3, (signed __int16)-(signed __int16)v2, (__int16 *)&v18 + 1);
    v5 = sub_4EEC(v12 >> SBYTE2(v18)) + 11520;
  }
  if ( (signed __int16)v2 > (signed __int16)v3 )
    v13 = (signed __int16)v2 <= 0;
  else
    v13 = 0;
  if ( v13 )
  {
    v14 = AKSC_div16f((signed __int16)-(signed __int16)v2, (signed __int16)-(signed __int16)v3, (__int16 *)&v18 + 1);
    v5 = 17280 - sub_4EEC(v14 >> SBYTE2(v18));
LABEL_38:
    if ( -(signed __int16)v2 < v3 )
    {
      v16 = AKSC_div16f((signed __int16)-(signed __int16)v3, (signed __int16)v2, (__int16 *)&v18 + 1);
      v5 = 23040 - sub_4EEC(v16 >> SBYTE2(v18));
    }
    goto LABEL_40;
  }
  if ( (signed __int16)v2 > 0 && -(signed __int16)v2 >= (signed __int16)v3 )
  {
    v15 = AKSC_div16f((signed __int16)v2, (signed __int16)-(signed __int16)v3, (__int16 *)&v18 + 1);
    v5 = sub_4EEC(v15 >> SBYTE2(v18)) + 17280;
  }
  if ( (signed __int16)v3 <= 0 )
    goto LABEL_38;
LABEL_40:
  if ( v5 == 23040 )
    v5 = 0;
  return v5;
}

//----- (00005148) --------------------------------------------------------
int __fastcall AKSC_invSqrt(signed int a1, _WORD *a2, int a3, __int16 a4)
{
  signed int v4; // r4@3
  _WORD *v5; // r5@3
  int result; // r0@4
  unsigned __int16 v7; // r0@5
  signed int v8; // r4@5
  int v15; // r5@7
  char v17; // r2@7
  int v18; // r1@7
  int v19; // r0@7

  if ( a1 <= 0 )
    a4 = 0;
  v4 = a1;
  v5 = a2;
  if ( a1 > 0 )
  {
    v7 = AKSC_norm32(a1);
    v8 = v4 << v7;
    _R12 = 30 - v7;
    __asm { SBFX.W          R0, R12, #1, #0xF }
    if ( !_NF )
      v8 >>= 1;
    *v5 = _R0 + 1;
    v15 = (v8 >> 25) - 16;
    _R4 = ((unsigned int)v8 >> 10) & 0x7FFF;
    v17 = _R0 + 1;
    v18 = word_5784[v15];
    v19 = (signed __int16)v18;
    _R1 = v18 - word_5784[v15 + 1];
    __asm { SMULBB.W        R4, R1, R4 }
    result = 2 * ((v19 << 15) - _R4) >> v17;
  }
  else
  {
    *a2 = a4;
    result = 0x40000000;
  }
  return result;
}

//----- (000051B8) --------------------------------------------------------
char *__fastcall AKSC_buffer(char *result, int a2, int a3, int a4)
{
  signed int v4; // r6@1
  char *v5; // r10@3
  int v6; // r4@3
  int v7; // r7@3
  int v8; // r5@4
  int v16; // r9@4
  int v17; // r8@4
  void *v18; // r0@5
  const void *v19; // r1@5
  int v22; // r5@7
  int v23; // r7@7
  int v24; // r10@7
  void *v25; // r0@8
  const void *v26; // r1@8

  v4 = a3 <= 0;
  if ( a2 < a3 )
    v4 = 1;
  v5 = result;
  v6 = a3;
  v7 = a4;
  if ( !v4 )
  {
    LOWORD(v8) = a2;
    _R2 = 6;
    _R1 = (unsigned __int16)a2 - 1;
    __asm { SMULBB.W        R0, R1, R2 }
    v16 = a4 + _R0;
    v17 = _R0 + -6 * v6 + a4;
    while ( 1 )
    {
      v8 = (unsigned __int16)(v8 - 1);
      if ( v8 < v6 )
        break;
      v18 = (void *)(v16 + v4);
      v19 = (const void *)(v17 + v4);
      v4 -= 6;
      memcpy(v18, v19, 6u);
    }
    _R3 = 6;
    _R1 = (unsigned __int16)v6 - 1;
    v22 = 0;
    __asm { SMULBB.W        R0, R1, R3 }
    v23 = (int)&result[v7];
    v24 = (int)&result[(_DWORD)v5];
    while ( 1 )
    {
      LOWORD(v6) = v6 - 1;
      if ( v6 & 0x8000 )
        break;
      v25 = (void *)(v23 + v22);
      v26 = (const void *)(v24 + v22);
      v22 -= 6;
      result = (char *)memcpy(v25, v26, 6u);
    }
  }
  return result;
}

//----- (0000523C) --------------------------------------------------------
int __fastcall AKSC_vectorCalc(int result, signed int a2, int a3, int a4, int a5, int a6)
{
  int v6; // r4@1
  int v7; // r6@1
  signed int v8; // r7@2
  int v9; // r5@2
  signed int v10; // r8@8
  int v11; // r8@9
  int v12; // r5@12

  v6 = 0;
  v7 = 0;
  do
  {
    v8 = 1;
    *(_WORD *)(a4 + v6) = *(_WORD *)(result + v6);
    *(_WORD *)(a3 + v6) = *(_WORD *)(result + v6);
    v9 = result + 2 * v7;
    while ( 1 )
    {
      v10 = *(_WORD *)(a4 + v6);
      if ( v8 >= a2 )
        break;
      if ( v10 > *(_WORD *)(v9 + 6) )
        *(_WORD *)(a4 + v6) = *(_WORD *)(v9 + 6);
      if ( *(_WORD *)(a3 + v6) < (signed int)*(_WORD *)(v9 + 6) )
        *(_WORD *)(a3 + v6) = *(_WORD *)(v9 + 6);
      v9 += 6;
      v8 = (unsigned __int16)(v8 + 1);
    }
    v11 = ((signed int)*(_WORD *)(a3 + v6) >> 1) + (v10 >> 1);
    *(_WORD *)(a5 + v6) = v11;
    if ( *(_WORD *)(a3 + v6) & 1 || *(_WORD *)(a4 + v6) & 1 )
      *(_WORD *)(a5 + v6) = v11 + 1;
    v12 = (unsigned __int16)(*(_WORD *)(a3 + v6) - *(_WORD *)(a4 + v6));
    *(_WORD *)(a6 + v6) = v12;
    if ( v12 << 16 < 0 )
      *(_WORD *)(a6 + v6) = 0x7FFF;
    v6 += 2;
    ++v7;
  }
  while ( v6 != 6 );
  return result;
}

//----- (000052E0) --------------------------------------------------------
signed int AKSC_GetVersion_Major()
{
  return 1;
}

//----- (000052E4) --------------------------------------------------------
int AKSC_GetVersion_Variation()
{
  return 0;
}

//----- (000052E8) --------------------------------------------------------
signed int AKSC_GetVersion_DateCode()
{
  return 809;
}

// ALL OK, 66 function(s) have been successfully decompiled
